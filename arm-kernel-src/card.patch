diff -Nur drivers/amlogic/cardreader/card_block.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/card_block.c
--- drivers/amlogic/cardreader/card_block.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/card_block.c	2011-07-14 00:17:51.976739983 +0800
@@ -16,26 +16,29 @@
 #include <linux/mutex.h>
 #include <linux/scatterlist.h>
 #include <linux/err.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/proc_fs.h>
 #include <linux/genhd.h>
+#include <linux/kthread.h>
 #include <linux/cardreader/card_block.h>
-
+#include <linux/cardreader/cardreader.h>
 #include <asm/system.h>
 #include <asm/uaccess.h>
 
-#include <mach/am_regs.h>
-#include <linux/dma-mapping.h>
-#include <asm/cacheflush.h>
-#include <linux/sched.h>
 
 static int major;
-#define CARD_SHIFT	3
+#define CARD_SHIFT	4
 #define CARD_QUEUE_EXIT		(1 << 0)
 #define CARD_QUEUE_SUSPENDED	(1 << 1)
 
 #define CARD_QUEUE_BOUNCESZ	(512*256)
 
 #define CARD_NUM_MINORS	(256 >> CARD_SHIFT)
-static unsigned long dev_use[CARD_NUM_MINORS / (8 * sizeof(unsigned long))];
+//static unsigned long dev_use[CARD_NUM_MINORS / (8 * sizeof(unsigned long))];
+static unsigned long dev_use[1];
+
+#define CARD_INAND_START_MINOR		40
 
 static int card_blk_issue_rq(struct card_queue *cq, struct request *req);
 static int card_blk_probe(struct memory_card *card);
@@ -57,6 +60,11 @@
 static struct completion card_thread_complete;
 static wait_queue_head_t card_thread_wq;
 static struct semaphore card_thread_sem;
+/*wait device delete*/
+struct completion card_devdel_comp;
+
+/*sdio irq flag*/
+unsigned char sdio_irq_handled=0;
 
 struct card_queue_list {
 	int cq_num;
@@ -71,18 +79,19 @@
 	struct card_queue_list *cq_node_current = card_queue_head;
 	struct card_queue_list *cq_node_prev = NULL;
 
-	do {
+	while (cq_node_current != NULL){
 		if (cq_node_current->cq == cq)
 			break;
 
 		cq_node_prev = cq_node_current;
 		cq_node_current = cq_node_current->cq_next;
-	} while (cq_node_current != NULL);
+	}
 
 	if (cq_node_current == card_queue_head) {
 		if (cq_node_current->cq_next == NULL) {
 			cq->flags |= CARD_QUEUE_EXIT;
 			wake_up_interruptible(&card_thread_wq);
+			up(&card_thread_sem);
 			wait_for_completion(&card_thread_complete);
 		} else {
 			card_queue_head->cq_num = 0;
@@ -95,7 +104,7 @@
 	kfree(cq->sg);
 	cq->sg = NULL;
 
-	blk_cleanup_queue(cq->queue);
+	//blk_cleanup_queue(cq->queue);
 
 	cq->card = NULL;
 
@@ -126,8 +135,11 @@
 	card_data->usage--;
 	if (card_data->usage == 0) {
 		put_disk(card_data->disk);
-		card_cleanup_queue(&card_data->queue);
+		//card_cleanup_queue(&card_data->queue);
+		blk_cleanup_queue(card_data->queue.queue);
+		card_data->disk->queue = NULL;
 		kfree(card_data);
+		complete(&card_devdel_comp);
 	}
 	mutex_unlock(&open_lock);
 }
@@ -175,8 +187,8 @@
 
 static inline int card_claim_card(struct memory_card *card)
 {
-	if(cr_mon.card_status[card->card_type] == CARD_REMOVED)
-		return ENODEV;
+	if(card->card_status == CARD_REMOVED)
+		return -ENODEV;
 	return __card_claim_host(card->host, card);
 }
 
@@ -185,6 +197,11 @@
 	struct card_queue *cq = q->queuedata;
 	int ret = BLKPREP_KILL;
 
+	if (!cq) {
+		printk(KERN_ERR "[card_prep_request] %s: killing request - no device/host\n", req->rq_disk->disk_name);
+		return BLKPREP_KILL;
+	}
+	
 	if (blk_special_request(req)) {
 		/*
 		 * Special commands already have the command
@@ -217,14 +234,18 @@
 	struct card_queue *cq = q->queuedata;
 	struct card_queue_list *cq_node_current = card_queue_head;
 
-	do {
-		if (cq_node_current->cq == cq) {
+	WARN_ON(!cq);
+	WARN_ON(!cq_node_current);
+	WARN_ON(!cq_node_current->cq);
+
+	while (cq_node_current != NULL){
+		if (cq && cq_node_current->cq == cq) {
 			cq_node_current->cq_flag = 1;
 			break;
 		}
 
 		cq_node_current = cq_node_current->cq_next;
-	} while (cq_node_current != NULL);
+	}
 
 	if (card_thread_sleep_flag) {
 		card_thread_sleep_flag = 0;
@@ -269,6 +290,7 @@
 	struct card_queue *cq = d;
 	struct request_queue *q = cq->queue;
 	struct card_queue_list *cq_node_current;
+	unsigned char rewait;
 	DECLARE_WAITQUEUE(wait, current);
 
 	daemonize("card_queue_thread");
@@ -287,10 +309,14 @@
 
 		spin_lock_irq(q->queue_lock);
 		cq_node_current = card_queue_head;
+		WARN_ON(!card_queue_head);
 		while (cq_node_current != NULL) {
 			cq = cq_node_current->cq;
 			q = cq->queue;
 			if (cq_node_current->cq_flag) {
+				/*wait sdio handle irq & xfer data*/
+				for(rewait=3;(!sdio_irq_handled)&&(rewait--);)
+					schedule();
 				req = blk_fetch_request(q);
 				if (req)
 					break;
@@ -304,21 +330,24 @@
 		cq->req = req;
 		spin_unlock_irq(q->queue_lock);
 
+		if (cq->flags & CARD_QUEUE_EXIT)
+			break;
+		
 		if (!req) {
-			if (cq->flags & CARD_QUEUE_EXIT)
-				break;
 
 			if (cq_node_current == NULL) {
 				up(&card_thread_sem);
 				card_thread_sleep_flag = 1;
 				interruptible_sleep_on(&card_thread_wq);
 				//schedule();
-				down(&card_thread_sem);
+				down_interruptible(&card_thread_sem);
 			}
 			continue;
 		}
 
 		cq->issue_fn(cq, req);
+		/*yield*/
+		cond_resched();
 	} while (1);
 	remove_wait_queue(&card_thread_wq, &wait);
 	up(&card_thread_sem);
@@ -331,186 +360,6 @@
 #define CONFIG_CARD_BLOCK_BOUNCE 1
 
 #ifdef CONFIG_CARD_BLOCK_BOUNCE
-
-static dma_addr_t card_desc[PAGE_SIZE>>2];
-/*
- * ndmacpy - memcpy with ndma module
- */
-void card_ndma_copy(void *to, void *from, size_t n, int to_buffer)
-{
-	dma_addr_t dma_desc=0;
-
-	BUG_ON(n > CARD_QUEUE_BOUNCESZ);
-	
-	// Add a descriptor to SDRAM at locations vdesc
-	//CONTROL: Descriptor Entry 0
-	card_desc[0] = (0<<30)|(1<<8);/*thread id 0 & no break*/
-	//SOURCE POINTER: Descriptor Entry 1
-	card_desc[1] = (dma_addr_t)from;
-	//DESTINATION POINTER: Descriptor Entry 2
-	card_desc[2] = (dma_addr_t)to;
-	//Bytes to Transfer: Descriptor Entry 3
-	card_desc[3] = n;
-
-	dmac_map_area(card_desc, PAGE_SIZE, DMA_TO_DEVICE);
-	dma_desc = virt_to_dma(NULL, card_desc);
-
-	dmac_map_area(phys_to_virt(from), n, DMA_FROM_DEVICE);
-	dmac_map_area(phys_to_virt(to), n, DMA_FROM_DEVICE);
-	
-	//reset table add reg
-	WRITE_CBUS_REG(NDMA_TABLE_ADD_REG, 0);
-	
-	//set thread 0 start descriptor addr
-	WRITE_CBUS_REG(NDMA_THREAD_TABLE_START0, dma_desc);
-	//set thread 0 end descriptor addr
-	WRITE_CBUS_REG(NDMA_THREAD_TABLE_END0, dma_desc+0x10);
-	
-	//init thread 0
-	WRITE_CBUS_REG(NDMA_THREAD_REG, 0x1<<24|0x1<<8|1);
-
-	// Indicate we just added a descriptor
-	WRITE_CBUS_REG(NDMA_TABLE_ADD_REG, 1);
-	// Enable the DMA Engine
-	WRITE_CBUS_REG(NDMA_CNTL_REG0, 1<<NDMA_ENABLE| 0x63<<16);
-
-	// Wait for DMA to complete (or use interrupts)
-	while(READ_CBUS_REG(NDMA_CNTL_REG0) & (1<<NDMA_STATUS)){
-		asm("nop");
-	}
-	
-	return ;
-}
-
-/**
- * sg_miter_next - proceed mapping iterator to the next mapping
- * @miter: sg mapping iter to proceed
- *
- * Description:
- *   Proceeds @miter@ to the next mapping.  @miter@ should have been
- *   started using sg_miter_start().  On successful return,
- *   @miter@->page, @miter@->addr and @miter@->length point to the
- *   current mapping.
- *
- * Context:
- *   IRQ disabled if SG_MITER_ATOMIC.  IRQ must stay disabled till
- *   @miter@ is stopped.  May sleep if !SG_MITER_ATOMIC.
- *
- * Returns:
- *   true if @miter contains the next mapping.  false if end of sg
- *   list is reached.
- */
-bool card_sg_miter_next(struct sg_mapping_iter *miter)
-{
-	unsigned int off, len;
-
-	/* check for end and drop resources from the last iteration */
-	if (!miter->__nents)
-		return false;
-
-	sg_miter_stop(miter);
-
-	/* get to the next sg if necessary.  __offset is adjusted by stop */
-	while (miter->__offset == miter->__sg->length) {
-		if (--miter->__nents) {
-			miter->__sg = sg_next(miter->__sg);
-			miter->__offset = 0;
-		} else
-			return false;
-	}
-
-	/* map the next page */
-	off = miter->__sg->offset + miter->__offset;
-	len = miter->__sg->length - miter->__offset;
-
-	miter->page = nth_page(sg_page(miter->__sg), off >> PAGE_SHIFT);
-	off &= ~PAGE_MASK;
-	//miter->length = min_t(unsigned int, len, PAGE_SIZE - off);
-	/*no need to copy every page, so copy every sg->length*/
-	miter->length = len;
-	
-	miter->consumed = miter->length;
-
-	if (miter->__flags & SG_MITER_ATOMIC)
-		miter->addr = kmap_atomic(miter->page, KM_BIO_SRC_IRQ) + off;
-	else
-		miter->addr = kmap(miter->page) + off;
-
-	return true;
-}
-
-static size_t card_sg_copy_buffer(struct scatterlist *sgl, unsigned int nents,
-			     void *buf, size_t buflen, int to_buffer)
-{
-	unsigned int offset = 0;
-	struct sg_mapping_iter miter;
-	unsigned long flags;
-	unsigned int sg_flags = SG_MITER_ATOMIC;
-
-	if (to_buffer)
-		sg_flags |= SG_MITER_FROM_SG;
-	else
-		sg_flags |= SG_MITER_TO_SG;
-
-	sg_miter_start(&miter, sgl, nents, sg_flags);
-
-	local_irq_save(flags);
-
-	while (card_sg_miter_next(&miter) && offset < buflen) {
-		unsigned int len;
-
-		len = min(miter.length, buflen - offset);
-
-		if (to_buffer)
-			card_ndma_copy(buf + offset, virt_to_phys(miter.addr), len, to_buffer);
-		else
-			card_ndma_copy(virt_to_phys(miter.addr), buf + offset, len, to_buffer);
-
-		offset += len;
-	}
-	
-	sg_miter_stop(&miter);
-
-	local_irq_restore(flags);
-	
-	return offset;
-}
-
-
-/**
- * sg_copy_from_buffer_for_sd - Copy from a linear buffer to an SG list
- * @sgl:		 The SG list
- * @nents:		 Number of SG entries
- * @buf:		 Where to copy from
- * @buflen:		 The number of bytes to copy
- *
- * Returns the number of copied bytes.
- *
- **/
-static size_t card_sg_copy_from_buffer(struct scatterlist *sgl, unsigned int nents,
-			   void *buf, size_t buflen)
-{
-	return card_sg_copy_buffer(sgl, nents, buf, buflen, 0);
-}
-
-/**
- * sg_copy_to_buffer - Copy from an SG list to a linear buffer
- * @sgl:		 The SG list
- * @nents:		 Number of SG entries
- * @buf:		 Where to copy to
- * @buflen:		 The number of bytes to copy
- *
- * Returns the number of copied bytes.
- *
- **/
-static size_t card_sg_copy_to_buffer(struct scatterlist *sgl, unsigned int nents,
-			 void *buf, size_t buflen)
-{
-	return card_sg_copy_buffer(sgl, nents, buf, buflen, 1);
-}
-
-
-
 /*
  * Prepare the sg list(s) to be handed of to the host driver
  */
@@ -539,8 +388,6 @@
 	return 1;
 }
 
-extern unsigned char *sd_mmc_phy_buf;
-
 /*
  * If writing, bounce the data to the buffer before the request
  * is sent to the host driver
@@ -549,7 +396,7 @@
 {
 	unsigned long flags;
 
-	if (!cq->bounce_buf || (cq->bounce_sg_len==1))
+	if (!cq->bounce_buf)
 		return;
 
 	if (rq_data_dir(cq->req) != WRITE)
@@ -557,10 +404,10 @@
 	
 	local_irq_save(flags);
 		
-	card_sg_copy_to_buffer(cq->bounce_sg, cq->bounce_sg_len,
-		sd_mmc_phy_buf, cq->sg[0].length);	
+	sg_copy_to_buffer(cq->bounce_sg, cq->bounce_sg_len,
+		cq->bounce_buf, cq->sg[0].length);
 	
-	local_irq_restore(flags);
+	local_irq_restore(flags);	
 }
 
 /*
@@ -570,24 +417,23 @@
 static void card_queue_bounce_post(struct card_queue *cq)
 {
 	unsigned long flags;
-	
-	if (!cq->bounce_buf || (cq->bounce_sg_len==1))
+
+	if (!cq->bounce_buf)
 		return;
 
 	if (rq_data_dir(cq->req) != READ)
 		return;
-
+	
 	local_irq_save(flags);
 	
-	card_sg_copy_from_buffer(cq->bounce_sg, cq->bounce_sg_len,
-		sd_mmc_phy_buf, cq->sg[0].length);
-		
+	sg_copy_from_buffer(cq->bounce_sg, cq->bounce_sg_len,
+		cq->bounce_buf, cq->sg[0].length);
+
 	local_irq_restore(flags);
 	
 	bio_flush_dcache_pages(cq->req->bio);
 }
 
-extern unsigned char *sd_mmc_buf;
 /*
  * Alloc bounce buf for read/write numbers of pages in one request
  */
@@ -595,13 +441,17 @@
 			struct memory_card *card)
 {
 	int ret=0;
+	struct card_host *host = card->host;
 	unsigned int bouncesz;
 
 	bouncesz = CARD_QUEUE_BOUNCESZ;
 
+	if (bouncesz > host->max_req_size)
+		bouncesz = host->max_req_size;
+
 	if (bouncesz >= PAGE_CACHE_SIZE) {
-	//	cq->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
-		cq->bounce_buf = sd_mmc_buf;
+		//cq->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+		cq->bounce_buf = host->dma_buf;
 		if (!cq->bounce_buf) {
 			printk(KERN_WARNING "%s: unable to "
 				"allocate bounce buffer\n", card->name);
@@ -668,7 +518,7 @@
 {
 	struct card_host *host = card->host;
 	u64 limit = BLK_BOUNCE_HIGH;
-	int ret, card_quene_num;
+	int ret=0, card_quene_num;
 	struct card_queue_list *cq_node_current;
 	struct card_queue_list *cq_node_prev = NULL;
 
@@ -719,8 +569,8 @@
 		init_completion(&card_thread_complete);
 		init_waitqueue_head(&card_thread_wq);
 		init_MUTEX(&card_thread_sem);
-		ret = kernel_thread(card_queue_thread, cq, CLONE_KERNEL | SIGCHLD);
-		if (ret >= 0)
+		host->queue_task = kthread_run(card_queue_thread, cq, "card_queue");
+		if (host->queue_task)
 		{
 			wait_for_completion(&card_thread_complete);
 			init_completion(&card_thread_complete);
@@ -766,6 +616,10 @@
 	int devidx, ret;
 
 	devidx = find_first_zero_bit(dev_use, CARD_NUM_MINORS);
+
+	if(card->card_type == CARD_INAND)
+		devidx = CARD_INAND_START_MINOR>>CARD_SHIFT;
+	
 	if (devidx >= CARD_NUM_MINORS)
 		return ERR_PTR(-ENOSPC);
 	__set_bit(devidx, dev_use);
@@ -822,10 +676,11 @@
 	struct card_blk_data *card_data = cq->data;
 	int stat = BLKPREP_OK;
 
+	WARN_ON(!cq->queue->queuedata);
 	/*
 	 * If we have no device, we haven't finished initialising.
 	 */
-	if (!card_data || !cq->card) {
+	if (!card_data || !cq->card || !cq->queue->queuedata) {
 		printk(KERN_ERR "%s: killing request - no device/host\n", req->rq_disk->disk_name);
 		stat = BLKPREP_KILL;
 	}
@@ -840,7 +695,6 @@
 	struct card_blk_request brq;
 	int ret;
 
-	//printk("card issue request %d sector num: %d\n", req->sector, req->nr_sectors);
 	if (card_claim_card(card)) {
 		spin_lock_irq(&card_data->lock);
 		ret = 1;
@@ -853,6 +707,8 @@
 
 	do {
 		brq.crq.cmd = rq_data_dir(req);
+		brq.crq.buf = cq->bounce_buf;
+		//	brq.crq.buf = req->buffer;
 
 		brq.card_data.lba = blk_rq_pos(req);
 		brq.card_data.blk_size = 1 << card_data->block_bits;
@@ -861,13 +717,6 @@
 		brq.card_data.sg = cq->sg;
 
 		brq.card_data.sg_len = card_queue_map_sg(cq);
-
-		if(cq->bounce_sg_len>1)
-			brq.crq.buf = cq->bounce_buf;
-		else
-			brq.crq.buf = req->buffer;
-		//printk("%s %d sg_len %d \t", brq.crq.cmd?"W":"R", brq.card_data.blk_nums, cq->bounce_sg_len);
-
 		//brq.card_data.sg_len = blk_rq_map_sg(req->q, req, brq.card_data.sg);
 
 		card->host->card_type = card->card_type;
@@ -917,7 +766,7 @@
 	} while (ret);
 
 	card_release_host(card->host);
-	//printk("card request completely %d sector num: %d communiction dir %d\n", req->sector, req->nr_sectors, brq.crq.cmd);
+	//printk("card request completely %d sector num: %d communiction dir %d\n", brq.card_data.lba, brq.card_data.blk_nums, brq.crq.cmd);
 	return 1;
 }
 
@@ -933,11 +782,15 @@
 		/*
 		 * I think this is needed.
 		 */
-		card_data->disk->queue = NULL;
+		
+		queue_flag_set_unlocked(QUEUE_FLAG_DEAD, card_data->queue.queue);
+		queue_flag_set_unlocked(QUEUE_FLAG_STOPPED, card_data->queue.queue);
+		card_data->queue.queue->queuedata = NULL;
+		card_cleanup_queue(&card_data->queue);
+		//card_data->disk->queue = NULL;
 
 		devidx = card_data->disk->first_minor >> CARD_SHIFT;
 		__clear_bit(devidx, dev_use);
-
 		card_blk_put(card_data);
 	}
 	card_set_drvdata(card, NULL);
@@ -947,17 +800,61 @@
 static int card_blk_suspend(struct memory_card *card, pm_message_t state)
 {
 	struct card_blk_data *card_data = card_get_drvdata(card);
+	struct card_host *host = card->host;
+	
+	printk("Enter %s suspend\n",card->name);
+	printk("***Entered %s:%s\n", __FILE__,__func__);
 
-	if (card_data) {
+
+	if (card_data) 
+	{
 		card_queue_suspend(&card_data->queue);
 	}
+	if(!host->sdio_task_state)
+	{
+		host->sdio_task_state = 1;
+	}
+	if(!host->card_task_state)
+	{
+		host->card_task_state = 1;
+	}
+	if(card->card_suspend)
+	{
+		card->card_suspend(card);
+	}
+	if(card->card_type == CARD_SDIO)
+		return 0;
+	//card->unit_state = CARD_UNIT_NOT_READY;
+	//host->slot_detector = CARD_REMOVED;
+	card->unit_state = CARD_UNIT_RESUMED;
 	return 0;
 }
 
 static int card_blk_resume(struct memory_card *card)
 {
 	struct card_blk_data *card_data = card_get_drvdata(card);
+	struct card_host *host = card->host;
+	
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+	
+	printk("Enter %s resume\n",card->name);
 
+	if(card->card_resume)
+	{
+		card->card_resume(card);
+	}
+	if(host->card_task_state)
+	{
+		host->card_task_state = 0;
+		if(host->card_task)
+			wake_up_process(host->card_task);
+	}
+	if(host->sdio_task_state)
+	{
+		host->sdio_task_state = 0;
+		if(host->sdio_irq_thread)
+			wake_up_process(host->sdio_irq_thread);
+	}
 	if (card_data) {
 		//mmc_blk_set_blksize(md, card);
 		card_queue_resume(&card_data->queue);
@@ -969,16 +866,119 @@
 #define card_blk_resume		NULL
 #endif
 
+#ifdef CONFIG_PROC_FS
+
+/*====================================================================*/
+/* Support for /proc/mtd */
+
+static struct proc_dir_entry *proc_card;
+struct mtd_partition *card_table[MAX_MTD_DEVICES];
+
+static inline int card_proc_info (char *buf, char* dev_name, int i)
+{
+	struct mtd_partition *this = card_table[i];
+
+	if (!this)
+		return 0;
+
+	return sprintf(buf, "%s%d: %8.8llx %8.8x \"%s\"\n", dev_name,
+		        i+1,(unsigned long long)this->size,
+		       CARD_QUEUE_BOUNCESZ, this->name);
+}
+
+static int card_read_proc (char *page, char **start, off_t off, int count,
+			  int *eof, void *data_unused)
+{
+	int len, l, i;
+        off_t   begin = 0;
+
+	len = sprintf(page, "dev:    size   erasesize  name\n");
+        for (i=0; i< MAX_MTD_DEVICES; i++) {
+
+                l = card_proc_info(page + len, "inand", i);
+                len += l;
+                if (len+begin > off+count)
+                        goto done;
+                if (len+begin < off) {
+                        begin += len;
+                        len = 0;
+                }
+        }
+
+        *eof = 1;
+
+done:
+        if (off >= len+begin)
+                return 0;
+        *start = page + (off-begin);
+        return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+#endif /* CONFIG_PROC_FS */
+
+/**
+ * add_card_partition : add card partition , refer to 
+ * board-****.c  inand_partition_info[]
+ * @disk: add partitions in which disk
+ * @part: partition table
+ * @nr_part: partition numbers
+ */
+int add_card_partition(struct gendisk * disk, struct mtd_partition * part, 
+				unsigned int nr_part)
+{
+	unsigned int i;
+	struct hd_struct * ret;
+	uint64_t cur_offset=0;
+	uint64_t offset, size;
+	
+	if(!part)
+		return 0;
+
+	for(i=0; i<nr_part; i++){
+		offset = part[i].offset>>9;
+		size = part[i].size>>9;
+		if (part[i].offset== MTDPART_OFS_APPEND)
+			offset = cur_offset;
+		if (part[i].size == MTDPART_SIZ_FULL)
+			size = disk->part0.nr_sects - offset;
+		ret = add_partition(disk, 1+i, offset, size, 0);
+		printk("[%s] %20s  offset 0x%012llx, len 0x%012llx %s\n", 
+				disk->disk_name, part[i].name, offset<<9, size<<9, 
+				IS_ERR(ret) ? "add fail":"");
+		//if(IS_ERR(ret)){
+		//	printk("errno = %d, offset = %x, size = %x, disk->part0.nr_sects = %x\n", ret, offset, size);
+		//	return ERR_PTR(ret);
+		//}
+		cur_offset = offset + size;
+		
+		card_table[i] = &part[i];
+		card_table[i]->offset = offset<<9;
+		card_table[i]->size = size<<9;
+	}
+
+#ifdef CONFIG_PROC_FS
+	if (!proc_card && (proc_card = create_proc_entry( "inand", 0, NULL )))
+		proc_card->read_proc = card_read_proc;
+#endif /* CONFIG_PROC_FS */
+
+	return 0;
+}
+
+
 static int card_blk_probe(struct memory_card *card)
 {
 	struct card_blk_data *card_data;
+	struct aml_card_info *pinfo = card->card_plat_info;
 
 	card_data = card_blk_alloc(card);
 	if (IS_ERR(card_data))
 		return PTR_ERR(card_data);
 
 	card_set_drvdata(card, card_data);
+
 	add_disk(card_data->disk);
+	add_card_partition(card_data->disk, pinfo->partitions,
+			pinfo->nr_partitions);
 
 	return 0;
 }
diff -Nur drivers/amlogic/cardreader/card_io.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/card_io.c
--- drivers/amlogic/cardreader/card_io.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/card_io.c	2011-07-14 00:17:51.976739983 +0800
@@ -6,10 +6,7 @@
 #include <mach/irqs.h>
 #include <mach/card_io.h>
     
-
 int i_GPIO_timer;
-unsigned SD_WORK_MODE = CARD_HW_MODE;
-unsigned MS_WORK_MODE = CARD_HW_MODE;
 int ATA_MASTER_DISABLED = 0;
 int ATA_SLAVE_ENABLED = 0;
 unsigned ATA_EIGHT_BIT_ENABLED = 1;
@@ -27,6 +24,78 @@
 /**/ void (*cf_reset_register) (int reset_high) = NULL;
 /**/ int (*cf_ins_register) (void) = NULL;
 /**/ void (*cf_io_release_register) (void) = NULL;
+/* */ void (*ms_mspro_power_register) (int power_on) = NULL;
+/* */ int (*ms_mspro_ins_register) (void) = NULL;
+/* */ int (*ms_mspro_wp_register) (void) = NULL;
+/* */ void (*ms_mspro_io_release_register) (void) = NULL;
+
+void sd_sdio_enable(SDIO_Pad_Type_t io_pad_type)
+{
+	switch (io_pad_type) {
+
+		case SDIO_GPIOA_0_5:
+			SET_CBUS_REG_MASK(CARD_PIN_MUX_1, 0x3F);
+			SET_CBUS_REG_MASK(SDIO_MULT_CONFIG, (1));
+			break;
+
+		case SDIO_GPIOA_9_14:
+			//CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_2, ((0xF<<16) | (1<<8) | (1<<12)));
+			SET_CBUS_REG_MASK(CARD_PIN_MUX_0, (0x3F<<23));
+			SET_CBUS_REG_MASK(SDIO_MULT_CONFIG, (0));
+			break;
+
+		case SDIO_GPIOB_2_7:
+			CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_0, (0x3F<<23));
+			//CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_5, ((1<<5)));
+			SET_CBUS_REG_MASK(CARD_PIN_MUX_2, ((0xF<<16) | (1<<8) | (1<<12)));
+			SET_CBUS_REG_MASK(SDIO_MULT_CONFIG, (2));
+			break;
+
+		case SDIO_GPIOE_6_11:
+			SET_CBUS_REG_MASK(CARD_PIN_MUX_7, ((0xF<<26) | (1<<24)));
+			SET_CBUS_REG_MASK(SDIO_MULT_CONFIG, (1));
+			break;
+
+		default :
+			printk("invalid hw io pad!!!\n");
+			break;
+	}
+	
+	return;
+}
+
+void sd_gpio_enable(SDIO_Pad_Type_t io_pad_type)
+{
+	switch (io_pad_type) {
+
+		case SDIO_GPIOA_0_5:
+			CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_1, 0x3F);
+			CLEAR_CBUS_REG_MASK(SDIO_MULT_CONFIG, (1));
+			break;
+
+		case SDIO_GPIOA_9_14:
+			CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_0, (0x3F<<23));
+			CLEAR_CBUS_REG_MASK(SDIO_MULT_CONFIG, (0));
+			//SET_CBUS_REG_MASK(CARD_PIN_MUX_2, ((0xF<<16) | (1<<8) | (1<<12)));
+			break;
+
+		case SDIO_GPIOB_2_7:
+			CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_2, ((0xF<<16) | (1<<8) | (1<<12)));
+			CLEAR_CBUS_REG_MASK(SDIO_MULT_CONFIG, (2));
+			break;
+
+		case SDIO_GPIOE_6_11:
+			CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_7, ((0xF<<26) | (1<<24)));
+			CLEAR_CBUS_REG_MASK(SDIO_MULT_CONFIG, (1));
+			break;
+
+		default :
+			printk("invalid hw io pad!!!\n");
+			break;
+	}
+	
+	return;
+}
 
 void sdio_open_host_interrupt(unsigned int_resource) 
 {	
@@ -151,6 +220,7 @@
 		status_irq_reg->cmd_int = 1;
 		status_irq_reg->arc_timing_out_int_en = 0;	
 		status_irq_reg->timing_out_int = 1;	
+		status_irq_reg->timing_out_count = 0;
 		WRITE_CBUS_REG(SDIO_STATUS_IRQ, status_irq);	
 		return SDIO_CMD_INT;	
 	}
@@ -161,6 +231,8 @@
 		return SDIO_TIMEOUT_INT;	
 	}
 	else if (status_irq_reg->if_int) {	
+		/*close IF INT before clear if int, avoid IF INT twice*/
+		sdio_close_host_interrupt(SDIO_IF_INT);
 		status_irq_reg->if_int = 1;		
 		WRITE_CBUS_REG(SDIO_STATUS_IRQ, status_irq);		
 		return SDIO_IF_INT;		
@@ -171,22 +243,37 @@
 		return SDIO_NO_INT;
 }
 
-void sdio_cmd_int_handle(void) 
+void sdio_if_int_handler(struct card_host *host) 
+{
+	sdio_irq_handled = 0;
+	if (host->caps & CARD_CAP_SDIO_IRQ){
+		//sdio_close_host_interrupt(SDIO_IF_INT);
+		if(host->sdio_irq_thread)
+			wake_up_process(host->sdio_irq_thread);
+	}
+	return;
+} 
+
+void sdio_cmd_int_handle(struct memory_card *card) 
 {
 	sdio_timeout_int_num = 0;
-	//wake_up_interruptible(&sdio_wait_event);
 	complete(&sdio_int_complete);
+	return;
 } 
 
-void sdio_timeout_int_handle(void) 
+void sdio_timeout_int_handle(struct memory_card *card) 
 {
-	if ((++sdio_timeout_int_num >= sdio_timeout_int_times) || cr_mon.card_status[CARD_SECURE_DIGITAL] == CARD_REMOVED) {
+	card->card_io_init(card);
+	card->card_detector(card);
+//	if(sdio_timeout_int_num && ((sdio_timeout_int_num%10000)==0))
+//		printk("[sdio_timeout_int_handle] sdio_timeout_int_num = %d\n", sdio_timeout_int_num);
+	if ((card->card_status == CARD_REMOVED) || (++sdio_timeout_int_num >= sdio_timeout_int_times)) {
 		sdio_close_host_interrupt(SDIO_TIMEOUT_INT);
 		sdio_timeout_int_num = 0;
 		sdio_timeout_int_times = 0;
-		//wake_up_interruptible(&sdio_wait_event);
 		complete(&sdio_int_complete);		
 	}
+	return;
 }
 
 
diff -Nur drivers/amlogic/cardreader/cardreader.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/cardreader.c
--- drivers/amlogic/cardreader/cardreader.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/cardreader.c	2011-07-14 00:17:51.976739983 +0800
@@ -6,29 +6,39 @@
 **        Revision : 1.0                                        **
 **                                                              **
 *****************************************************************/  
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/mii.h>
+#include <linux/skbuff.h>
 #include <linux/mutex.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/irqreturn.h>
-#include <linux/err.h>
 #include <linux/device.h>
 #include <linux/pagemap.h>
 #include <linux/platform_device.h>
+#include <linux/cardreader/sdio.h>
 #include <linux/cardreader/cardreader.h>
 #include <linux/cardreader/card_block.h>
-    
+#include <linux/kthread.h>
+#include <asm/cacheflush.h>
 #include <mach/am_regs.h>
 #include <mach/irqs.h>
 #include <mach/card_io.h>
 
 #define card_list_to_card(l)	container_of(l, struct memory_card, node)
-static DEFINE_MUTEX(init_lock);
+struct completion card_devadd_comp;
 
 struct amlogic_card_host 
 {
-	struct card_host *card;
+	struct card_host *host;
+	struct aml_card_platform *board_data;
 	int present;
  
 	/*
@@ -44,46 +54,211 @@
 	int transfer_index;
 };
 
-CARD_READER_MONITOR cr_mon;
-
 //wait_queue_head_t     sdio_wait_event;
+extern void sdio_if_int_handler(struct card_host *host);
+extern void sdio_cmd_int_handle(struct memory_card *card);
+extern void sdio_timeout_int_handle(struct memory_card *card);
 
 static int card_reader_monitor(void *arg);
 void card_detect_change(struct card_host *host, unsigned long delay);
 struct card_host *card_alloc_host(int extra, struct device *dev);
 static void card_setup(struct card_host *host);
-static void amlogic_card_request(struct card_host *card, struct card_blk_request *brq);
-static struct memory_card *card_find_card(struct card_host *host, u32 * raw_cid);
+static void amlogic_card_request(struct card_host *host, struct card_blk_request *brq);
+struct memory_card *card_find_card(struct card_host *host, u8 card_type);
+
+static struct memory_card *card_alloc_card(struct card_host *host) 
+{
+	struct memory_card *card;
+
+	card = kzalloc(sizeof(struct memory_card), GFP_KERNEL);
+	if (!card)
+		return ERR_PTR(-ENOMEM);
+
+	card_init_card(card, host);
+	list_add(&card->node, &host->cards);
+
+	return card;
+}
 
-void card_reader_initialize(struct card_host *card) 
+static void card_reader_initialize(struct card_host *host) 
 {
-	unsigned card_num;
+	struct amlogic_card_host *aml_host = card_priv(host);
+	struct aml_card_platform *card_platform = aml_host->board_data;
+	struct aml_card_info *card_plat_info;
+	struct memory_card *card;
+	int i, err = 0;
 
-	for (card_num = CARD_XD_PICTURE; card_num < CARD_MAX_UNIT; card_num++) {	
-		cr_mon.unit_state[card_num] = CARD_UNIT_NOT_READY;		
-		cr_mon.blk_length[card_num] = 0;	
-		cr_mon.capacity[card_num] = 0;	
+	for (i=0; i<card_platform->card_num; i++) {
+		card_plat_info = &card_platform->card_info[i];
+
+		if (!strcmp("xd_card", card_plat_info->name)) {
+#ifdef CONFIG_XD
+			card = card_find_card(host, CARD_XD_PICTURE);
+			if (card)
+				continue;
+			card = card_alloc_card(host);
+			if (!card)
+				continue;
+
+			card->unit_state = CARD_UNIT_NOT_READY;
+			strcpy(card->name, CARD_XD_NAME_STR);
+			card->card_type = CARD_XD_PICTURE;
+			card->card_plat_info = card_plat_info;
+			err = xd_probe(card);
+			if (err)
+				continue;
+#endif
+		}
+		else if (!strcmp("ms_card", card_plat_info->name)) {
+#ifdef CONFIG_MS_MSPRO
+			card = card_find_card(host, CARD_MEMORY_STICK);
+			if (card)
+				continue;
+			card = card_alloc_card(host);
+			if (!card)
+				continue;
+
+			card->unit_state = CARD_UNIT_NOT_READY;
+			strcpy(card->name, CARD_MS_NAME_STR);
+			card->card_type = CARD_MEMORY_STICK;
+			card->card_plat_info = card_plat_info;
+			err = ms_probe(card);
+			if (err)
+				continue;
+#endif
+		}
+		else if (!strcmp("sd_card", card_plat_info->name)) {
+#ifdef CONFIG_SD_MMC
+			card = card_find_card(host, CARD_SECURE_DIGITAL);
+			if (card)
+				continue;
+			card = card_alloc_card(host);
+			if (!card)
+				continue;
+
+			card->unit_state = CARD_UNIT_NOT_READY;
+			strcpy(card->name, CARD_SD_NAME_STR);
+			card->card_type = CARD_SECURE_DIGITAL;
+			card->card_plat_info = card_plat_info;
+			err = sd_mmc_probe(card);
+			if (err)
+				continue;
+#endif
+		}
+		else if (!strcmp("inand_card", card_plat_info->name)) {
+#ifdef CONFIG_INAND
+			card = card_find_card(host, CARD_INAND);
+			if (card)
+				continue;
+			card = card_alloc_card(host);
+			if (!card)
+				continue;
+
+			card->unit_state = CARD_UNIT_NOT_READY;
+			strcpy(card->name, CARD_INAND_NAME_STR);
+			card->card_type = CARD_INAND;
+			card->card_plat_info = card_plat_info;
+			err = inand_probe(card);
+			if (err)
+				continue;
+#endif
+		}
+		else if (!strcmp("sdio_card", card_plat_info->name)) {
+#ifdef CONFIG_SDIO
+			card = card_find_card(host, CARD_SDIO);
+			if (card)
+				continue;
+			card = card_alloc_card(host);
+			if (!card)
+				continue;
+
+			card->unit_state = CARD_UNIT_NOT_READY;
+			strcpy(card->name, CARD_SDIO_NAME_STR);
+			card->card_type = CARD_SDIO;
+			card->card_plat_info = card_plat_info;
+			err = sdio_probe(card);
+			if (err)
+				continue;
+#endif
+		}
+		else if (!strcmp("cf_card", card_plat_info->name)) {
+#ifdef CONFIG_CF
+			card = card_find_card(host, CARD_COMPACT_FLASH);
+			if (card)
+				continue;
+			card = card_alloc_card(host);
+			if (!card)
+				continue;
+
+			card->unit_state = CARD_UNIT_NOT_READY;
+			strcpy(card->name, CARD_CF_NAME_STR);
+			card->card_type = CARD_COMPACT_FLASH;
+			card->card_plat_info = card_plat_info;
+			err = cf_probe(card);
+			if (err)
+				continue;
+#endif
+		}
 	}
+}
+
+static irqreturn_t sdio_interrupt_monitor(int irq, void *dev_id, struct pt_regs *regs) 
+{
+	struct card_host *host = (struct card_host *)dev_id;
+	struct memory_card *card = host->card_busy;
+	unsigned sdio_interrupt_resource;
+
+	sdio_interrupt_resource = sdio_check_interrupt();
+	switch (sdio_interrupt_resource) {
+		case SDIO_IF_INT:
+		    sdio_if_int_handler(host);
+		    break;
+
+		case SDIO_CMD_INT:
+			sdio_cmd_int_handle(card);
+			break;
+
+		case SDIO_TIMEOUT_INT:
+			sdio_timeout_int_handle(card);
+			break;
 	
-	cr_mon.card_detector[CARD_TYPE_UNKNOW] = NULL;	
-	cr_mon.card_insert_process[CARD_TYPE_UNKNOW] = NULL;	
-	cr_mon.card_remove_process[CARD_TYPE_UNKNOW] = NULL;	
-	cr_mon.card_read_data[CARD_TYPE_UNKNOW] = NULL;	
-	cr_mon.card_write_data[CARD_TYPE_UNKNOW] = NULL;	
-	strcpy(cr_mon.name[CARD_TYPE_UNKNOW], CARD_UNKNOW_NAME_STR);	//   "/dev/disk/xx"
+		case SDIO_SOFT_INT:
+		    //AVDetachIrq(sdio_int_handler);
+		    //sdio_int_handler = -1;
+		    break;
+	
+		case SDIO_NO_INT:	
+			break;
 
-}
+		default:	
+			break;	
+	}
 
-static int card_reader_init(struct card_host *card) 
-{	
-	int ret;	
+    return IRQ_HANDLED; 
+
+} 
 
-	card_reader_initialize(card);	
-	ret = kernel_thread(card_reader_monitor, card, CLONE_KERNEL | SIGCHLD);
-	if (ret < 0)	
+static int card_reader_init(struct card_host *host) 
+{	
+	host->dma_buf = dma_alloc_coherent(NULL, host->max_req_size, (dma_addr_t *)&host->dma_phy_buf, GFP_KERNEL);
+	if(host->dma_buf == NULL)
+		return -ENOMEM;
+
+	card_reader_initialize(host);	
+	host->card_task = kthread_run(card_reader_monitor, host, "card");
+	if (!host->card_task)	
 		printk("card creat process failed\n");
 	else	
 		printk("card creat process sucessful\n");
+
+	if (request_irq(INT_SDIO, (irq_handler_t) sdio_interrupt_monitor, 0, "sd_mmc", host)) {
+		printk("request SDIO irq error!!!\n");
+		return -1;
+	}
+
+#ifdef CONFIG_SDIO_HARD_IRQ
+	host->caps |= CARD_CAP_SDIO_IRQ;
+#endif
 	return 0;
 } 
 
@@ -91,7 +266,7 @@
 {
     unsigned card_type, card_4in1_init_type;
     struct card_host *card_host = (struct card_host *)data;
-    struct memory_card *card;
+    struct memory_card *card = NULL;
     card_4in1_init_type = 0;
 
 	daemonize("card_read_monitor");
@@ -99,57 +274,77 @@
 	while(1) {
 		msleep(200);
 
-		mutex_lock(&init_lock);
+		if(card_host->card_task_state)
+		{
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule();
+			set_current_state(TASK_RUNNING);
+		}
 		for(card_type=CARD_XD_PICTURE; card_type<CARD_MAX_UNIT; card_type++) {
-			if(cr_mon.card_detector[card_type] && (!cr_mon.card_power_off_flag[card_type]))
-				cr_mon.card_status[card_type] = (*cr_mon.card_detector[card_type])();
 
-	    	if((cr_mon.card_status[card_type] == CARD_INSERTED) && (cr_mon.unit_state[card_type] != CARD_UNIT_READY) && ((card_type == CARD_COMPACT_FLASH) ||(cr_mon.slot_detector == CARD_REMOVED)||(cr_mon.card_slot_mode == CARD_SLOT_DISJUNCT))) {
-				if(cr_mon.card_insert_process[card_type])
-					cr_mon.unit_state[card_type] = (*cr_mon.card_insert_process[card_type])();
-				else
-					cr_mon.unit_state[card_type] = CARD_UNIT_READY;
-
-				if(cr_mon.unit_state[card_type] == CARD_UNIT_PROCESSED) {
-					if(cr_mon.card_slot_mode == CARD_SLOT_4_1) {
-	                	if (card_type != CARD_COMPACT_FLASH) {
-	                		cr_mon.slot_detector = CARD_INSERTED;
+			card_reader_initialize(card_host);
+			card = card_find_card(card_host, card_type);
+			if (card == NULL)
+				continue;
+
+			__card_claim_host(card_host, card);
+			card->card_io_init(card);
+			card->card_detector(card);
+			card_release_host(card_host);
+
+	    	if((card->card_status == CARD_INSERTED) && (((card->unit_state != CARD_UNIT_READY) 
+				&& ((card_type == CARD_SDIO) ||(card_type == CARD_INAND)
+				|| (card_host->slot_detector == CARD_REMOVED)||(card->card_slot_mode == CARD_SLOT_DISJUNCT)))
+				||(card->unit_state == CARD_UNIT_RESUMED))) {
+
+				if(card->unit_state == CARD_UNIT_RESUMED){
+					__card_claim_host(card_host, card);
+					card->card_insert_process(card);
+					card_release_host(card_host);
+					card->unit_state = CARD_UNIT_READY;
+					break;
+				}
+					
+				__card_claim_host(card_host, card);
+				card->card_insert_process(card);
+				card_release_host(card_host);
+					
+				if(card->unit_state == CARD_UNIT_PROCESSED) {
+					if(card->card_slot_mode == CARD_SLOT_4_1) {
+						if (card_type != CARD_SDIO && card_type != CARD_INAND) {
+	                		card_host->slot_detector = CARD_INSERTED;
 	                		card_4in1_init_type = card_type;
 	                	}
 					}
-					cr_mon.unit_state[card_type] = CARD_UNIT_READY;
-					cr_mon.card_register_flag[card_type] = CARD_REGISTERED;
+					card->unit_state = CARD_UNIT_READY;
 					card_host->card_type = card_type;
+					if(card->state != CARD_STATE_PRESENT)
+					card->state = CARD_STATE_INITED;
+					if (card_type == CARD_SDIO)
+						card_host->card = card;
 					card_detect_change(card_host, 0);
 	            }
 	        }
-	        else if((cr_mon.card_status[card_type] == CARD_REMOVED) && (cr_mon.unit_state[card_type] != CARD_UNIT_NOT_READY)) {
-				if(cr_mon.card_slot_mode == CARD_SLOT_4_1) {                       
+	        else if((card->card_status == CARD_REMOVED) && ((card->unit_state != CARD_UNIT_NOT_READY)
+				||(card->unit_state == CARD_UNIT_RESUMED))){
+
+				if(card->card_slot_mode == CARD_SLOT_4_1) {                       
 					if (card_type == card_4in1_init_type) 
-						cr_mon.slot_detector = CARD_REMOVED;
+						card_host->slot_detector = CARD_REMOVED;
 				}
 
-				if(cr_mon.card_remove_process[card_type])
-					cr_mon.unit_state[card_type] = (*cr_mon.card_remove_process[card_type])();
-				else
-					cr_mon.unit_state[card_type] = CARD_UNIT_NOT_READY;
-
-				if(cr_mon.unit_state[card_type] == CARD_UNIT_PROCESSED) {
-					cr_mon.unit_state[card_type] = CARD_UNIT_NOT_READY;
-
-					if(cr_mon.card_register_flag[card_type] == CARD_REGISTERED) {
-						cr_mon.card_register_flag[card_type] = CARD_UNREGISTERED;
-						card = card_find_card(card_host, cr_mon.raw_cid[card_type]);
-						if(card) {
-							list_del(&card->node);
-							card_remove_card(card);
-						}
+				card->card_remove_process(card);
+
+				if(card->unit_state == CARD_UNIT_PROCESSED) {
+					card->unit_state = CARD_UNIT_NOT_READY;
+
+					if(card) {
+						list_del(&card->node);
+						card_remove_card(card);
 					}
-					
-	            }
+				}
 	        }
 		}
-		mutex_unlock(&init_lock);
 	}
 
     return 0;
@@ -203,6 +398,8 @@
 	}
 	set_current_state(TASK_RUNNING);
 	host->card_busy = card;
+	if (!host->claimed)
+		host->claimed = 1;
 	spin_unlock_irqrestore(&host->lock, flags);
 	remove_wait_queue(&host->wq, &wait);
 
@@ -215,35 +412,118 @@
 
 EXPORT_SYMBOL(__card_claim_host);
 
+#ifdef CONFIG_SDIO
+int sdio_read_func_cis(struct sdio_func *func);
+static int card_sdio_init_func(struct memory_card *card, unsigned int fn)
+{
+	int ret = 0;
+	struct sdio_func *func;
+
+	BUG_ON(fn > SDIO_MAX_FUNCS);
+
+	card_claim_host(card->host);
+
+	func = sdio_alloc_func(card);
+	if (IS_ERR(func))
+		return PTR_ERR(func);
+
+	func->num = fn;
+
+	ret = sdio_read_func_cis(func);
+	if (ret)
+		goto fail;
+
+	card_release_host(card->host);
+
+	card->sdio_func[fn - 1] = func;
+
+	return 0;
+
+fail:
+	card_release_host(card->host);
+	sdio_remove_func(func);
+	return ret;
+}
+
+#if defined(CONFIG_MACH_MESON_8726M_REFB09)
+extern int amlogic_wifi_power(int on);
+#endif
+static int card_sdio_init_card(struct memory_card *card)
+{
+	int err, i;
+
+	for (i = 0; i < card->sdio_funcs; i++) {
+		err = card_sdio_init_func(card, i + 1);
+		if (err) 
+			return err;
+
+		err = sdio_add_func(card->sdio_func[i]);
+		if (err) 
+			return err;
+	}
+
+#if defined(CONFIG_MACH_MESON_8726M_REFB09)
+	amlogic_wifi_power(0);
+#endif
+	return 0;
+}
+
+/*
+ * Host is being removed. Free up the current card.
+ */
+static void card_sdio_remove(struct card_host *host)
+{
+	int i;
+
+	BUG_ON(!host);
+	BUG_ON(!host->card);
+
+	for (i = 0;i < host->card->sdio_funcs;i++) {
+		if (host->card->sdio_func[i]) {
+			sdio_remove_func(host->card->sdio_func[i]);
+			host->card->sdio_func[i] = NULL;
+		}
+	}
+
+	card_remove_card(host->card);
+	host->card = NULL;
+}
+
+#else
+static int card_sdio_init_func(struct memory_card *card, unsigned int fn)
+{
+	return 0;
+}
+
+static int card_sdio_init_card(struct memory_card *card)
+{
+	return 0;
+}
+
+/*
+ * Host is being removed. Free up the current card.
+ */
+static void card_sdio_remove(struct card_host *host)
+{
+}
+
+
+#endif
 /*
  * Locate a Memory card on this Memory host given a raw CID.
  */ 
-static struct memory_card *card_find_card(struct card_host *host, u32 * raw_cid) 
+struct memory_card *card_find_card(struct card_host *host, u8 card_type) 
 {
 	struct memory_card *card;
 	
 	list_for_each_entry(card, &host->cards, node) {
-		if (memcmp(card->raw_cid, raw_cid, sizeof(card->raw_cid)) == 0)		
+		if (card->card_type == card_type)		
 			return card;
 	}
 
 	return NULL;
 }
 
-static struct memory_card *card_alloc_card(struct card_host *host, u32 * raw_cid) 
-{
-	struct memory_card *card;
-
-	card = kmalloc(sizeof(struct memory_card), GFP_KERNEL);
-	if (!card)
-		return ERR_PTR(-ENOMEM);
-
-	card_init_card(card, host);
-	memcpy(card->raw_cid, raw_cid, sizeof(card->raw_cid));
-
-	return card;
-}
-
 /**
  *	card_add_host - initialise host hardware
  *	@host: card host
@@ -276,6 +556,14 @@
 		card_remove_card(card);
 	} 
 
+	if (host->dma_buf != NULL)
+	{
+	   dma_free_coherent(NULL, host->max_req_size, host->dma_buf, (dma_addr_t )host->dma_phy_buf);
+	   host->dma_buf  = NULL;
+	   host->dma_phy_buf = NULL;
+	}
+
+	free_irq(INT_SDIO, host);
 	card_remove_host_sysfs(host);
 } 
 
@@ -294,20 +582,23 @@
 
 static void card_discover_cards(struct card_host *host) 
 {
-	struct memory_card *card;
 	int err;
+	struct memory_card *card;
+
+	BUG_ON(host->card_busy == NULL);
 	
-	card = card_find_card(host, cr_mon.raw_cid[host->card_type]);
+	card = card_find_card(host, host->card_type);
 	if (!card) {	
-		card = card_alloc_card(host, cr_mon.raw_cid[host->card_type]);
+		card = card_alloc_card(host);
 		if (IS_ERR(card)) {	
 			err = PTR_ERR(card);		
 		}	
 		list_add(&card->node, &host->cards);
 	}
 
-	card->capacity = cr_mon.capacity[host->card_type];
-	card->card_type = host->card_type;	
+	if (card->card_type == CARD_SDIO)
+		host->card = card;
+	
 	card->state &= (~CARD_STATE_DEAD);
 }
 
@@ -330,12 +621,14 @@
 	BUG_ON(host->card_busy == NULL);
 	spin_lock_irqsave(&host->lock, flags);
 	host->card_busy = NULL;
+	host->claimed = 0;
 	spin_unlock_irqrestore(&host->lock, flags);
 	wake_up(&host->wq);
 } 
 
 static void card_reader_rescan(struct work_struct *work) 
 {	
+	int err = 0;
 	struct list_head *l, *n;
 	struct card_host *host = container_of(work, struct card_host, detect);
 
@@ -349,16 +642,23 @@
 
 	list_for_each_safe(l, n, &host->cards) {
 		struct memory_card *card = card_list_to_card(l);
+
 		/*
 		* If this is a new and good card, register it.
 		*/ 
-		if ((!(card->state & CARD_STATE_PRESENT)) && (!(card->state & CARD_STATE_DEAD))) {
-			if (card_register_card(card, cr_mon.name[host->card_type]))	
+		if ((!(card->state & CARD_STATE_PRESENT)) && (!(card->state & CARD_STATE_DEAD) && (card->state & CARD_STATE_INITED))) {
+			if (card_register_card(card))	
 				card->state = CARD_STATE_DEAD;
 			else	
 				card->state = CARD_STATE_PRESENT;	
+
+			if ((card->card_type == CARD_SDIO)) {
+				err = card_sdio_init_card(card);
+				if (err)
+					card_sdio_remove(host);
+			}
 		}
-		
+
 		/*
 		* If this card is dead, destroy it.
 		*/ 
@@ -367,6 +667,7 @@
 			card_remove_card(card);
 		}
 	}
+
 }
 
 struct card_host *card_alloc_host(int extra, struct device *dev) 
@@ -388,7 +689,8 @@
 		host->max_phys_segs = 1;
 		host->max_sectors = 1 << (PAGE_CACHE_SHIFT - 5);
 		host->max_seg_size = PAGE_CACHE_SIZE;
-		
+		host->max_blk_size = 512;
+		host->max_blk_count = 256;
 		host->max_req_size = 512*256;	/*for CONFIG_CARD_BLOCK_BOUNCE fix me*/
 		printk("card max_req_size is %dK \n", host->max_req_size/1024);
 	}
@@ -418,43 +720,56 @@
 	/*if (delay)
 		card_schedule_delayed_work(&host->detect, delay);
 	else */ 
+	init_completion(&card_devadd_comp);
 	card_schedule_work(&host->detect);
+	wait_for_completion(&card_devadd_comp);
 } 
 EXPORT_SYMBOL(card_detect_change);
 
+static void amlogic_enable_sdio_irq(struct card_host *host, int enable)
+{
+	if (enable)
+		sdio_open_host_interrupt(SDIO_IF_INT);
+	else
+		sdio_close_host_interrupt(SDIO_IF_INT);
+
+	return;
+}
+
 static struct card_host_ops amlogic_card_ops = { 
 	.request = amlogic_card_request, 
+	.enable_sdio_irq = amlogic_enable_sdio_irq,
 };
 
 static int amlogic_card_probe(struct platform_device *pdev) 
 {
-	struct card_host *card;
-	struct amlogic_card_host *host;
+	struct card_host *host;
+	struct amlogic_card_host *aml_host;
 	int ret;	
 
-	card = card_alloc_host(sizeof(struct amlogic_card_host), &pdev->dev);
-	if (!card) {	
+	host = card_alloc_host(sizeof(struct amlogic_card_host), &pdev->dev);
+	if (!host) {	
 		printk("Failed to allocate card host\n");	
 		return -ENOMEM;	
 	}
 
-	card->ops = &amlogic_card_ops;
-	host = card_priv(card);	
-	host->card = card;	
-	host->bus_mode = 0;
-	//host->board = pdev->dev.platform_data;
+	host->ops = &amlogic_card_ops;
+	aml_host = card_priv(host);	
+	aml_host->host = host;	
+	aml_host->bus_mode = 0;
+	aml_host->board_data = pdev->dev.platform_data;
   
-	platform_set_drvdata(pdev, card);
+	platform_set_drvdata(pdev, host);
 	/*
 	* Add host to CARD layer
 	*/ 
-	ret = card_add_host(card);
+	ret = card_add_host(host);
 	/*
 	* monitor card insertion/removal if we can
 	*/ 
-	ret = card_reader_init(card);
+	ret = card_reader_init(host);
 	if (ret) {
-		card_free_host(card);
+		card_free_host(host);
 		return ret;	
 	}
 
@@ -481,26 +796,15 @@
 	return 0;
 }
 
-static void amlogic_card_request(struct card_host *card, struct card_blk_request *brq)
+static void amlogic_card_request(struct card_host *host, struct card_blk_request *brq)
 {
-	int ret;
-	unsigned int lba, byte_cnt;
-	unsigned char *data_buf;
+	struct memory_card *card = host->card_busy;
 
-	lba = brq->card_data.lba;
-	byte_cnt = brq->card_data.blk_size * brq->card_data.blk_nums;
-	data_buf = brq->crq.buf;
-
-	mutex_lock(&init_lock);
-	if(brq->crq.cmd == READ) {
-		ret = cr_mon.card_read_data[card->card_type](lba, byte_cnt, data_buf);
-				brq->card_data.error = ret;
-	}
-	else if(brq->crq.cmd == WRITE) {
-		ret = cr_mon.card_write_data[card->card_type](lba, byte_cnt, data_buf);
-				brq->card_data.error = ret;
-	}
-	mutex_unlock(&init_lock);
+	BUG_ON(card == NULL);
+
+	card->card_request_process(card, brq);
+
+	return;
 }
 
 static struct platform_driver amlogic_card_driver = { 
diff -Nur drivers/amlogic/cardreader/card_sysfs.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/card_sysfs.c
--- drivers/amlogic/cardreader/card_sysfs.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/card_sysfs.c	2011-07-14 00:17:51.976739983 +0800
@@ -15,12 +15,15 @@
 #include <linux/idr.h>
 #include <linux/workqueue.h>
 #include <linux/err.h>
+#include <linux/cardreader/sdio.h>
 #include <linux/cardreader/card_block.h>
 
 #define dev_to_memory_card(d)	container_of(d, struct memory_card, dev)
 #define to_card_driver(d)	container_of(d, struct card_driver, drv)
 #define cls_dev_to_card_host(d)	container_of(d, struct card_host, class_dev)
 
+extern struct completion card_devdel_comp;
+extern struct completion card_devadd_comp;
 void card_release_card(struct device *dev)
 {
 	struct memory_card *card = dev_to_memory_card(dev);
@@ -66,6 +69,8 @@
 	struct card_driver *drv = to_card_driver(dev->driver);
 	struct memory_card *card = dev_to_memory_card(dev);
 
+	if (card->card_type == CARD_SDIO)
+		return 0;
 	return drv->probe(card);
 }
 
@@ -127,15 +132,21 @@
 
 EXPORT_SYMBOL(card_init_card);
 
+#include <linux/delay.h>
 /*
  * Internal function.  Register a new card card with the driver model.
  */
-int card_register_card(struct memory_card *card, char *card_name)
+int card_register_card(struct memory_card *card)
 {
-	strcpy(card->name, card_name);
-	dev_set_name(&card->dev, "%s:%s", card_hostname(card->host), card_name);
+	int ret;
+	
+	dev_set_name(&card->dev, "%s:%s", card_hostname(card->host), card->name);
+
+	/*return device_add(&card->dev);*/
+	device_add(&card->dev);
 
-	return device_add(&card->dev);
+	complete(&card_devadd_comp);
+	return ret;
 }
 
 EXPORT_SYMBOL(card_register_card);
@@ -145,9 +156,12 @@
  * driver model, and (eventually) free it.
  */
 void card_remove_card(struct memory_card *card)
-{
-	if (card->state & CARD_STATE_PRESENT)
+{	
+	if (card->state & CARD_STATE_PRESENT){
+		init_completion(&card_devdel_comp);
 		device_del(&card->dev);
+		wait_for_completion(&card_devdel_comp);
+	}
 
 	put_device(&card->dev);
 }
@@ -258,27 +272,94 @@
 	flush_workqueue(workqueue);
 }
 
+/**
+ *	card_align_data_size - pads a transfer size to a more optimal value
+ *	@card: the Memory card associated with the data transfer
+ *	@sz: original transfer size
+ *
+ *	Pads the original data size with a number of extra bytes in
+ *	order to avoid controller bugs and/or performance hits
+ *	(e.g. some controllers revert to PIO for certain sizes).
+ *
+ *	Returns the improved size, which might be unmodified.
+ *
+ *	Note that this function is only relevant when issuing a
+ *	single scatter gather entry.
+ */
+unsigned int card_align_data_size(struct memory_card *card, unsigned int sz)
+{
+	/*
+	 * FIXME: We don't have a system for the controller to tell
+	 * the core about its problems yet, so for now we just 32-bit
+	 * align the size.
+	 */
+	sz = ((sz + 3) / 4) * 4;
+
+	return sz;
+}
+EXPORT_SYMBOL(card_align_data_size);
+
+int card_register_host_class(void)
+{
+	return class_register(&card_host_class);
+}
+
+void card_unregister_host_class(void)
+{
+	class_unregister(&card_host_class);
+}
+
+int card_register_bus(void)
+{
+	return bus_register(&card_bus_type);
+}
+
+void card_unregister_bus(void)
+{
+	return bus_unregister(&card_bus_type);
+}
+
 static int __init card_init(void)
 {
-	int ret;
+	int ret = 0;
 
 	workqueue = create_singlethread_workqueue("kcardd");
 	if (!workqueue)
 		return -ENOMEM;
 
-	ret = bus_register(&card_bus_type);
-	if (ret == 0) {
-		ret = class_register(&card_host_class);
+	ret = card_register_bus();
 		if (ret)
-			bus_unregister(&card_bus_type);
-	}
+		goto destroy_workqueue;
+
+	ret = card_register_host_class();
+	if (ret)
+		goto unregister_bus;
+
+#ifdef CONFIG_SDIO
+	ret = sdio_register_bus();
+	if (ret)
+		goto unregister_host_class;
+#endif
+
+	return 0;
+
+unregister_host_class:
+	card_unregister_host_class();
+unregister_bus:
+	card_unregister_bus();
+destroy_workqueue:
+	destroy_workqueue(workqueue);
+
 	return ret;
 }
 
 static void __exit card_exit(void)
 {
-	class_unregister(&card_host_class);
-	bus_unregister(&card_bus_type);
+#ifdef CONFIG_SDIO
+	sdio_unregister_bus();
+#endif
+	card_unregister_host_class();
+	card_unregister_bus();
 	destroy_workqueue(workqueue);
 }
 
diff -Nur drivers/amlogic/cardreader/Kconfig /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/Kconfig
--- drivers/amlogic/cardreader/Kconfig	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/Kconfig	2011-07-14 00:17:51.972739983 +0800
@@ -13,6 +13,12 @@
 	default y
 	depends on CARDREADER
 
+config SDIO
+	bool "sdio interface driver support"
+	default y
+	depends on CARDREADER
+	select SD_MMC
+	
 config AM_ATA
 	bool "ATA/ATAPI driver support"
 	default n
@@ -33,4 +39,10 @@
 	default n
 	depends on CARDREADER
 
+config INAND
+	bool "inand card driver support"
+	default n
+	depends on CARDREADER
+	select SD_MMC
+	
 endmenu
diff -Nur drivers/amlogic/cardreader/Makefile /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/Makefile
--- drivers/amlogic/cardreader/Makefile	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/Makefile	2011-07-14 00:17:51.972739983 +0800
@@ -9,6 +9,7 @@
 obj-$(CONFIG_CARDREADER) +=  card_block.o
 obj-$(CONFIG_CARDREADER) +=  cardreader.o
 obj-$(CONFIG_CARDREADER) +=  card_io.o
+obj-$(CONFIG_SDIO) += sdio_sys.o sdio_io.o sdio_ops.o sdio_cis.o
 obj-$(CONFIG_SD_MMC) += sd/
 obj-$(CONFIG_AM_ATA) += ata/
 obj-$(CONFIG_CF) += cf/
diff -Nur drivers/amlogic/cardreader/ms/ms.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms.c
--- drivers/amlogic/cardreader/ms/ms.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms.c	2011-07-14 00:17:51.976739983 +0800
@@ -7,171 +7,327 @@
 **                                                              **
 *****************************************************************/
 #include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/pagemap.h>
+#include <linux/fs.h>
 
-#include <asm/drivers/cardreader/cardreader.h>
-#include <asm/drivers/cardreader/card_io.h>
+#include <linux/cardreader/card_block.h>
+#include <linux/cardreader/cardreader.h>
+#include "ms_misc.h"
 
-#include "ms_mspro.h"
+extern unsigned ms_force_write_two_times;
 
-static MS_MSPRO_Card_Info_t ms_info;
-extern MS_MSPRO_Card_Info_t *ms_mspro_info;
 
-extern unsigned ms_force_write_two_times;
+static unsigned ms_backup_input_val = 0;
+static unsigned ms_backup_output_val = 0;
+static unsigned MS_BAKUP_INPUT_REG = (unsigned)&ms_backup_input_val;
+static unsigned MS_BAKUP_OUTPUT_REG = (unsigned)&ms_backup_output_val;
 
-unsigned char ms_insert_detector(void)
+unsigned MS_BS_OUTPUT_EN_REG;
+unsigned MS_BS_OUTPUT_EN_MASK;
+unsigned MS_BS_OUTPUT_REG;
+unsigned MS_BS_OUTPUT_MASK;
+unsigned MS_CLK_OUTPUT_EN_REG;
+unsigned MS_CLK_OUTPUT_EN_MASK;
+unsigned MS_CLK_OUTPUT_REG;
+unsigned MS_CLK_OUTPUT_MASK;
+unsigned MS_DAT_OUTPUT_EN_REG;
+unsigned MS_DAT0_OUTPUT_EN_MASK;
+unsigned MS_DAT0_3_OUTPUT_EN_MASK;
+unsigned MS_DAT_INPUT_REG;
+unsigned MS_DAT_OUTPUT_REG;
+unsigned MS_DAT0_INPUT_MASK;
+unsigned MS_DAT0_OUTPUT_MASK;
+unsigned MS_DAT0_3_INPUT_MASK;
+unsigned MS_DAT0_3_OUTPUT_MASK;
+unsigned MS_DAT_INPUT_OFFSET;
+unsigned MS_DAT_OUTPUT_OFFSET;
+unsigned MS_INS_OUTPUT_EN_REG;
+unsigned MS_INS_OUTPUT_EN_MASK;
+unsigned MS_INS_INPUT_REG;
+unsigned MS_INS_INPUT_MASK;
+unsigned MS_PWR_OUTPUT_EN_REG;
+unsigned MS_PWR_OUTPUT_EN_MASK;
+unsigned MS_PWR_OUTPUT_REG;
+unsigned MS_PWR_OUTPUT_MASK;
+unsigned MS_PWR_EN_LEVEL;
+unsigned MS_WORK_MODE;
+
+void ms_insert_detector(struct memory_card *card)
 {
-	int ret = ms_mspro_check_insert();
+	MS_MSPRO_Card_Info_t *ms_mspro_info = (MS_MSPRO_Card_Info_t *)card->card_info;
+	
+	int ret = ms_mspro_check_insert(ms_mspro_info);
+	
 	if(ret)
-	{
-        return CARD_INSERTED;
-    }
-    else
-    {
-        return CARD_REMOVED;
-    }
+		card->card_status = CARD_INSERTED;
+	else
+		card->card_status = CARD_REMOVED;
+
+	return;
 }
 
 extern unsigned char disable_port_switch;
-unsigned char ms_open(void)
+void ms_open(struct memory_card *card)
 {
 	int ret;
+	MS_MSPRO_Card_Info_t *ms_mspro_info = (MS_MSPRO_Card_Info_t *)card->card_info;
 	
-	ret = ms_mspro_init(&ms_info);
+	ret = ms_mspro_init(ms_mspro_info);
 	if(ret)
 	{
 		disable_port_switch = 1;
-	    ret = ms_mspro_init(&ms_info);
+		ret = ms_mspro_init(ms_mspro_info);
 	}
 	disable_port_switch = 0;
+	
+	card->capacity = ms_mspro_info->blk_nums;
 	if(ret)
-		return CARD_UNIT_READY;
+		card->unit_state = CARD_UNIT_READY;
 	else
-		return CARD_UNIT_PROCESSED;
+		card->unit_state = CARD_UNIT_PROCESSED;
+
+	return;
 }
 
-unsigned char ms_close(void)
+void ms_close(struct memory_card *card)
 {
-	ms_mspro_exit();	
-	return CARD_UNIT_PROCESSED;
+	MS_MSPRO_Card_Info_t *ms_mspro_info = (MS_MSPRO_Card_Info_t *)card->card_info;
+	
+	if (ms_mspro_info->data_buf != NULL)
+	{
+		dma_free_coherent(NULL, 4096, ms_mspro_info->data_buf, (dma_addr_t )ms_mspro_info->data_phy_buf);
+		ms_mspro_info->data_buf  = NULL;
+		ms_mspro_info->data_phy_buf = NULL;
+	}
+	
+	if (ms_mspro_info->ms_mspro_buf != NULL)
+	{
+		dma_free_coherent(NULL, 4096, ms_mspro_info->ms_mspro_buf, (dma_addr_t )ms_mspro_info->ms_mspro_phy_buf);
+		ms_mspro_info->ms_mspro_buf  = NULL;
+		ms_mspro_info->ms_mspro_phy_buf = NULL;
+	}
+	
+	ms_mspro_exit(ms_mspro_info);
+	ms_mspro_free(ms_mspro_info);
+	ms_mspro_info = NULL;
+	card->card_info = NULL;
+	card->unit_state =  CARD_UNIT_PROCESSED;
+	
+	return;
 }
 
-unsigned char ms_read_info(u32 *blk_length, u32 *capacity, u32 *raw_cid)
+unsigned char ms_read_info(struct memory_card *card, u32 *blk_length, u32 *capacity, u32 *raw_cid)
 {
-	if(ms_info.inited_flag)
+	MS_MSPRO_Card_Info_t *ms_mspro_info = (MS_MSPRO_Card_Info_t *)card->card_info;
+	
+	if(ms_mspro_info->inited_flag)
 	{
 		if(blk_length)
 			*blk_length = 512;
 		if(capacity)
-			*capacity = ms_info.blk_nums;
+			*capacity = ms_mspro_info->blk_nums;
 		if(raw_cid)
-			memcpy(raw_cid, &(ms_info.raw_cid), sizeof(ms_info.raw_cid));
+			memcpy(raw_cid, &(ms_mspro_info->raw_cid), sizeof(ms_mspro_info->raw_cid));
 		return 0;
 	}
 	else
 		return 1;
 }
 
-int ms_ioctl(dev_t dev, int req, void *argp)
+static void ms_io_init(struct memory_card *card)
+{
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+	MS_WORK_MODE = aml_card_info->work_mode;
+
+	switch (aml_card_info->io_pad_type) {
+
+		case SDIO_GPIOA_0_5:
+			MS_BS_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_BS_OUTPUT_EN_MASK = PREG_IO_9_MASK;
+			MS_BS_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_BS_OUTPUT_MASK = PREG_IO_9_MASK;
+
+			MS_CLK_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_CLK_OUTPUT_EN_MASK = PREG_IO_8_MASK;
+			MS_CLK_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_CLK_OUTPUT_MASK = PREG_IO_8_MASK;
+
+			MS_DAT_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_DAT0_OUTPUT_EN_MASK = PREG_IO_4_MASK;
+			MS_DAT0_3_OUTPUT_EN_MASK = PREG_IO_4_7_MASK;
+			MS_DAT_INPUT_REG = EGPIO_GPIOA_INPUT;
+			MS_DAT_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_DAT0_INPUT_MASK = PREG_IO_4_MASK;
+			MS_DAT0_OUTPUT_MASK = PREG_IO_4_MASK;
+			MS_DAT0_3_INPUT_MASK = PREG_IO_4_7_MASK;
+			MS_DAT0_3_OUTPUT_MASK = PREG_IO_4_7_MASK;
+			MS_DAT_INPUT_OFFSET = 4;
+			MS_DAT_OUTPUT_OFFSET = 4;
+			break;
+
+		case SDIO_GPIOA_9_14:
+			MS_BS_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_BS_OUTPUT_EN_MASK = PREG_IO_18_MASK;
+			MS_BS_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_BS_OUTPUT_MASK = PREG_IO_18_MASK;
+
+			MS_CLK_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_CLK_OUTPUT_EN_MASK = PREG_IO_17_MASK;
+			MS_CLK_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_CLK_OUTPUT_MASK = PREG_IO_17_MASK;
+
+			MS_DAT_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_DAT0_OUTPUT_EN_MASK = PREG_IO_13_MASK;
+			MS_DAT0_3_OUTPUT_EN_MASK = PREG_IO_13_16_MASK;
+			MS_DAT_INPUT_REG = EGPIO_GPIOA_INPUT;
+			MS_DAT_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_DAT0_INPUT_MASK = PREG_IO_13_MASK;
+			MS_DAT0_OUTPUT_MASK = PREG_IO_13_MASK;
+			MS_DAT0_3_INPUT_MASK = PREG_IO_13_16_MASK;
+			MS_DAT0_3_OUTPUT_MASK = PREG_IO_13_16_MASK;
+			MS_DAT_INPUT_OFFSET = 13;
+			MS_DAT_OUTPUT_OFFSET = 13;
+			break;
+
+		case SDIO_GPIOB_2_7:
+			MS_BS_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_BS_OUTPUT_EN_MASK = PREG_IO_21_MASK;
+			MS_BS_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_BS_OUTPUT_MASK = PREG_IO_21_MASK;
+
+			MS_CLK_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_CLK_OUTPUT_EN_MASK = PREG_IO_22_MASK;
+			MS_CLK_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_CLK_OUTPUT_MASK = PREG_IO_22_MASK;
+
+			MS_DAT_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			MS_DAT0_OUTPUT_EN_MASK = PREG_IO_23_MASK;
+			MS_DAT0_3_OUTPUT_EN_MASK = PREG_IO_23_26_MASK;
+			MS_DAT_INPUT_REG = EGPIO_GPIOA_INPUT;
+			MS_DAT_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			MS_DAT0_INPUT_MASK = PREG_IO_23_MASK;
+			MS_DAT0_OUTPUT_MASK = PREG_IO_23_MASK;
+			MS_DAT0_3_INPUT_MASK = PREG_IO_23_26_MASK;
+			MS_DAT0_3_OUTPUT_MASK = PREG_IO_23_26_MASK;
+			MS_DAT_INPUT_OFFSET = 23;
+			MS_DAT_OUTPUT_OFFSET = 23;
+			break;
+
+		case SDIO_GPIOE_6_11:
+			MS_BS_OUTPUT_EN_REG = EGPIO_GPIOE_ENABLE;
+			MS_BS_OUTPUT_EN_MASK = PREG_IO_7_MASK;
+			MS_BS_OUTPUT_REG = EGPIO_GPIOE_OUTPUT;
+			MS_BS_OUTPUT_MASK = PREG_IO_7_MASK;
+
+			MS_CLK_OUTPUT_EN_REG = EGPIO_GPIOE_ENABLE;
+			MS_CLK_OUTPUT_EN_MASK = PREG_IO_6_MASK;
+			MS_CLK_OUTPUT_REG = EGPIO_GPIOE_OUTPUT;
+			MS_CLK_OUTPUT_MASK = PREG_IO_6_MASK;
+
+			MS_DAT_OUTPUT_EN_REG = EGPIO_GPIOE_ENABLE;
+			MS_DAT0_OUTPUT_EN_MASK = PREG_IO_8_MASK;
+			MS_DAT0_3_OUTPUT_EN_MASK = PREG_IO_8_11_MASK;
+			MS_DAT_INPUT_REG = EGPIO_GPIOE_INPUT;
+			MS_DAT_OUTPUT_REG = EGPIO_GPIOE_OUTPUT;
+			MS_DAT0_INPUT_MASK = PREG_IO_8_MASK;
+			MS_DAT0_OUTPUT_MASK = PREG_IO_8_MASK;
+			MS_DAT0_3_INPUT_MASK = PREG_IO_8_11_MASK;
+			MS_DAT0_3_OUTPUT_MASK = PREG_IO_8_11_MASK;
+			MS_DAT_INPUT_OFFSET = 8;
+			MS_DAT_OUTPUT_OFFSET = 8;
+			break;
+
+        default:
+			printk("Warning couldn`t find any valid hw io pad!!!\n");
+            break;
+	}
+
+	if (aml_card_info->card_ins_en_reg) {
+		MS_INS_OUTPUT_EN_REG = aml_card_info->card_ins_en_reg;
+		MS_INS_OUTPUT_EN_MASK = aml_card_info->card_ins_en_mask;
+		MS_INS_INPUT_REG = aml_card_info->card_ins_input_reg;
+		MS_INS_INPUT_MASK = aml_card_info->card_ins_input_mask;
+	}
+	else {
+		MS_INS_OUTPUT_EN_REG = MS_BAKUP_OUTPUT_REG;
+		MS_INS_OUTPUT_EN_MASK = 1;
+		MS_INS_INPUT_REG = MS_BAKUP_INPUT_REG;
+		MS_INS_INPUT_MASK = 1;
+	}
+
+	if (aml_card_info->card_power_en_reg) {
+		MS_PWR_OUTPUT_EN_REG = aml_card_info->card_power_en_reg;
+		MS_PWR_OUTPUT_EN_MASK = aml_card_info->card_power_en_mask;
+		MS_PWR_OUTPUT_REG = aml_card_info->card_power_output_reg;
+		MS_PWR_OUTPUT_MASK = aml_card_info->card_power_output_mask;
+		MS_PWR_EN_LEVEL = aml_card_info->card_power_en_lev;
+	}
+	else {
+		MS_PWR_OUTPUT_EN_REG = MS_BAKUP_OUTPUT_REG;
+		MS_PWR_OUTPUT_EN_MASK = 1;
+		MS_PWR_OUTPUT_REG = MS_BAKUP_OUTPUT_REG;
+		MS_PWR_OUTPUT_MASK = 1;
+		MS_PWR_EN_LEVEL = 0;	
+	}
+	return;
+}
+
+static int ms_request(struct memory_card *card, struct card_blk_request *brq)
 {
-//	unsigned32 ret=0;
-//    int errno;
-//    blkdev_request1 *req1 =(blkdev_request1 *) argp;  
-//    blkdev_request *r =&(req1->req); 
-//    blkdev_sg_buffer* psgbuf ;
-//    void * databuf;
-//    avfs_status_code status;
-//    INT32U capacity = 0;
-//
-//    switch (req)
-//    {
-//        case BLKIO_REQUEST:
-//        {
-//            psgbuf=&(r->bufs[0]);
-//            databuf=psgbuf->buffer;
-//            switch (r->req)
-//            {
-//                case BLKDEV_REQ_READ:
-//                case BLKDEV_REQ_READ_DEV:
-//                	card_get_dev();
-//                    ret = ms_mspro_read_data(r->start,r->count*512,(INT8U *)databuf);
-//                    if((ret)&&(ms_mspro_check_insert()))
-//                    {
-//                    	ms_mspro_info->inited_flag = 0;
-//                    	ret = ms_mspro_init(&ms_info);
-//                    	if(!ret)
-//                    		ret = ms_mspro_read_data(r->start,r->count*512,(INT8U *)databuf);
-//                    }
-//                    card_put_dev();
-//                    if(!ret)
-//                        status=AVFS_SUCCESSFUL;
-//                    else
-//                        status=AVFS_IO_ERROR;                   
-//                    if(r->req_done)
-//                        r->req_done(r->done_arg, status, ret);       
-//                    break;
-//                case BLKDEV_REQ_WRITE:
-//                case BLKDEV_REQ_WRITE_DEV:
-//                	card_get_dev();
-//                    ret = ms_mspro_write_data(r->start,r->count*512,(INT8U *)databuf);
-//                    if((!ret) && ms_force_write_two_times)
-//                    	ret = ms_mspro_write_data(r->start,r->count*512,(INT8U *)databuf);
-//                    if((ret)&&(ms_mspro_check_insert()))
-//                    {
-//                    	ms_mspro_info->inited_flag = 0;
-//                    	ret = ms_mspro_init(&ms_info);
-//                    	if(!ret)
-//                    		ret = ms_mspro_write_data(r->start,r->count*512,(INT8U *)databuf);
-//                    }
-//                    card_put_dev();
-//                    if(!ret)
-//                        status=AVFS_SUCCESSFUL;
-//                    else
-//                        status=AVFS_IO_ERROR;                       
-//                    if(r->req_done)
-//                        r->req_done(r->done_arg, status, ret);       
-//                    break;
-//                case BLKDEV_REQ_ASYREAD_DEV:
-//                case BLKDEV_REQ_ASYREAD_MEM:
-//                    break;
-//                default:
-//                    errno = EBADRQC;
-//                    ret=-1;
-//                    break;
-//            }
-//            break;
-//        }
-//        case BLKIO_GETSIZE:
-//        {
-//            ms_read_info(NULL, &capacity);
-//            r->status = capacity;
-//            break;
-//        }
-//        case BLKIO_GET_TYPE_STR:
-//        {
-//        	//if(ms_info.card_type == CARD_TYPE_MS)
-//        		*(char **)argp = "MS";
-//        	//else
-//        	//	*(char **)argp = "MSPRO";
-//        	break;
-//    	}
-//    	case BLKIO_GET_DEVSTAT:
-//    	{
-//    		blkdev_stat_t *info = (blkdev_stat_t *)argp;
-//    		ms_mspro_get_info(info);
-//    		break;
-//    	}   	
-//        default:
-//        {
-//            errno = EBADRQC;
-//            ret=-1;
-//            break;
-//        }
-//    }
-    return 0;//ret; 
+	MS_MSPRO_Card_Info_t *ms_info = (MS_MSPRO_Card_Info_t *)card->card_info;
+	unsigned int lba, byte_cnt;
+	unsigned char *data_buf;
+
+	lba = brq->card_data.lba;
+	byte_cnt = brq->card_data.blk_size * brq->card_data.blk_nums;
+	data_buf = brq->crq.buf;
+
+	if(brq->crq.cmd == READ) {
+		//printk("R(%d,%d)\n", lba, byte_cnt);
+		brq->card_data.error = ms_mspro_read_data(ms_info, lba, byte_cnt, data_buf);
+	}
+	else if(brq->crq.cmd == WRITE) {
+		//printk("W(%d,%d)\n", lba, byte_cnt);
+		brq->card_data.error = ms_mspro_write_data(ms_info, lba, byte_cnt, data_buf);
+	}
+
+	return 0;
 }
 
-void ms_init(void)
+int ms_probe(struct memory_card *card)
 {
-	ms_io_init();
-	ms_mspro_prepare_init();
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+
+	MS_MSPRO_Card_Info_t *ms_mspro_info = ms_mspro_malloc(sizeof(MS_MSPRO_Card_Info_t), GFP_KERNEL);
+	if (ms_mspro_info == NULL)
+		return -ENOMEM;
+
+	if (card->host->dma_buf != NULL) {
+		ms_mspro_info->dma_buf = card->host->dma_buf;
+		ms_mspro_info->dma_phy_buf = card->host->dma_phy_buf;
+	}
+
+	card->card_info = ms_mspro_info;
+	card->card_io_init = ms_io_init;
+	card->card_detector = ms_insert_detector;
+	card->card_insert_process = ms_open;
+	card->card_remove_process = ms_close;
+	card->card_request_process = ms_request;
+
+	if (aml_card_info->card_extern_init)
+		aml_card_info->card_extern_init();
+	card->card_io_init(card);
+	ms_mspro_info->io_pad_type = aml_card_info->io_pad_type;
+	ms_mspro_prepare_init(ms_mspro_info);
+
+	ms_mspro_info->data_buf = dma_alloc_coherent(NULL, PAGE_CACHE_SIZE, (dma_addr_t *)&ms_mspro_info->data_phy_buf, GFP_KERNEL);
+	if(ms_mspro_info->data_buf == NULL)
+		return -ENOMEM;
+	
+	ms_mspro_info->ms_mspro_buf = dma_alloc_coherent(NULL, PAGE_CACHE_SIZE, (dma_addr_t *)&ms_mspro_info->ms_mspro_phy_buf, GFP_KERNEL);
+	if(ms_mspro_info->ms_mspro_buf == NULL)
+		return -ENOMEM;
+
+	return 0;
 }
diff -Nur drivers/amlogic/cardreader/ms/ms_misc.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_misc.h
--- drivers/amlogic/cardreader/ms/ms_misc.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_misc.h	2011-07-14 00:17:51.976739983 +0800
@@ -9,15 +9,23 @@
 #include <linux/init.h>
 #include <linux/delay.h>
     
-#include <asm/arch/am_regs.h>
+#include <mach/am_regs.h>
 #include <asm/cacheflush.h>
 #include <asm/delay.h>
+#include <mach/am_regs.h>
+
+#include "ms_protocol.h"
+#include "mspro_protocol.h"
+#include "ms_mspro.h"
     
-#define ms_get_timer_tick()         READ_ISA_REG(IREG_TIMER_E_COUNT)	//unit: 10us or 1/100ms, max: 0 ~ 0xFFFFFF
+//#define ms_get_timer_tick()         READ_ISA_REG(IREG_TIMER_E_COUNT)	//unit: 10us or 1/100ms, max: 0 ~ 0xFFFFFF
+#define ms_get_timer_tick()		READ_CBUS_REG(ISA_TIMERE)
 #define MS_MAX_TIMER_TICK           0xFFFFFF
-#define TIMER_1US					1
-#define TIMER_10US					(10*TIMER_1US)
-#define TIMER_1MS					(100*TIMER_10US)
+//#define TIMER_1US					1
+//#define TIMER_10US					(10*TIMER_1US)
+//#define TIMER_1MS					(100*TIMER_10US)
+#define TIMER_1MS					1
+
 void ms_start_timer(unsigned long time_value);
 int ms_check_timer(void);
 int ms_check_timeout(void);
@@ -41,11 +49,11 @@
     
 #define MS_MSPRO_HW_CONTROL
 #define MS_MSPRO_SW_CONTROL
-    
+    
 #define MS_MSPRO_ALLOC_MEMORY
     
 #ifdef MS_MSPRO_ALLOC_MEMORY
-#define ms_mspro_malloc				kmalloc
+#define ms_mspro_malloc				kzalloc
 #define ms_mspro_free				kfree
 #endif				/*  */
     
@@ -75,4 +83,82 @@
 unsigned short ms_verify_crc16(unsigned char *ptr, unsigned int len);
 unsigned short ms_cal_crc16(unsigned char *ptr, unsigned int len);
 
+/**************************************************************/
+int ms_media_type_identification(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_search_boot_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char *data_buf);
+int ms_check_boot_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char *data_buf);
+int ms_check_disabled_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char *data_buf);
+int ms_boot_area_protection(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char *data_buf);
+int ms_logical_physical_table_creation(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned short seg_no);
+
+//int ms_read_boot_idi(unsigned char * data_buf);
+int ms_read_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr,
+		  unsigned char *data_buf);
+int ms_write_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr,
+		   unsigned char *data_buf);
+int ms_copy_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long source_block_addr,
+		  unsigned char source_page_addr, unsigned long dest_block_addr,
+		  unsigned char dest_page_addr, unsigned char *data_buf);
+int ms_read_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr,
+		   unsigned short page_nums, unsigned char *data_buf);
+int ms_write_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr,
+		    unsigned short page_nums, unsigned char *data_buf);
+int ms_erase_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr);
+int ms_read_extra_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr);
+int ms_write_extra_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr);
+int ms_overwrite_extra_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr,
+			     unsigned char mask_data);
+int ms_sleep(void);
+int ms_clear_buffer(void);
+int ms_flash_stop(void);
+int ms_reset(MS_MSPRO_Card_Info_t *ms_mspro_info);
+/***************************************************************/
+
+int mspro_media_type_identification(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int mspro_cpu_startup(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int mspro_confirm_attribute_information(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char *data_buf);
+int mspro_confirm_system_information(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char *data_buf);
+int mspro_recognize_file_system(void);
+int mspro_read_user_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr,
+			     unsigned short sector_count,
+			     unsigned char *data_buf);
+int mspro_write_user_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr,
+			     unsigned short sector_count,
+			     unsigned char *data_buf);
+int mspro_erase_user_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr,
+			     unsigned short sector_count);
+int mspro_read_attribute_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr,
+				 unsigned short sector_count,
+				 unsigned char *data_buf);
+int mspro_read_information_block(void);
+int mspro_update_imformation_block(void);
+int mspro_format(void);
+int mspro_sleep(void);
+
+/**************************************************************/
+
+//Following functions only used in ms_protocol.c and mspro_protocol.c
+int ms_mspro_wait_int(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet);
+int ms_mspro_wait_rdy(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet);
+int ms_mspro_write_tpc(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet);
+int ms_mspro_read_data_line(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet);
+int ms_mspro_write_data_line(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet);
+int ms_mspro_packet_communicate(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet);
+char *ms_mspro_error_to_string(int errcode);
+void ms_mspro_endian_convert(Endian_Type_t data_type, void *data);
+
+//Following functions are the API used for outside routinue
+//void ms_mspro_get_info(blkdev_stat_t *info);
+int ms_mspro_init(MS_MSPRO_Card_Info_t * card_info);
+void ms_mspro_exit(MS_MSPRO_Card_Info_t *ms_mspro_info);
+void ms_mspro_prepare_init(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_mspro_check_insert(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_mspro_read_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt,
+			unsigned char *data_buf);
+int ms_mspro_write_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt,
+			 unsigned char *data_buf);
+void ms_mspro_power_on(MS_MSPRO_Card_Info_t *ms_mspro_info);
+void ms_mspro_power_off(MS_MSPRO_Card_Info_t *ms_mspro_info);
+
 #endif				//_H_MS_MISC
+
diff -Nur drivers/amlogic/cardreader/ms/ms_mspro.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_mspro.c
--- drivers/amlogic/cardreader/ms/ms_mspro.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_mspro.c	2011-07-14 00:17:51.976739983 +0800
@@ -1,7 +1,9 @@
-#include "ms_port.h"
+#include <asm/cacheflush.h>
+#include <linux/pagemap.h>
 #include "ms_misc.h"
-#include "ms_mspro.h"
+#include "ms_port.h"
 
+/*
 //Global and static variable definitions
 static MS_MSPRO_Card_Info_t _ms_mspro_info = {CARD_NONE_TYPE,       //card_type
 											  MEMORY_STICK_ERROR,   //media_type
@@ -19,25 +21,11 @@
 										      NULL,					//ms_mspro_get_ins
 										      NULL					//ms_mspro_io_release
 											 };
-
-#ifndef MS_MSPRO_ALLOC_MEMORY
-static MS_MSPRO_Card_Buffer_t _ms_mspro_buf;
-#endif
-
-MS_MSPRO_Card_Info_t *ms_mspro_info = &_ms_mspro_info;
-
-#ifdef MS_MSPRO_ALLOC_MEMORY
-MS_MSPRO_Card_Buffer_t *ms_mspro_buf = NULL;
-#else
-MS_MSPRO_Card_Buffer_t *ms_mspro_buf = &_ms_mspro_buf;
-#endif
-
+*/
 static unsigned long ms_save_hw_io_config;
 static unsigned long ms_save_hw_io_mult_config;
 static unsigned long ms_save_hw_reg_flag;
 
-unsigned ms_mspro_buf_from_sys = 0;
-unsigned char *ms_mspro_buffer = NULL;
 unsigned char disable_port_switch = 0;
 unsigned ms_mspro_power_delay = 0;
 unsigned check_one_boot_block = 0;
@@ -85,15 +73,15 @@
 unsigned short mass_counter;
 
 //Functions only used in this source file]
-void ms_mspro_prepare_power(void);
-void ms_mspro_io_config(void);
-int ms_mspro_staff_init(void);
-int ms_mspro_cmd_test(void);
-int ms_mspro_media_type_identification(void);
-MS_MSPRO_Media_Type_t ms_mspro_check_media_type(void);
-int ms_mspro_interface_mode_switching(MS_MSPRO_Interface_Mode_t new_interface_mode);
+void ms_mspro_prepare_power(MS_MSPRO_Card_Info_t *ms_mspro_info);
+void ms_mspro_io_config(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_mspro_staff_init(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_mspro_cmd_test(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_mspro_media_type_identification(MS_MSPRO_Card_Info_t *ms_mspro_info);
+MS_MSPRO_Media_Type_t ms_mspro_check_media_type(MS_MSPRO_Card_Info_t *ms_mspro_info);
+int ms_mspro_interface_mode_switching(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_Interface_Mode_t new_interface_mode);
 
-int ms_mspro_check_data_consistency(void);
+int ms_mspro_check_data_consistency(MS_MSPRO_Card_Info_t *ms_mspro_info);
 
 //Function implement start...
 
@@ -104,7 +92,7 @@
 }
 
 #ifdef MS_MSPRO_HW_CONTROL
-int ms_mspro_wait_int_hw(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_wait_int_hw(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	unsigned long temp = 0;
 	
@@ -115,7 +103,7 @@
 		ms_start_timer(MS_MSPRO_INT_TIMEOUT);
 		do
 		{
-			irq_config = READ_PERIPHS_REG(SDIO_IRQ_CONFIG);
+			irq_config = READ_CBUS_REG(SDIO_IRQ_CONFIG);
 			temp = (irq_config >> 8) & 0x0000000F;
 			
 			if(temp)
@@ -135,7 +123,7 @@
 		ms_start_timer(MS_MSPRO_INT_TIMEOUT);
 		do
 		{
-			irq_config = READ_PERIPHS_REG(SDIO_IRQ_CONFIG);
+			irq_config = READ_CBUS_REG(SDIO_IRQ_CONFIG);
 			temp = (irq_config >> 8) & 0x00000001;
 			
 			if(temp)
@@ -152,7 +140,7 @@
 #endif
 
 #ifdef MS_MSPRO_SW_CONTROL
-int ms_mspro_wait_int_sw(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_wait_int_sw(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	unsigned long temp = 0, data = 0, cnt = 0;
 	
@@ -215,7 +203,7 @@
 }
 #endif
 
-int ms_mspro_wait_rdy(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_wait_rdy(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	unsigned long temp = 0, data;
 	
@@ -299,7 +287,7 @@
 		return MS_MSPRO_NO_ERROR;
 }
 
-int ms_mspro_write_tpc(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_write_tpc(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	int i;
 	unsigned long temp,tpc_cmd;
@@ -374,7 +362,7 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_mspro_read_data_line(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_read_data_line(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	unsigned long data_cnt, temp = 0, loop_num, data;
 	unsigned short crc16 = 0;
@@ -541,7 +529,7 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_mspro_write_data_line(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_write_data_line(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	unsigned long data_cnt, loop_num, data;
 	unsigned short crc16 = 0;
@@ -640,12 +628,12 @@
 }
 
 #ifdef MS_MSPRO_HW_CONTROL
-int ms_mspro_packet_communicate_hw(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_packet_communicate_hw(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	int num_res,i,cnt;
 	unsigned char *data_buf;
 	unsigned long cmd_arg,cmd_send,cmd_ext;
-	unsigned long timeout, timeout_count, repeat_time;
+	unsigned long timeout, repeat_time;
 	unsigned long status_irq;
 	//unsigned long irq_config;	
 	MSHW_CMD_Send_Reg_t *cmd_send_reg;
@@ -673,8 +661,10 @@
 		case TPC_MS_READ_PAGE_DATA:			//TPC_MSPRO_READ_LONG_DATA
 		case TPC_MSPRO_READ_SHORT_DATA:
 			//AV_invalidate_dcache();
-			inv_dcache_range((unsigned long)ms_mspro_buffer, ((unsigned long)ms_mspro_buffer + tpc_packet->param.in.count)); 
-			data_buf = ms_mspro_buffer;
+			//inv_dcache_range((unsigned long)ms_mspro_buffer, ((unsigned long)ms_mspro_buffer + tpc_packet->param.in.count)); 
+			//data_buf = ms_mspro_buffer;
+			data_buf = ms_mspro_info->data_phy_buf;
+			//data_buf = ms_mspro_info->dma_phy_buf;
 			cmd_send_reg->have_long_data_read = 1;
 			if(ms_mspro_info->interface_mode == INTERFACE_PARALLEL)
 				cmd_ext_reg->long_data_nums = tpc_packet->param.in.count * 8 + 16 - 4;
@@ -689,7 +679,32 @@
 			//else // CARD_TYPE_MSPRO
 			//	data_buf = ms_mspro_buf->mspro.sector_buf;
 			//memcpy(data_buf, tpc_packet->param.out.buffer, tpc_packet->param.out.count);
-			data_buf = tpc_packet->param.out.buffer;
+			//data_buf = tpc_packet->param.out.buffer;
+			dmac_map_area(ms_mspro_info->data_buf, tpc_packet->param.in.count, 1);
+			if((tpc_packet->param.out.buffer >= ms_mspro_info->data_buf) &&
+				(tpc_packet->param.out.buffer < ms_mspro_info->data_buf+sizeof(MS_MSPRO_Card_Info_t)))
+				data_buf = ms_mspro_info->data_phy_buf + 
+						((int)(tpc_packet->param.out.buffer) - (int)(ms_mspro_info->data_buf));
+			else if((tpc_packet->param.out.buffer >= ms_mspro_info->ms_mspro_buf) &&
+				(tpc_packet->param.out.buffer < ms_mspro_info->ms_mspro_buf+PAGE_CACHE_SIZE))
+				data_buf = ms_mspro_info->ms_mspro_phy_buf + 
+						((int)(tpc_packet->param.out.buffer) - (int)(ms_mspro_info->ms_mspro_buf));
+			else if((tpc_packet->param.out.buffer >= ms_mspro_info->dma_buf) &&
+				(tpc_packet->param.out.buffer < ms_mspro_info->dma_buf+256*512))
+				data_buf = ms_mspro_info->dma_phy_buf + 
+						((int)(tpc_packet->param.out.buffer) - (int)(ms_mspro_info->dma_buf));
+			else{
+				printk("ms_mspro_info->data_buf = %x, ms_mspro_info->data_phy_buf = %x\n"
+					"ms_mspro_info->ms_mspro_buf = %x, ms_mspro_info->ms_mspro_phy_buf = %x\n"
+					"ms_mspro_info->dma_buf = %x, ms_mspro_info->dma_phy_buf = %x\n"
+					"tpc_packet->param.out.buffer = %x, data_buf = %x\n",
+					(unsigned int)(ms_mspro_info->data_buf), (unsigned int)(ms_mspro_info->data_phy_buf), 
+					(unsigned int)(ms_mspro_info->ms_mspro_buf), (unsigned int)(ms_mspro_info->ms_mspro_phy_buf), 
+					(unsigned int)(ms_mspro_info->dma_buf), (unsigned int)(ms_mspro_info->dma_phy_buf), 
+					(unsigned int)(tpc_packet->param.out.buffer), (unsigned int)data_buf);
+				dump_stack();
+				BUG();
+			}
 			
 			cmd_send_reg->have_long_data_write = 1;
 			if(ms_mspro_info->interface_mode == INTERFACE_PARALLEL)
@@ -698,7 +713,7 @@
 				cmd_ext_reg->long_data_nums = tpc_packet->param.out.count * 8 + 16 - 1;
 			
 			//AV_invalidate_dcache();
-			inv_dcache_range((unsigned long)tpc_packet->param.out.buffer, ((unsigned long)tpc_packet->param.out.buffer + tpc_packet->param.out.count)); 
+			//inv_dcache_range((unsigned long)tpc_packet->param.out.buffer, ((unsigned long)tpc_packet->param.out.buffer + tpc_packet->param.out.count)); 
 			break;
 			
 		case TPC_MS_MSPRO_READ_REG:
@@ -765,27 +780,28 @@
 	if(timeout > (ms_mspro_info->ms_clk_unit*0x1FFF)/1000)
 	{
 		status_irq_reg->timing_out_count = 0x1FFF;
-		sdio_timeout_int_times = (timeout*1000)/(ms_mspro_info->ms_clk_unit*0x1FFF);
+		//sdio_timeout_int_times = (timeout*1000)/(ms_mspro_info->ms_clk_unit*0x1FFF);
+		sdio_timeout_int_times = timeout/(ms_mspro_info->ms_clk_unit*0x1FFF/1000);
 	}
 	else
 	{
 		status_irq_reg->timing_out_count = (ms_mspro_info->ms_clk_unit)*1000;
 		sdio_timeout_int_times = 1;
 	}
-	WRITE_PERIPHS_REG(SDIO_STATUS_IRQ, status_irq);
+	WRITE_CBUS_REG(SDIO_STATUS_IRQ, status_irq);
 
-	WRITE_PERIPHS_REG(CMD_ARGUMENT, cmd_arg);
-	WRITE_PERIPHS_REG(SDIO_EXTENSION, cmd_ext);
+	WRITE_CBUS_REG(CMD_ARGUMENT, cmd_arg);
+	WRITE_CBUS_REG(SDIO_EXTENSION, cmd_ext);
 	if(data_buf != NULL)
 	{
-		WRITE_PERIPHS_REG(SDIO_M_ADDR, (unsigned long)data_buf);
+		WRITE_CBUS_REG(SDIO_M_ADDR, (unsigned long)data_buf);
 	}
 
 	init_completion(&sdio_int_complete);
 	sdio_open_host_interrupt(SDIO_CMD_INT);
 	sdio_open_host_interrupt(SDIO_TIMEOUT_INT);
 
-	WRITE_PERIPHS_REG(CMD_SEND, cmd_send);
+	WRITE_CBUS_REG(CMD_SEND, cmd_send);
 
 	//interruptible_sleep_on(&sdio_wait_event);
 	wait_for_completion(&sdio_int_complete);
@@ -793,7 +809,7 @@
 	/*timeout_count = 0;
     while(1)
     {
-    	status_irq = READ_PERIPHS_REG(SDIO_STATUS_IRQ);
+    	status_irq = READ_CBUS_REG(SDIO_STATUS_IRQ);
     	
     	if(!status_irq_reg->cmd_busy && status_irq_reg->cmd_int)
     		break;
@@ -801,7 +817,7 @@
         if((++timeout_count) > timeout)
         {
         	irq_config_reg->soft_reset = 1;
-            WRITE_PERIPHS_REG(SDIO_IRQ_CONFIG, irq_config);
+            WRITE_CBUS_REG(SDIO_IRQ_CONFIG, irq_config);
             
             if((++repeat_time) > MS_MSPRO_RETRY_COUNT)
         	{
@@ -818,7 +834,7 @@
 	if(sdio_timeout_int_times == 0)
 		return MS_MSPRO_ERROR_TIMEOUT;
 
-	status_irq = READ_PERIPHS_REG(SDIO_STATUS_IRQ);
+	status_irq = READ_CBUS_REG(SDIO_STATUS_IRQ);
 	if(tpc_packet->TPC_cmd.trans_dir.bRead && !status_irq_reg->data_read_crc16_ok)
 		return MS_MSPRO_ERROR_DATA_CRC;
 		
@@ -830,11 +846,11 @@
 		unsigned long multi_config = 0;
 		SDIO_Multi_Config_Reg_t *multi_config_reg = (void *)&multi_config;
 		multi_config_reg->write_read_out_index = 1;
-		WRITE_PERIPHS_REG(SDIO_MULT_CONFIG, multi_config);
+		WRITE_CBUS_REG(SDIO_MULT_CONFIG, multi_config);
 	}
 	while(num_res)
 	{
-		unsigned long data_temp = READ_PERIPHS_REG(CMD_ARGUMENT);
+		unsigned long data_temp = READ_CBUS_REG(CMD_ARGUMENT);
 		
 		tpc_packet->param.in.buffer[--num_res] = data_temp & 0xFF;
 		if(num_res <= 0)
@@ -861,16 +877,19 @@
 		else
 #endif
 		{
-			memcpy(tpc_packet->param.in.buffer, data_buf, tpc_packet->param.in.count);
+			dmac_map_area(ms_mspro_info->data_buf, tpc_packet->param.in.count, 2);
+			memcpy(tpc_packet->param.in.buffer, ms_mspro_info->data_buf, tpc_packet->param.in.count);
+			dmac_map_area(ms_mspro_info->data_buf, tpc_packet->param.in.count, 2);	
 		}
 	}
 		
+			dmac_map_area(ms_mspro_info->data_buf, tpc_packet->param.in.count, 1);
 	return MS_MSPRO_NO_ERROR;
 }
 #endif
 
 #ifdef MS_MSPRO_SW_CONTROL
-int ms_mspro_packet_communicate_sw(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_packet_communicate_sw(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	int ret;
 	
@@ -879,26 +898,26 @@
 		return MS_MSPRO_ERROR_TPC_FORMAT;
 		
 	//write TPC comand to data line
-	ms_mspro_write_tpc(tpc_packet);
+	ms_mspro_write_tpc(ms_mspro_info, tpc_packet);
 
 	//write data or read response
 	if (tpc_packet->TPC_cmd.trans_dir.bWrite)   //Write packet
 	{
-		ms_mspro_write_data_line(tpc_packet);
+		ms_mspro_write_data_line(ms_mspro_info, tpc_packet);
 			
-		ret = ms_mspro_wait_rdy(tpc_packet);
+		ret = ms_mspro_wait_rdy(ms_mspro_info, tpc_packet);
 		if(!ret)
 		{
 			if ((tpc_packet->TPC_cmd.value == TPC_MS_MSPRO_SET_CMD) || (tpc_packet->TPC_cmd.value == TPC_MSPRO_EX_SET_CMD))
-				ret = ms_mspro_wait_int(tpc_packet);
+				ret = ms_mspro_wait_int(ms_mspro_info, tpc_packet);
 		}
 	}
 	else                        //Read packet
 	{
-		ret = ms_mspro_wait_rdy(tpc_packet);
+		ret = ms_mspro_wait_rdy(ms_mspro_info, tpc_packet);
 		if(!ret)
 		{
-            ret=ms_mspro_read_data_line(tpc_packet);
+            ret=ms_mspro_read_data_line(ms_mspro_info, tpc_packet);
 		}
 	}
 	
@@ -918,9 +937,10 @@
 }
 #endif
 
-int ms_mspro_media_type_identification()
+int ms_mspro_media_type_identification(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	MS_MSPRO_TPC_Packet_t packet;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
@@ -929,21 +949,21 @@
 	ms_mspro_buf->ms.reg_set.read_addr = 0x02;           //READ_ADRS = 0x02
 	ms_mspro_buf->ms.reg_set.read_size = 0x06;           //READ_SIZE = 0x06
 	packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
 	packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 	packet.param.in.count = 6;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 	packet.param.in.buffer = &ms_mspro_buf->ms.regs.Status_Reg0;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_media_type_identification();
+	error = ms_media_type_identification(ms_mspro_info);
 	if(error)
 	{
-		error = mspro_media_type_identification();
+		error = mspro_media_type_identification(ms_mspro_info);
 	}
 
 #ifdef  MS_MSPRO_DEBUG
@@ -954,10 +974,12 @@
 	return error;
 }
 
-int ms_mspro_interface_mode_switching(MS_MSPRO_Interface_Mode_t new_interface_mode)
+int ms_mspro_interface_mode_switching(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_Interface_Mode_t new_interface_mode)
 {
 	MS_MSPRO_TPC_Packet_t packet;
-	unsigned char sys_para_reg;
+	//unsigned char sys_para_reg;
+	unsigned char* sys_para_reg = ms_mspro_info->data_buf;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
@@ -968,7 +990,7 @@
 	ms_mspro_buf->ms.reg_set.write_addr = 0x10;          //WRITE_ADRS = 0x10
 	ms_mspro_buf->ms.reg_set.write_size = 0x01;          //WRITE_SIZE = 0x01
 	packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -976,14 +998,17 @@
 	packet.param.out.count = 1;             //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 	if(ms_mspro_info->card_type == CARD_TYPE_MS)
 	{                           //Default 0x80: Serial I/F
-		sys_para_reg = (new_interface_mode==INTERFACE_PARALLEL) ? 0x88 : 0x80;
+		//sys_para_reg = (new_interface_mode==INTERFACE_PARALLEL) ? 0x88 : 0x80;
+		*sys_para_reg = (new_interface_mode==INTERFACE_PARALLEL) ? 0x88 : 0x80;
 	}
 	else    //CARD_TYPE_MSPRO
 	{                           //Default 0x00: Parallel I/F
-		sys_para_reg = (new_interface_mode==INTERFACE_SERIAL) ? 0x80 : 0x00;
+		//sys_para_reg = (new_interface_mode==INTERFACE_SERIAL) ? 0x80 : 0x00;
+		*sys_para_reg = (new_interface_mode==INTERFACE_SERIAL) ? 0x80 : 0x00;
 	}
-	packet.param.out.buffer[0] = sys_para_reg;
-	error = ms_mspro_packet_communicate(&packet);
+	//packet.param.out.buffer[0] = sys_para_reg;
+	packet.param.out.buffer = sys_para_reg;
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -994,7 +1019,7 @@
 	{
 		unsigned long sdio_config = 0;
 		SDIO_Config_Reg_t *config_reg = (void *)&sdio_config;
-		sdio_config = READ_PERIPHS_REG(SDIO_CONFIG);
+		sdio_config = READ_CBUS_REG(SDIO_CONFIG);
 		if(new_interface_mode == INTERFACE_PARALLEL)
 		{
 			config_reg->bus_width = 1;
@@ -1005,7 +1030,7 @@
 			config_reg->bus_width = 0;
 			config_reg->cmd_out_at_posedge = 0;
 		}
-		WRITE_PERIPHS_REG(SDIO_CONFIG, sdio_config);
+		WRITE_CBUS_REG(SDIO_CONFIG, sdio_config);
 	}
 #endif
 
@@ -1027,8 +1052,10 @@
 	}
 }
 
-MS_MSPRO_Media_Type_t ms_mspro_check_media_type(void)
+MS_MSPRO_Media_Type_t ms_mspro_check_media_type(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
+	
 	if((ms_mspro_buf->ms.regs.Category_Reg >= 0x01) && (ms_mspro_buf->ms.regs.Category_Reg <= 0x7F))
 		return MEMORY_STICK_IO;
 	
@@ -1099,10 +1126,11 @@
 	return MEMORY_STICK_ERROR;
 }
 
-int ms_mspro_init(MS_MSPRO_Card_Info_t * card_info)
+int ms_mspro_init(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	int error,i;
 	int init_retry_flag = 0;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	unsigned long temp;
 	
@@ -1114,14 +1142,14 @@
 	{
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
-		ms_sdio_enable();
+		ms_sdio_enable(ms_mspro_info->io_pad_type);
 #endif		
 #ifdef MS_MSPRO_SW_CONTROL
 	if(MS_WORK_MODE == CARD_SW_MODE)
-		ms_gpio_enable();
+		ms_gpio_enable(ms_mspro_info->io_pad_type);
 #endif
 
-		error = ms_mspro_cmd_test();
+		error = ms_mspro_cmd_test(ms_mspro_info);
 		if(!error)
 			return error;
 	}
@@ -1135,7 +1163,7 @@
 
 init_retry:
 	
-	error = ms_mspro_staff_init();
+	error = ms_mspro_staff_init(ms_mspro_info);
 	if(error)
 	{
 #ifdef  MS_MSPRO_DEBUG
@@ -1144,7 +1172,7 @@
 		return error;
 	}	
 	
-	error = ms_mspro_media_type_identification();
+	error = ms_mspro_media_type_identification(ms_mspro_info);
 	if(error)
 	{
 #ifdef  MS_MSPRO_DEBUG
@@ -1153,11 +1181,11 @@
 		return error;
 	}
 		
-	ms_mspro_info->media_type = ms_mspro_check_media_type();
+	ms_mspro_info->media_type = ms_mspro_check_media_type(ms_mspro_info);
 
 	if(ms_mspro_info->card_type == CARD_TYPE_MS)
 	{
-		error = ms_search_boot_block(ms_mspro_buffer);
+		error = ms_search_boot_block(ms_mspro_info, ms_mspro_info->data_buf);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -1166,7 +1194,7 @@
 			return error;
 		}
 			
-		error = ms_check_boot_block(ms_mspro_buffer);
+		error = ms_check_boot_block(ms_mspro_info, ms_mspro_info->data_buf);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -1175,7 +1203,7 @@
 			return error;
 		}
 		
-		error = ms_check_disabled_block(ms_mspro_buffer);
+		error = ms_check_disabled_block(ms_mspro_info, ms_mspro_info->data_buf);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -1195,7 +1223,7 @@
 
 		if(ms_mspro_buf->ms.boot_attribute_information.Parallel_Transfer_Supporting && (!init_retry_flag))
 		{
-			error = ms_mspro_interface_mode_switching(INTERFACE_PARALLEL);
+			error = ms_mspro_interface_mode_switching(ms_mspro_info, INTERFACE_PARALLEL);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
@@ -1204,17 +1232,17 @@
 				return error;
 			}
 			
-			error = ms_mspro_cmd_test();
+			error = ms_mspro_cmd_test(ms_mspro_info);
 			if(error)
 			{				
 #ifdef  MS_MSPRO_DEBUG
 				Debug_Printf("This Memory Stick can not work in Parallel I/F mode, retry Serial I/F mode!\n");
 #endif
-				error = ms_mspro_interface_mode_switching(INTERFACE_SERIAL);
+				error = ms_mspro_interface_mode_switching(ms_mspro_info, INTERFACE_SERIAL);
 				if(error)
 				{					
 					ms_mspro_info->interface_mode = INTERFACE_SERIAL;
-					error = ms_mspro_cmd_test();
+					error = ms_mspro_cmd_test(ms_mspro_info);
 				}
 				if(error)
 				{
@@ -1238,7 +1266,7 @@
 		
 		if(ms_mspro_buf->ms.boot_area_protection_process_flag)
 		{
-			error = ms_boot_area_protection(ms_mspro_buffer);
+			error = ms_boot_area_protection(ms_mspro_info, ms_mspro_info->data_buf);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
@@ -1250,7 +1278,7 @@
 	
 		for(i=0; i<ms_mspro_buf->ms.boot_attribute_information.Block_Numbers/MS_BLOCKS_PER_SEGMENT; i++)
 		{
-			error = ms_logical_physical_table_creation(i);
+			error = ms_logical_physical_table_creation(ms_mspro_info, i);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
@@ -1271,7 +1299,7 @@
 	}
 	else if(ms_mspro_info->card_type == CARD_TYPE_MSPRO)
 	{
-		error = mspro_cpu_startup();
+		error = mspro_cpu_startup(ms_mspro_info);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -1280,7 +1308,7 @@
 			return error;
 		}
 			
-		error = mspro_confirm_attribute_information(ms_mspro_buffer);
+		error = mspro_confirm_attribute_information(ms_mspro_info, ms_mspro_info->data_buf);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -1289,7 +1317,7 @@
 			return error;
 		}
 			
-		error = mspro_confirm_system_information(ms_mspro_buffer);
+		error = mspro_confirm_system_information(ms_mspro_info, ms_mspro_info->data_buf);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -1300,7 +1328,7 @@
 		
 		if(ms_mspro_buf->mspro.system_information.Interface_Type == 1 && (!init_retry_flag))
 		{
-			error = ms_mspro_interface_mode_switching(INTERFACE_PARALLEL);
+			error = ms_mspro_interface_mode_switching(ms_mspro_info, INTERFACE_PARALLEL);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
@@ -1309,17 +1337,17 @@
 				return error;
 			}
 			
-			error = ms_mspro_cmd_test();
+			error = ms_mspro_cmd_test(ms_mspro_info);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
 				Debug_Printf("This Memory Stick Pro can not work in Parallel I/F mode, retry Serial I/F mode!\n");
 #endif
-				error = ms_mspro_interface_mode_switching(INTERFACE_SERIAL);
+				error = ms_mspro_interface_mode_switching(ms_mspro_info, INTERFACE_SERIAL);
 				if(error)
 				{
 					ms_mspro_info->interface_mode = INTERFACE_SERIAL;
-					error = ms_mspro_cmd_test();
+					error = ms_mspro_cmd_test(ms_mspro_info);
 				}
 				if(error)
 				{
@@ -1352,14 +1380,14 @@
 		return error;
 	}
 
-	error = ms_mspro_check_data_consistency();
-	if(error)
-	{
-#ifdef  MS_MSPRO_DEBUG
-		Debug_Printf("#%s error occured in ms_mspro_check_data_consistency()!\n", ms_mspro_error_to_string(error));
-#endif
-		return error;
-	}
+	//error = ms_mspro_check_data_consistency();
+	//if(error)
+	//{
+//#ifdef  MS_MSPRO_DEBUG
+//		Debug_Printf("#%s error occured in ms_mspro_check_data_consistency()!\n", ms_mspro_error_to_string(error));
+//#endif
+//		return error;
+//	}
 	
 #ifdef  MS_MSPRO_DEBUG
 	Debug_Printf("ms_mspro_init() is completed successfully!\n");
@@ -1383,16 +1411,14 @@
 	ms_mspro_info->init_retry = 0;
 	ms_mspro_info->raw_cid = ms_mspro_info->card_type;
 
-	memcpy(card_info, ms_mspro_info, sizeof(MS_MSPRO_Card_Info_t));
-
-    ms_save_hw_io_config = READ_PERIPHS_REG(SDIO_CONFIG);
-    ms_save_hw_io_mult_config = READ_PERIPHS_REG(SDIO_MULT_CONFIG);
+    ms_save_hw_io_config = READ_CBUS_REG(SDIO_CONFIG);
+    ms_save_hw_io_mult_config = READ_CBUS_REG(SDIO_MULT_CONFIG);
 	ms_save_hw_reg_flag = 1;
 
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_mspro_check_insert(void)
+int ms_mspro_check_insert(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	int level;
 	
@@ -1409,13 +1435,13 @@
 	{
 		if(ms_mspro_info->init_retry)
 		{
-			ms_mspro_power_off();
+			ms_mspro_power_off(ms_mspro_info);
 			ms_mspro_info->init_retry = 0;
 		}
 			
 		if(ms_mspro_info->inited_flag)
 		{
-			ms_mspro_power_off();
+			ms_mspro_power_off(ms_mspro_info);
 			ms_mspro_info->removed_flag = 1;
 			ms_mspro_info->inited_flag = 0;
 		}
@@ -1429,16 +1455,17 @@
 }
 
 #ifdef MS_MSPRO_HW_CONTROL
-int ms_mspro_read_data_hw(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int ms_mspro_read_data_hw(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error,tracer,i;
 	
 	unsigned long sector_nums, data_offset;
 	unsigned short logical_no,physical_no,page_no,last_seg_no,last_logical_no,page_nums;
 	unsigned long pages_per_block;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 
 	MS_MSPRO_TPC_Packet_t packet;
-	unsigned char buf[8] = {0,0,0,0,0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 	
 	if(byte_cnt == 0)
 	{
@@ -1448,13 +1475,13 @@
 #endif
 		return error;
 	}
-	 
-	 ms_sdio_enable();
+
+	 ms_sdio_enable(ms_mspro_info->io_pad_type);
 	 
 	if(ms_mspro_info->card_type == CARD_TYPE_MSPRO)
 	{
 		sector_nums = (byte_cnt+MSPRO_SECTOR_SIZE-1)/MSPRO_SECTOR_SIZE;
-		error = mspro_read_user_sector(lba, sector_nums, data_buf);
+		error = mspro_read_user_sector(ms_mspro_info, lba, sector_nums, data_buf);
 		tracer=0;
 		while (1)
 		{
@@ -1464,13 +1491,13 @@
 			packet.param.out.count = 1;
 			packet.param.out.buffer = buf;
 			packet.param.out.buffer[0] = CMD_MSPRO_STOP;
-			if (ms_mspro_packet_communicate(&packet))
+			if (ms_mspro_packet_communicate(ms_mspro_info, &packet))
 			{
-				if (ms_mspro_packet_communicate(&packet))
+				if (ms_mspro_packet_communicate(ms_mspro_info, &packet))
 				{
-					if (ms_mspro_packet_communicate(&packet))
+					if (ms_mspro_packet_communicate(ms_mspro_info, &packet))
 		{
-						ms_mspro_packet_communicate(&packet);
+						ms_mspro_packet_communicate(ms_mspro_info, &packet);
 					}
 				}
 			}
@@ -1483,7 +1510,7 @@
 			lba += mass_counter;
 			sector_nums -= mass_counter;
 			data_buf += MSPRO_SECTOR_SIZE*mass_counter;
-			error = mspro_read_user_sector(lba, sector_nums, data_buf);
+			error = mspro_read_user_sector(ms_mspro_info, lba, sector_nums, data_buf);
 		}	
 			if(error)
 			{
@@ -1531,7 +1558,7 @@
 			{
 				for(i=0; i<(pages_per_block - page_no); i++)
 				{
-					error = ms_read_page(physical_no, page_no++, data_buf);
+					error = ms_read_page(ms_mspro_info, physical_no, page_no++, data_buf);
 					if(error)
 					{
 #ifdef  MS_MSPRO_DEBUG
@@ -1553,7 +1580,7 @@
 			{
 				for(i=0; i<page_nums; i++)
 				{
-					error = ms_read_page(physical_no, page_no++, data_buf);
+					error = ms_read_page(ms_mspro_info, physical_no, page_no++, data_buf);
 					if(error)
 					{
 #ifdef  MS_MSPRO_DEBUG
@@ -1582,13 +1609,14 @@
 //#define MS_ONESECTOR_PERREAD
 
 
-int ms_mspro_read_data_sw(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int ms_mspro_read_data_sw(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error;
     int retry = 0;
 	unsigned long sector_nums, data_offset;
 	unsigned short logical_no,physical_no,page_no,last_seg_no,last_logical_no,page_nums;
 	unsigned long pages_per_block;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	if(byte_cnt == 0)
 	{
@@ -1599,7 +1627,7 @@
 		return error;
 	}
 	
-	ms_mspro_io_config();
+	ms_mspro_io_config(ms_mspro_info);
 	
 	if(ms_mspro_info->card_type == CARD_TYPE_MSPRO)
     {
@@ -1608,14 +1636,14 @@
         int i;
         for(i=0;i<sector_nums;i++){
             do {
-                error = mspro_read_user_sector(lba+i, 1, data_buf+(MSPRO_SECTOR_SIZE*i));
+                error = mspro_read_user_sector(ms_mspro_info, lba+i, 1, data_buf+(MSPRO_SECTOR_SIZE*i));
             } while(error && retry++<16);
             if(error)
                 break;
         }    
 #else
         do {
-            error = mspro_read_user_sector(lba, sector_nums, data_buf);
+            error = mspro_read_user_sector(ms_mspro_info, lba, sector_nums, data_buf);
         } while(error && retry++<16);
 #endif
         if(error)
@@ -1662,7 +1690,7 @@
 		
 			if(page_nums > (pages_per_block - page_no))
 			{
-				error = ms_read_block(physical_no, page_no, (pages_per_block - page_no), data_buf+data_offset);
+				error = ms_read_block(ms_mspro_info, physical_no, page_no, (pages_per_block - page_no), data_buf+data_offset);
 				if(error)
 				{
 #ifdef  MS_MSPRO_DEBUG
@@ -1681,7 +1709,7 @@
 			}
 			else
 			{
-				error = ms_read_block(physical_no, page_no, page_nums, data_buf+data_offset);
+				error = ms_read_block(ms_mspro_info, physical_no, page_no, page_nums, data_buf+data_offset);
 				if(error)
 				{
 #ifdef  MS_MSPRO_DEBUG
@@ -1706,16 +1734,17 @@
 #endif
 
 #ifdef MS_MSPRO_HW_CONTROL
-int ms_mspro_write_data_hw(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int ms_mspro_write_data_hw(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error,tracer,i,j,k;
 	
 	unsigned long sector_nums, data_offset;
 	unsigned short logical_no,physical_no,page_no,seg_no,last_seg_no,last_logical_no,page_nums,free_blk_no;
 	unsigned long pages_per_block,free_table_index;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	MS_MSPRO_TPC_Packet_t packet;
-	unsigned char buf[8] = {0,0,0,0,0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 	
 	if(byte_cnt == 0)
 	{
@@ -1744,12 +1773,12 @@
 		return error;
 	}
     
-     ms_sdio_enable();
+     ms_sdio_enable(ms_mspro_info->io_pad_type);
      
 	if(ms_mspro_info->card_type == CARD_TYPE_MSPRO)
 	{
 		sector_nums = (byte_cnt+MSPRO_SECTOR_SIZE-1)/MSPRO_SECTOR_SIZE;
-		error = mspro_write_user_sector(lba, sector_nums, data_buf);
+		error = mspro_write_user_sector(ms_mspro_info, lba, sector_nums, data_buf);
 		tracer=0;
 		while (1)
 		{
@@ -1759,13 +1788,13 @@
 			packet.param.out.count = 1;
 			packet.param.out.buffer = buf;
 			packet.param.out.buffer[0] = CMD_MSPRO_STOP;
-			if (ms_mspro_packet_communicate(&packet))
+			if (ms_mspro_packet_communicate(ms_mspro_info, &packet))
 			{
-				if (ms_mspro_packet_communicate(&packet))
+				if (ms_mspro_packet_communicate(ms_mspro_info, &packet))
 				{
-					if (ms_mspro_packet_communicate(&packet))
+					if (ms_mspro_packet_communicate(ms_mspro_info, &packet))
 		{
-						ms_mspro_packet_communicate(&packet);
+						ms_mspro_packet_communicate(ms_mspro_info, &packet);
 					}
 				}
 			}
@@ -1778,7 +1807,7 @@
 			lba += mass_counter;
 			sector_nums -= mass_counter;
 			data_buf += MSPRO_SECTOR_SIZE*mass_counter;
-			error = mspro_write_user_sector(lba, sector_nums, data_buf);
+			error = mspro_write_user_sector(ms_mspro_info, lba, sector_nums, data_buf);
 		}	
 			if(error)
 			{
@@ -1830,7 +1859,7 @@
 				free_blk_no = ms_mspro_buf->ms.free_block_table[free_table_index];
 				if(free_blk_no != 0xFFFF)
 				{
-					error = ms_read_extra_data(free_blk_no, 0);
+					error = ms_read_extra_data(ms_mspro_info, free_blk_no, 0);
 					if(error)
 						continue;
 						
@@ -1847,7 +1876,7 @@
 				return error;
 			}
 
-			error = ms_erase_block(free_blk_no);
+			error = ms_erase_block(ms_mspro_info, free_blk_no);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
@@ -1858,7 +1887,7 @@
 				
 			for(j=0; j<page_no; j++)
 			{
-				error = ms_copy_page(physical_no, j, free_blk_no, j, ms_mspro_buffer);
+				error = ms_copy_page(ms_mspro_info, physical_no, j, free_blk_no, j, ms_mspro_info->data_buf);
 				if(error)
 				{
 #ifdef  MS_MSPRO_DEBUG
@@ -1875,7 +1904,7 @@
 			{
 				for(i=page_no; i<pages_per_block; i++)
 				{
-				  error = ms_write_page(free_blk_no, i, data_buf+data_offset);
+				  error = ms_write_page(ms_mspro_info, free_blk_no, i, data_buf+data_offset);
 				  if(error)
 				  {
 #ifdef    MS_MSPRO_DEBUG
@@ -1905,7 +1934,7 @@
 			{
 				for(i=page_no; i<(page_no+page_nums); i++)
 				{
-				  error = ms_write_page(free_blk_no, i, data_buf+data_offset);
+				  error = ms_write_page(ms_mspro_info, free_blk_no, i, data_buf+data_offset);
 				  if(error)
 				  {
 #ifdef    MS_MSPRO_DEBUG
@@ -1930,7 +1959,7 @@
 
 				for(k=(page_no+page_nums); k<pages_per_block; k++)
 				{
-					error = ms_copy_page(physical_no, k, free_blk_no, k, ms_mspro_buffer);
+					error = ms_copy_page(ms_mspro_info, physical_no, k, free_blk_no, k, ms_mspro_info->data_buf);
 					if(error)
 					{
 #ifdef  MS_MSPRO_DEBUG
@@ -1963,13 +1992,14 @@
 #endif
 
 #ifdef MS_MSPRO_SW_CONTROL
-int ms_mspro_write_data_sw(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int ms_mspro_write_data_sw(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error,i,j,k;
 	
 	unsigned long sector_nums, data_offset;
 	unsigned short logical_no,physical_no,page_no,seg_no,last_seg_no,last_logical_no,page_nums,free_blk_no;
 	unsigned long pages_per_block,free_table_index;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	if(byte_cnt == 0)
 	{
@@ -1998,7 +2028,7 @@
 		return error;
 	}
 
-	ms_mspro_io_config();
+	ms_mspro_io_config(ms_mspro_info);
 
 	if(ms_mspro_info->card_type == CARD_TYPE_MSPRO)
 	{
@@ -2008,7 +2038,7 @@
 		//if(error)
 		//  return error;
 			
-		error = mspro_write_user_sector(lba, sector_nums, data_buf);
+		error = mspro_write_user_sector(ms_mspro_info, lba, sector_nums, data_buf);
 		if(error)
 		{
 #ifdef  MS_MSPRO_DEBUG
@@ -2059,7 +2089,7 @@
 				free_blk_no = ms_mspro_buf->ms.free_block_table[free_table_index];
 				if(free_blk_no != 0xFFFF)
 				{
-					error = ms_read_extra_data(free_blk_no, 0);
+					error = ms_read_extra_data(ms_mspro_info, free_blk_no, 0);
 					if(error)
 						continue;
 						
@@ -2076,7 +2106,7 @@
 				return error;
 			}
 
-			error = ms_erase_block(free_blk_no);
+			error = ms_erase_block(ms_mspro_info, free_blk_no);
 			if(error)
 			{
 #ifdef  MS_MSPRO_DEBUG
@@ -2087,7 +2117,7 @@
 				
 			for(j=0; j<page_no; j++)
 			{
-				error = ms_copy_page(physical_no, j, free_blk_no, j, ms_mspro_buffer);
+				error = ms_copy_page(ms_mspro_info, physical_no, j, free_blk_no, j, ms_mspro_info->data_buf);
 				if(error)
 				{
 #ifdef  MS_MSPRO_DEBUG
@@ -2116,7 +2146,7 @@
 				//  data_offset += MS_PAGE_SIZE;
 				//}
 				
-				error = ms_write_block(free_blk_no, page_no, (pages_per_block - page_no), data_buf+data_offset);
+				error = ms_write_block(ms_mspro_info, free_blk_no, page_no, (pages_per_block - page_no), data_buf+data_offset);
 				if(error)
 				{
 #ifdef  MS_MSPRO_DEBUG
@@ -2146,7 +2176,7 @@
 				//  data_offset += MS_PAGE_SIZE;
 				//}
 				
-				error = ms_write_block(free_blk_no, page_no, page_nums, data_buf+data_offset);
+				error = ms_write_block(ms_mspro_info, free_blk_no, page_no, page_nums, data_buf+data_offset);
 				if(error)
 				{
 #ifdef  MS_MSPRO_DEBUG
@@ -2159,7 +2189,7 @@
 
 				for(k=(page_no+page_nums); k<pages_per_block; k++)
 				{
-					error = ms_copy_page(physical_no, k, free_blk_no, k, ms_mspro_buffer);
+					error = ms_copy_page(ms_mspro_info, physical_no, k, free_blk_no, k, ms_mspro_info->data_buf);
 					if(error)
 					{
 #ifdef  MS_MSPRO_DEBUG
@@ -2191,10 +2221,10 @@
 }
 #endif
 
-void ms_mspro_io_config(void)
+void ms_mspro_io_config(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	int i;
-	ms_gpio_enable();
+	ms_gpio_enable(ms_mspro_info->io_pad_type);
 	
 	ms_set_clk_output();
 	ms_set_clk_high();
@@ -2209,66 +2239,38 @@
 	}
 }
 
-int ms_mspro_staff_init(void)
+int ms_mspro_staff_init(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	unsigned long sdio_config;
 	unsigned long sdio_multi_config;
 	SDIO_Multi_Config_Reg_t *multi_config_reg;
 	SDIO_Config_Reg_t *config_reg;
 	
-#ifdef MS_MSPRO_ALLOC_MEMORY
-	if(!ms_mspro_buf)
-	{
-		ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)ms_mspro_malloc(sizeof(MS_MSPRO_Card_Buffer_t),GFP_KERNEL);
-		if(!ms_mspro_buf)
-			return MS_MSPRO_ERROR_NO_MEMORY;
-		memset(ms_mspro_buf, 0, sizeof(MS_MSPRO_Card_Buffer_t));
-	}
-#endif
-
-	if(ms_mspro_buffer == NULL)
-	{
-	    //_phymem_node_t *memmap = Am_GetSystemMem(MEMMAP_DEFAULT, MEMITEM_DMA_DRAM);
-        //if(memmap != NULL && (memmap->end - memmap->start + 1)/MSPRO_SECTOR_SIZE)
-        //{
-        //    ms_mspro_buffer = (void *)(memmap->start);
-        //    ms_mspro_buf_from_sys = 1;
-        //}
-        //else
-        //{
-		    ms_mspro_buffer = (unsigned char *)ms_mspro_malloc(MSPRO_SECTOR_SIZE*2,GFP_KERNEL);
-		    if(ms_mspro_buffer == NULL)
-			    return MS_MSPRO_ERROR_NO_MEMORY;
-		    memset(ms_mspro_buffer, 0, MSPRO_SECTOR_SIZE*2);
-		    ms_mspro_buf_from_sys = 0;
-	    //}
-	}
-	
-	ms_mspro_prepare_power();
-	ms_mspro_power_on();
+	ms_mspro_prepare_power(ms_mspro_info);
+	ms_mspro_power_on(ms_mspro_info);
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
 	{
-		sdio_multi_config = (READ_PERIPHS_REG(SDIO_MULT_CONFIG) & 0x00000003);
+		sdio_multi_config = (READ_CBUS_REG(SDIO_MULT_CONFIG) & 0x00000003);
 		multi_config_reg = (void *)&sdio_multi_config;
 		multi_config_reg->ms_enable = 1;
 		multi_config_reg->ms_sclk_always = 1;
-		WRITE_PERIPHS_REG(SDIO_MULT_CONFIG, sdio_multi_config);
+		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sdio_multi_config);
 	
 		sdio_config = 0;
 		config_reg = (void *)&sdio_config;
 		config_reg->cmd_clk_divide = 3;//aml_system_clk / (2*MS_MSPRO_TRANSFER_SLOWER_CLK) -1;
 		config_reg->m_endian = 3;
-		WRITE_PERIPHS_REG(SDIO_CONFIG, sdio_config);
+		WRITE_CBUS_REG(SDIO_CONFIG, sdio_config);
 		ms_mspro_info->ms_clk_unit = 1000/MS_MSPRO_TRANSFER_CLK;
 		
-		ms_sdio_enable();
+		ms_sdio_enable(ms_mspro_info->io_pad_type);
 	}
 #endif
 #ifdef MS_MSPRO_SW_CONTROL
 	if(MS_WORK_MODE == CARD_SW_MODE)
-		ms_mspro_io_config();
+		ms_mspro_io_config(ms_mspro_info);
 #endif
 
 	ms_mspro_info->card_type = CARD_NONE_TYPE;
@@ -2287,10 +2289,11 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_mspro_cmd_test(void)
+int ms_mspro_cmd_test(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	int error;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	packet.TPC_cmd.value = TPC_MS_MSPRO_SET_RW_REG_ADRS;
 	packet.param.out.count = 4;             				//READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
@@ -2298,12 +2301,12 @@
 	ms_mspro_buf->mspro.reg_set.write_size = 0x06;
 	packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
 	
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	
 	return error;
 }
 
-void ms_mspro_power_on()
+void ms_mspro_power_on(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	ms_delay_ms(ms_mspro_power_delay+1);
 
@@ -2320,14 +2323,14 @@
 	ms_delay_ms(200);
 	if(ms_mspro_info->ms_mspro_power)
 	{
-		if(ms_mspro_check_insert()) //ensure card wasn't removed at this time
+		if(ms_mspro_check_insert(ms_mspro_info)) //ensure card wasn't removed at this time
 		{
 			ms_mspro_info->ms_mspro_power(1);
 		}
 	}
 	else
 	{
-		if(ms_mspro_check_insert()) //ensure card wasn't removed at this time
+		if(ms_mspro_check_insert(ms_mspro_info)) //ensure card wasn't removed at this time
 		{
 			ms_set_enable();
 		}
@@ -2339,7 +2342,7 @@
 
 }
 
-void ms_mspro_power_off()
+void ms_mspro_power_off(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 #ifdef MS_MSPRO_POWER_CONTROL
 	if(ms_mspro_info->ms_mspro_power)
@@ -2354,30 +2357,30 @@
 }
 
 //check data lines consistency
-int ms_mspro_check_data_consistency()
+int ms_mspro_check_data_consistency(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	int error;
-	unsigned char *mbr_buf = ms_mspro_buffer;
+	unsigned char *mbr_buf = ms_mspro_info->data_buf;
 	
 	//This card is working in parallel bus mode!
 	memset(mbr_buf, 0, ms_mspro_info->blk_len*2);
 	if(ms_mspro_info->interface_mode == INTERFACE_PARALLEL)
 	{
 		//read MBR information
-		error = ms_mspro_read_data(0, ms_mspro_info->blk_len*2, mbr_buf);
+		error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len*2, mbr_buf);
 		if(error)
 		{
 			//error! retry again!
-			error = ms_mspro_read_data(0, ms_mspro_info->blk_len, mbr_buf);
+			error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len, mbr_buf);
 			if(error)
 				return error;
 		}
 
-		error = ms_mspro_read_data(0, ms_mspro_info->blk_len*2, mbr_buf);
+		error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len*2, mbr_buf);
 		if(error)
 		{
 			//error! retry again!
-			error = ms_mspro_read_data(0, ms_mspro_info->blk_len, mbr_buf);
+			error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len, mbr_buf);
 			if(error)
 				return error;
 		}
@@ -2386,7 +2389,7 @@
 		if((mbr_buf[510] != 0x55) || (mbr_buf[511] != 0xAA))
 		{
 			//data consistency error! retry again!
-			error = ms_mspro_read_data(0, ms_mspro_info->blk_len, mbr_buf);
+			error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len, mbr_buf);
 			if(error)
 				return error;
 			
@@ -2398,7 +2401,7 @@
 #endif
 
 				//error again! retry serial bus mode!
-				error = ms_mspro_interface_mode_switching(INTERFACE_SERIAL);
+				error = ms_mspro_interface_mode_switching(ms_mspro_info, INTERFACE_SERIAL);
 				if(error)
 					return error;
 			}
@@ -2416,11 +2419,11 @@
 	//This card is working in serial bus mode!
 	memset(mbr_buf, 0, ms_mspro_info->blk_len);
 	//read MBR information
-	error = ms_mspro_read_data(0, ms_mspro_info->blk_len, mbr_buf);
+	error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len, mbr_buf);
 	if(error)
 	{
 		//error! retry again!
-		error = ms_mspro_read_data(0, ms_mspro_info->blk_len, mbr_buf);
+		error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len, mbr_buf);
 		if(error)
 			return error;
 	}
@@ -2429,7 +2432,7 @@
 	if((mbr_buf[510] != 0x55) || (mbr_buf[511] != 0xAA))
 	{
 		//data consistency error! retry again!
-		error = ms_mspro_read_data(0, ms_mspro_info->blk_len, mbr_buf);
+		error = ms_mspro_read_data(ms_mspro_info, 0, ms_mspro_info->blk_len, mbr_buf);
 		if(error)
 			return error;
 			
@@ -2443,23 +2446,23 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_mspro_packet_communicate(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_packet_communicate(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
 	int error = 0;
 	
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
-		error = ms_mspro_packet_communicate_hw(tpc_packet);
+		error = ms_mspro_packet_communicate_hw(ms_mspro_info, tpc_packet);
 #endif
 #ifdef MS_MSPRO_SW_CONTROL
 	if(MS_WORK_MODE == CARD_SW_MODE)
-		error = ms_mspro_packet_communicate_sw(tpc_packet);
+		error = ms_mspro_packet_communicate_sw(ms_mspro_info, tpc_packet);
 #endif
 
 		return error;
 }
 
-int ms_mspro_read_data(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int ms_mspro_read_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error = 0;
 	
@@ -2468,44 +2471,44 @@
     {
     	if(ms_save_hw_reg_flag)
     	{
-        	WRITE_PERIPHS_REG(SDIO_CONFIG, ms_save_hw_io_config);
-        	WRITE_PERIPHS_REG(SDIO_MULT_CONFIG, ms_save_hw_io_mult_config);
+        	WRITE_CBUS_REG(SDIO_CONFIG, ms_save_hw_io_config);
+        	WRITE_CBUS_REG(SDIO_MULT_CONFIG, ms_save_hw_io_mult_config);
         }
-		error = ms_mspro_read_data_hw(lba, byte_cnt, data_buf);	
+		error = ms_mspro_read_data_hw(ms_mspro_info, lba, byte_cnt, data_buf);	
 	}
 #endif
 #ifdef MS_MSPRO_SW_CONTROL
 	if(MS_WORK_MODE == CARD_SW_MODE)
-		error = ms_mspro_read_data_sw(lba, byte_cnt, data_buf);
+		error = ms_mspro_read_data_sw(ms_mspro_info, lba, byte_cnt, data_buf);
 #endif
 
 	return error;
 }
 
-int ms_mspro_wait_int(MS_MSPRO_TPC_Packet_t * tpc_packet)
+int ms_mspro_wait_int(MS_MSPRO_Card_Info_t *ms_mspro_info, MS_MSPRO_TPC_Packet_t * tpc_packet)
 {
-	int error;
+	int error = 0;
 	
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
 	{
 		if(ms_save_hw_reg_flag)
     	{
-        	WRITE_PERIPHS_REG(SDIO_CONFIG, ms_save_hw_io_config);
-        	WRITE_PERIPHS_REG(SDIO_MULT_CONFIG, ms_save_hw_io_mult_config);
+        	WRITE_CBUS_REG(SDIO_CONFIG, ms_save_hw_io_config);
+        	WRITE_CBUS_REG(SDIO_MULT_CONFIG, ms_save_hw_io_mult_config);
         }
-		error = ms_mspro_wait_int_hw(tpc_packet);
+		error = ms_mspro_wait_int_hw(ms_mspro_info, tpc_packet);
 	}
 #endif
 #ifdef MS_MSPRO_SW_CONTROL
 	if(MS_WORK_MODE == CARD_SW_MODE)
-		error = ms_mspro_wait_int_sw(tpc_packet);
+		error = ms_mspro_wait_int_sw(ms_mspro_info, tpc_packet);
 #endif
 
 	return error;
 }
 
-int ms_mspro_write_data(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int ms_mspro_write_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error = 0;
 
@@ -2514,10 +2517,10 @@
 	{
     	if(ms_save_hw_reg_flag)
     	{
-        	WRITE_PERIPHS_REG(SDIO_CONFIG, ms_save_hw_io_config);
-        	WRITE_PERIPHS_REG(SDIO_MULT_CONFIG, ms_save_hw_io_mult_config);
+        	WRITE_CBUS_REG(SDIO_CONFIG, ms_save_hw_io_config);
+        	WRITE_CBUS_REG(SDIO_MULT_CONFIG, ms_save_hw_io_mult_config);
         }
-		error = ms_mspro_write_data_hw(lba, byte_cnt, data_buf);
+		error = ms_mspro_write_data_hw(ms_mspro_info, lba, byte_cnt, data_buf);
 	}
 #endif
 #ifdef MS_MSPRO_SW_CONTROL
@@ -2526,48 +2529,35 @@
 	#ifdef AVOS		
 		ms_delay_ms(2);	
 	#endif 	
-		error = ms_mspro_write_data_sw(lba, byte_cnt, data_buf);			
+		error = ms_mspro_write_data_sw(ms_mspro_info, lba, byte_cnt, data_buf);			
 	}		
 #endif
 
 	return error;
 }
 
-void ms_mspro_exit(void)
-{
+void ms_mspro_exit(MS_MSPRO_Card_Info_t *ms_mspro_info)
+{	
 	if(ms_mspro_info->ms_mspro_io_release)
 		ms_mspro_info->ms_mspro_io_release();
 		
 	check_one_boot_block = 0;
 	mspro_access_status_reg_after_read = 0;
-	
-#ifdef MS_MSPRO_ALLOC_MEMORY
-	if(ms_mspro_buf)
-	{
-		ms_mspro_free(ms_mspro_buf);
-		ms_mspro_buf = NULL;
-		if(!ms_mspro_buf_from_sys)
-		{
-		    ms_mspro_free(ms_mspro_buffer);
-		    ms_mspro_buffer = NULL;
-		}
-	}
-#endif
 }
 
-void ms_mspro_prepare_init(void)
+void ms_mspro_prepare_init(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
-	//if(ms_mspro_power_register)
-	//	ms_mspro_info->ms_mspro_power = ms_mspro_power_register;
-	//if(ms_mspro_ins_register)
-	//	ms_mspro_info->ms_mspro_get_ins = ms_mspro_ins_register;
-	//if(ms_mspro_io_release_register)
-	//	ms_mspro_info->ms_mspro_io_release = ms_mspro_io_release_register;
+	if(ms_mspro_power_register)
+		ms_mspro_info->ms_mspro_power = ms_mspro_power_register;
+	if(ms_mspro_ins_register)
+		ms_mspro_info->ms_mspro_get_ins = ms_mspro_ins_register;
+	if(ms_mspro_io_release_register)
+		ms_mspro_info->ms_mspro_io_release = ms_mspro_io_release_register;
 }
 
-void ms_mspro_prepare_power(void)
+void ms_mspro_prepare_power(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
-	ms_gpio_enable();
+	ms_gpio_enable(ms_mspro_info->io_pad_type);
 	
 	ms_set_clk_output();
 	ms_set_clk_low();
@@ -2577,25 +2567,3 @@
 	ms_set_bs_state(0);
 }
 
-//void ms_mspro_get_info(blkdev_stat_t *info)
-//{
-//	if(info->magic != BLKDEV_STAT_MAGIC)
-//		return;
-//	info->valid = 1;
-//	info->blk_size = ms_mspro_info->blk_len;
-//	info->blk_num = ms_mspro_info->blk_nums;
-//	info->st_read_only = ms_mspro_info->read_only_flag;
-//	info->st_write_protect = ms_mspro_info->write_protected_flag;
-//	switch(ms_mspro_info->card_type)
-//	{
-//		case CARD_TYPE_MS:
-//			info->blkdev_name = "MS card";
-//			break;
-//		case CARD_TYPE_MSPRO:
-//			info->blkdev_name = "MSPRO card";
-//			break;
-//		default:
-//			break;
-//	}	
-//}
-
diff -Nur drivers/amlogic/cardreader/ms/ms_mspro.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_mspro.h
--- drivers/amlogic/cardreader/ms/ms_mspro.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_mspro.h	2011-07-14 00:17:51.976739983 +0800
@@ -4,11 +4,12 @@
 #include <linux/slab.h>
 #include <linux/types.h>
     
-#include <asm/drivers/cardreader/cardreader.h>
-#include <asm/drivers/cardreader/card_io.h>
-#include <asm/drivers/cardreader/sdio_hw.h>
+#include <linux/cardreader/card_block.h>
+#include <linux/cardreader/cardreader.h>
+#include <linux/cardreader/sdio_hw.h>
+#include <mach/card_io.h>
+
 #include "ms_protocol.h"
-#include "mspro_protocol.h"
     
 #pragma pack(1)
 typedef struct _MS_MSPRO_INT_Register  {
@@ -55,44 +56,76 @@
 } MS_MSPRO_Reg_Set_t;
 
 #pragma pack()
-typedef enum _MS_MSPRO_Card_Type 
-    { CARD_NONE_TYPE = 0, CARD_TYPE_MS, CARD_TYPE_MSPRO 
+typedef enum _MS_MSPRO_Card_Type 
+{ 
+	CARD_NONE_TYPE = 0, 
+	CARD_TYPE_MS, 
+	CARD_TYPE_MSPRO 
 } MS_MSPRO_Card_Type_t;
-typedef enum _MS_MSPRO_Interface_Mode 
-    { INTERFACE_SERIAL = 1, INTERFACE_PARALLEL = 4 
-} MS_MSPRO_Interface_Mode_t;
-typedef enum _MS_MSPRO_Error_Status 
-    { MS_MSPRO_NO_ERROR =
-0, MS_MSPRO_ERROR_TPC_FORMAT, MS_MSPRO_ERROR_RDY_TIMEOUT, MS_MSPRO_ERROR_INT_TIMEOUT,
-	MS_MSPRO_ERROR_DATA_CRC, MS_MSPRO_ERROR_MEDIA_TYPE,
-	MS_MSPRO_ERROR_CMDNK, MS_MSPRO_ERROR_CED,
-	MS_MSPRO_ERROR_FLASH_READ, MS_MSPRO_ERROR_FLASH_WRITE,
-	MS_MSPRO_ERROR_FLASH_ERASE,
-	MS_MSPRO_ERROR_PARAMETER, MS_MSPRO_ERROR_WRITE_PROTECTED,
-	MS_MSPRO_ERROR_READ_ONLY,
-	MS_ERROR_BOOT_SEARCH, MS_ERROR_MEMORY_STICK_TYPE,
-	MS_ERROR_FORMAT_TYPE, MS_ERROR_BLOCK_NUMBER_SIZE,
-	MS_ERROR_DISABLED_BLOCK, MS_ERROR_NO_FREE_BLOCK,
-	MS_ERROR_LOGICAL_PHYSICAL_TABLE, MS_ERROR_BOOT_IDI,
-	MSPRO_ERROR_MEDIA_BREAKDOWN, MSPRO_ERROR_STARTUP_TIMEOUT,
-	MSPRO_ERROR_WRITE_DISABLED, 
-#ifdef MS_MSPRO_HW_CONTROL
-	    MS_MSPRO_ERROR_TIMEOUT, MS_MSPRO_ERROR_UNSUPPORTED, 
-#endif				/*  */
-	MS_MSPRO_ERROR_NO_MEMORY, MS_MSPRO_ERROR_NO_READ 
-} MS_MSPRO_Error_Status_t;
-typedef enum _MS_MSPRO_Media_Type 
-    { MEMORY_STICK_ERROR, MEMORY_STICK, MEMORY_STICK_WITH_SP,
-	MEMORY_STICK_ROM, MEMORY_STICK_R, MEMORY_STICK_ROM_WITH_SP,
-	MEMORY_STICK_R_WITH_SP,
-	MEMORY_STICK_PRO, MEMORY_STICK_PRO_ROM, MEMORY_STICK_PRO_R,
-	MEMORY_STICK_IO,
-	MEMORY_STICK_PRO_IO 
-} MS_MSPRO_Media_Type_t;
-typedef enum _Endian_Type 
-    { ENDIAN_TYPE_WORD = 2, ENDIAN_TYPE_DWORD = 4, ENDIAN_TYPE_QWORD = 8 
-} Endian_Type_t;
-typedef union _MS_MSPRO_Card_Buffer  {
+
+typedef enum _MS_MSPRO_Interface_Mode 
+{ 
+	INTERFACE_SERIAL = 1, 
+	INTERFACE_PARALLEL = 4 
+} MS_MSPRO_Interface_Mode_t;
+
+typedef enum _MS_MSPRO_Error_Status 
+{ 
+    	MS_MSPRO_NO_ERROR =0, 
+    	MS_MSPRO_ERROR_TPC_FORMAT, 
+    	MS_MSPRO_ERROR_RDY_TIMEOUT, 
+    	MS_MSPRO_ERROR_INT_TIMEOUT,
+    	MS_MSPRO_ERROR_DATA_CRC, 
+    	MS_MSPRO_ERROR_MEDIA_TYPE,
+	MS_MSPRO_ERROR_CMDNK, 
+	MS_MSPRO_ERROR_CED,
+	MS_MSPRO_ERROR_FLASH_READ, 
+	MS_MSPRO_ERROR_FLASH_WRITE,
+	MS_MSPRO_ERROR_FLASH_ERASE,
+	MS_MSPRO_ERROR_PARAMETER, 
+	MS_MSPRO_ERROR_WRITE_PROTECTED,
+	MS_MSPRO_ERROR_READ_ONLY,
+	MS_ERROR_BOOT_SEARCH, 
+	MS_ERROR_MEMORY_STICK_TYPE,
+	MS_ERROR_FORMAT_TYPE, 
+	MS_ERROR_BLOCK_NUMBER_SIZE,
+	MS_ERROR_DISABLED_BLOCK, 
+	MS_ERROR_NO_FREE_BLOCK,
+	MS_ERROR_LOGICAL_PHYSICAL_TABLE, 
+	MS_ERROR_BOOT_IDI,
+	MSPRO_ERROR_MEDIA_BREAKDOWN, 
+	MSPRO_ERROR_STARTUP_TIMEOUT,
+	MSPRO_ERROR_WRITE_DISABLED, 
+	MS_MSPRO_ERROR_TIMEOUT, 
+	MS_MSPRO_ERROR_UNSUPPORTED, 
+	MS_MSPRO_ERROR_NO_MEMORY, 
+	MS_MSPRO_ERROR_NO_READ 
+} MS_MSPRO_Error_Status_t;
+
+typedef enum _MS_MSPRO_Media_Type 
+{ 
+	MEMORY_STICK_ERROR, 
+	MEMORY_STICK, 
+	MEMORY_STICK_WITH_SP,
+	MEMORY_STICK_ROM, 
+	MEMORY_STICK_R, 
+	MEMORY_STICK_ROM_WITH_SP,
+	MEMORY_STICK_R_WITH_SP,
+	MEMORY_STICK_PRO, 
+	MEMORY_STICK_PRO_ROM, 
+	MEMORY_STICK_PRO_R,
+	MEMORY_STICK_IO,
+	MEMORY_STICK_PRO_IO 
+} MS_MSPRO_Media_Type_t;
+
+typedef enum _Endian_Type 
+{ 
+	ENDIAN_TYPE_WORD = 2, 
+	ENDIAN_TYPE_DWORD = 4, 
+	ENDIAN_TYPE_QWORD = 8 
+} Endian_Type_t;
+
+typedef union _MS_MSPRO_Card_Buffer  {
 	struct  {
 		MS_Registers_t regs;
 		MS_MSPRO_Reg_Set_t reg_set;
@@ -120,7 +153,8 @@
 		unsigned char system_entry_index;
 		MSPRO_System_Information_t system_information;
 	} mspro;
-} MS_MSPRO_Card_Buffer_t;
+} MS_MSPRO_Card_Buffer_t;
+
 typedef struct _MS_MSPRO_Card_Info  {
 	MS_MSPRO_Card_Type_t card_type;
 	MS_MSPRO_Media_Type_t media_type;
@@ -133,13 +167,24 @@
 	int removed_flag;
 	int init_retry;
 	u32 raw_cid;
-	unsigned ms_clk_unit;
+	unsigned ms_clk_unit;
+	
 	void (*ms_mspro_power) (int power_on);
 	int (*ms_mspro_get_ins) (void);
-	void (*ms_mspro_io_release) (void);
-} MS_MSPRO_Card_Info_t;
-extern MS_MSPRO_Card_Info_t *ms_mspro_info;
-extern MS_MSPRO_Card_Buffer_t *ms_mspro_buf;
+	void (*ms_mspro_io_release) (void);
+	
+	SDIO_Pad_Type_t  io_pad_type;	/* hw io pin pad */
+	
+	unsigned char *dma_buf;
+	unsigned char *dma_phy_buf;
+
+	unsigned char *ms_mspro_buf;
+	unsigned char *ms_mspro_phy_buf;
+
+	unsigned char* data_buf;
+	unsigned char* data_phy_buf;
+	
+} MS_MSPRO_Card_Info_t;
 
 //Transfer Protocol Command (TPC)
 #define TPC_MS_READ_PAGE_DATA               0x2D
@@ -165,27 +210,5 @@
 #define MS_MSPRO_TRANSFER_HIGHSPEED_CLK				25	//M HZ
     
 #define MS_WRITE_ESPECIAL_CAPACITY_BLOCKS				130000
-//Following functions only used in ms_protocol.c and mspro_protocol.c
-int ms_mspro_wait_int(MS_MSPRO_TPC_Packet_t * tpc_packet);
-int ms_mspro_wait_rdy(MS_MSPRO_TPC_Packet_t * tpc_packet);
-int ms_mspro_write_tpc(MS_MSPRO_TPC_Packet_t * tpc_packet);
-int ms_mspro_read_data_line(MS_MSPRO_TPC_Packet_t * tpc_packet);
-int ms_mspro_write_data_line(MS_MSPRO_TPC_Packet_t * tpc_packet);
-int ms_mspro_packet_communicate(MS_MSPRO_TPC_Packet_t * tpc_packet);
-char *ms_mspro_error_to_string(int errcode);
-void ms_mspro_endian_convert(Endian_Type_t data_type, void *data);
-
-//Following functions are the API used for outside routinue
-//void ms_mspro_get_info(blkdev_stat_t *info);
-int ms_mspro_init(MS_MSPRO_Card_Info_t * card_info);
-void ms_mspro_exit(void);
-void ms_mspro_prepare_init(void);
-int ms_mspro_check_insert(void);
-int ms_mspro_read_data(unsigned long lba, unsigned long byte_cnt,
-			unsigned char *data_buf);
-int ms_mspro_write_data(unsigned long lba, unsigned long byte_cnt,
-			 unsigned char *data_buf);
-void ms_mspro_power_on(void);
-void ms_mspro_power_off(void);
 
 #endif				//_H_MS_MSPRO
diff -Nur drivers/amlogic/cardreader/ms/ms_port.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_port.h
--- drivers/amlogic/cardreader/ms/ms_port.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_port.h	2011-07-14 00:17:51.976739983 +0800
@@ -3,9 +3,8 @@
 
 #include <asm/types.h>
 #include <asm/io.h>
-#include <asm/arch/am_regs.h>
-
-#include <asm/drivers/cardreader/card_io.h>
+#include <mach/am_regs.h>
+#include <mach/card_io.h>
     
 //Following I/O configurations are just for default case if no any known PCB defined
     
@@ -13,7 +12,14 @@
     
 //Port operation for MS BUS
 //write it as such form that could be replaced by function later if needed
-extern int i_GPIO_timer;
+extern int i_GPIO_timer;
+extern void (*ms_mspro_power_register) (int power_on);
+extern int (*ms_mspro_ins_register) (void);
+extern int (*ms_mspro_wp_register) (void);
+extern void (*ms_mspro_io_release_register) (void);
+
+extern void sd_sdio_enable(SDIO_Pad_Type_t io_pad_type);
+extern void sd_gpio_enable(SDIO_Pad_Type_t io_pad_type);
 
 #ifdef MS_IO_EXTERNAL
 extern unsigned MS_BS_OUTPUT_EN_REG;
@@ -51,8 +57,10 @@
     //extern void (*ms_mspro_io_release_register)(void);
     
 #define MS_MSPRO_POWER_CONTROL
-void ms_sdio_enable(void);
-void ms_gpio_enable(void);
+//void ms_sdio_enable(void);
+//void ms_gpio_enable(void);
+#define ms_sdio_enable sd_sdio_enable
+#define ms_gpio_enable sd_gpio_enable
 
 #else				//MS_IO_EXTERNAL
     
@@ -93,8 +101,8 @@
     
 #define MS_MSPRO_POWER_CONTROL          
     
-#define ms_sdio_enable()				{SET_PERIPHS_REG_BITS(PERIPHS_PIN_MUX_2, 0x3F);SET_PERIPHS_REG_BITS(SDIO_MULT_CONFIG, (1));}      
-#define ms_gpio_enable()				{CLEAR_PERIPHS_REG_BITS(PERIPHS_PIN_MUX_2, 0x3F);CLEAR_PERIPHS_REG_BITS(SDIO_MULT_CONFIG, (1));}  
+#define ms_sdio_enable()			{SET_CBUS_REG_MASK(CARD_PIN_MUX_0, (0x3F<<23));SET_CBUS_REG_MASK(SDIO_MULT_CONFIG, (0));}
+#define ms_gpio_enable()			{CLEAR_CBUS_REG_MASK(CARD_PIN_MUX_0, (0x3F<<23));CLEAR_CBUS_REG_MASK(SDIO_MULT_CONFIG, (0));}
     
 #endif				//MS_IO_EXTERNAL                     
     
diff -Nur drivers/amlogic/cardreader/ms/mspro_protocol.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/mspro_protocol.c
--- drivers/amlogic/cardreader/ms/mspro_protocol.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/mspro_protocol.c	2011-07-14 00:17:51.976739983 +0800
@@ -7,8 +7,10 @@
 extern unsigned short mass_counter;
 extern unsigned mspro_access_status_reg_after_read;
 
-int mspro_media_type_identification()
+int mspro_media_type_identification(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
+
 	if (ms_mspro_buf->mspro.regs.Type_Reg != 0x01)
 		return MS_MSPRO_ERROR_MEDIA_TYPE;
 		
@@ -38,10 +40,11 @@
 }
 }
 
-int mspro_cpu_startup(void)
+int mspro_cpu_startup(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
@@ -55,7 +58,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->mspro.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			continue;
 			
@@ -67,7 +70,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->mspro.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			continue;
 
@@ -97,14 +100,15 @@
 			return MS_MSPRO_NO_ERROR;
 }
 
-int mspro_confirm_attribute_information(unsigned char * data_buf)
+int mspro_confirm_attribute_information(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char * data_buf)
 {
 	int error,i;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	unsigned char entry_cnt = 0, entry_index = 0;
 
 	// read attribute information
-	error = mspro_read_attribute_sector(0, 1, data_buf);
+	error = mspro_read_attribute_sector(ms_mspro_info, 0, 1, data_buf);
 	if(error)
 		return error;
 		
@@ -153,11 +157,12 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int mspro_confirm_system_information(unsigned char * data_buf)
+int mspro_confirm_system_information(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char * data_buf)
 {
 	int error;
 	
 	unsigned short sector_addr, data_offset, data_size;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	
 	sector_addr = ms_mspro_buf->mspro.device_information_entry[ms_mspro_buf->mspro.system_entry_index].Address / MSPRO_SECTOR_SIZE;
@@ -165,7 +170,7 @@
 	data_size = ms_mspro_buf->mspro.device_information_entry[ms_mspro_buf->mspro.system_entry_index].Size;
 	
 	// read system information
-	error = mspro_read_attribute_sector(sector_addr, 1, data_buf);
+	error = mspro_read_attribute_sector(ms_mspro_info, sector_addr, 1, data_buf);
 	if(error)
 		return error;
 	// save system information
@@ -174,7 +179,7 @@
 	if(data_size > (MSPRO_SECTOR_SIZE-data_offset))
 	{
 		// read system information
-		error = mspro_read_attribute_sector(sector_addr+1, 1, data_buf);
+		error = mspro_read_attribute_sector(ms_mspro_info, sector_addr+1, 1, data_buf);
 		if(error)
 			return error;
 		// save system information
@@ -231,15 +236,16 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int mspro_read_user_sector(unsigned long sector_addr, unsigned short sector_count, unsigned char * data_buf)
+int mspro_read_user_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr, unsigned short sector_count, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
 	unsigned long data_offset = 0;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 
 	int error;
 	
-	unsigned char buf[8] = {0,0,0,0,0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 		
 	mass_counter=0;
 	
@@ -254,7 +260,7 @@
 		ms_mspro_buf->mspro.reg_set.write_addr = 0x11;
 		ms_mspro_buf->mspro.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -271,7 +277,7 @@
 		ms_mspro_buf->mspro.regs.parameters.data.Data_Address_Reg1 = (sector_addr>>8) & 0xFF;
 		ms_mspro_buf->mspro.regs.parameters.data.Data_Address_Reg0 = sector_addr & 0xFF;
 		packet.param.out.buffer = &ms_mspro_buf->mspro.regs.Data_Count_Reg1;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -279,7 +285,7 @@
 		packet.param.out.count = 1;
 		packet.param.out.buffer = buf;
 		packet.param.out.buffer[0] = read_sector_type ? CMD_MSPRO_READ_ATRB : CMD_MSPRO_READ_DATA;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -297,7 +303,7 @@
 		packet.param.out.buffer[4] = (sector_addr>>16) & 0xFF;
 		packet.param.out.buffer[5] = (sector_addr>>8) & 0xFF;
 		packet.param.out.buffer[6] = sector_addr & 0xFF;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 }
@@ -305,7 +311,7 @@
 
 	while(1)
 	{
-		error = ms_mspro_wait_int(&packet);
+		error = ms_mspro_wait_int(ms_mspro_info, &packet);
 		if(error)
 			return error;
 			
@@ -319,7 +325,7 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 			packet.param.in.count = 1;
 			packet.param.in.buffer = &ms_mspro_buf->mspro.regs.INT_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -354,7 +360,7 @@
 		packet.TPC_cmd.value = TPC_MSPRO_READ_LONG_DATA;    //READ_LONG_DATA
 		packet.param.in.count = MSPRO_SECTOR_SIZE;      //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = data_buf+data_offset;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -375,14 +381,14 @@
 		ms_mspro_buf->ms.reg_set.read_addr = 0x02;           //READ_ADRS = 0x02
 		ms_mspro_buf->ms.reg_set.read_size = 0x01;           //READ_SIZE = 0x06
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
 		packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 		packet.param.in.count = 1;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.Status_Reg0;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -390,15 +396,16 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int mspro_write_user_sector(unsigned long sector_addr, unsigned short sector_count, unsigned char * data_buf)
+int mspro_write_user_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr, unsigned short sector_count, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
 	unsigned long data_offset = 0;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[8] = {0,0,0,0,0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 	mass_counter=0;
 
@@ -413,7 +420,7 @@
 		ms_mspro_buf->mspro.reg_set.write_addr = 0x11;
 		ms_mspro_buf->mspro.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -430,7 +437,7 @@
 		ms_mspro_buf->mspro.regs.parameters.data.Data_Address_Reg1 = (sector_addr>>8) & 0xFF;
 		ms_mspro_buf->mspro.regs.parameters.data.Data_Address_Reg0 = sector_addr & 0xFF;
 		packet.param.out.buffer = &ms_mspro_buf->mspro.regs.Data_Count_Reg1;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -438,7 +445,7 @@
 		packet.param.out.count = 1;
 		packet.param.out.buffer = buf;
 		packet.param.out.buffer[0] = CMD_MSPRO_WRITE_DATA;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -457,7 +464,7 @@
 		packet.param.out.buffer[4] = (sector_addr>>16) & 0xFF;
 		packet.param.out.buffer[5] = (sector_addr>>8) & 0xFF;
 		packet.param.out.buffer[6] = sector_addr & 0xFF;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -465,7 +472,7 @@
 
 	while(1)
 	{
-		error = ms_mspro_wait_int(&packet);
+		error = ms_mspro_wait_int(ms_mspro_info, &packet);
 		if(error)
 			return error;
 			
@@ -479,7 +486,7 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 			packet.param.in.count = 1;
 			packet.param.in.buffer = &ms_mspro_buf->mspro.regs.INT_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 	}
@@ -506,7 +513,7 @@
 		packet.TPC_cmd.value = TPC_MSPRO_WRITE_LONG_DATA;   //WRITE_LONG_DATA
 		packet.param.out.count = MSPRO_SECTOR_SIZE;     //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = data_buf+data_offset;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -518,16 +525,18 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int mspro_erase_user_sector(unsigned long sector_addr, unsigned short sector_count)
+int mspro_erase_user_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr, unsigned short sector_count)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
-	unsigned char report_buf[MSPRO_REPORT_SIZE];
+	//unsigned char report_buf[MSPRO_REPORT_SIZE];
 	unsigned long all_sectorts = 0, processed_sectors = 0;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 
 	int error;
 	
-	unsigned char buf[8] = {0,0,0,0,0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
+	unsigned char* report_buf = ms_mspro_info->data_buf;
 	
 	memset(report_buf, 0, MSPRO_REPORT_SIZE);
 		
@@ -545,7 +554,7 @@
 			ms_mspro_buf->mspro.reg_set.write_addr = 0x11;
 			ms_mspro_buf->mspro.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -562,7 +571,7 @@
 			ms_mspro_buf->mspro.reg_set.write_addr = 0x11;
 			ms_mspro_buf->mspro.reg_set.write_size = 0x07;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -586,7 +595,7 @@
 	ms_mspro_buf->mspro.regs.parameters.data.Data_Address_Reg0 = sector_addr & 0xFF;
 	ms_mspro_buf->mspro.regs.parameters.data.TPC_Pamameter_Reg = MSPRO_REPORT_TYPE;
 	packet.param.out.buffer = &ms_mspro_buf->mspro.regs.Data_Count_Reg1;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -598,7 +607,7 @@
 		ms_mspro_buf->mspro.reg_set.write_addr = 0x17;
 		ms_mspro_buf->mspro.reg_set.write_size = 0x01;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	
@@ -606,7 +615,7 @@
 		packet.param.out.count = 1;             //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		ms_mspro_buf->mspro.regs.parameters.data.TPC_Pamameter_Reg = MSPRO_REPORT_TYPE;
 		packet.param.out.buffer = &ms_mspro_buf->mspro.regs.parameters.data.TPC_Pamameter_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -617,13 +626,13 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MSPRO_ERASE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
 	while(1)
 	{
-		error = ms_mspro_wait_int(&packet);
+		error = ms_mspro_wait_int(ms_mspro_info, &packet);
 		if(error)
 			return error;
 			
@@ -637,7 +646,7 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 			packet.param.in.count = 1;
 			packet.param.in.buffer = &ms_mspro_buf->mspro.regs.INT_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -660,7 +669,7 @@
 		packet.TPC_cmd.value = TPC_MSPRO_READ_SHORT_DATA;   //READ_SHORT_DATA
 		packet.param.in.count = MSPRO_REPORT_SIZE;      //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = report_buf;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -674,16 +683,17 @@
 		return MS_MSPRO_NO_ERROR;
 }
 
-int mspro_read_attribute_sector(unsigned long sector_addr, unsigned short sector_count, unsigned char * data_buf)
+int mspro_read_attribute_sector(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long sector_addr, unsigned short sector_count, unsigned char * data_buf)
 {
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
 	{
 		int error,tracer;
 		read_sector_type=1;
-		error = mspro_read_user_sector(sector_addr, sector_count, data_buf);
+		error = mspro_read_user_sector(ms_mspro_info, sector_addr, sector_count, data_buf);
 		tracer=0;
 		while (1)
 		{
@@ -698,7 +708,7 @@
 			sector_addr += mass_counter;
 			sector_count -= mass_counter;
 			data_buf += MSPRO_SECTOR_SIZE*mass_counter;
-			error = mspro_read_user_sector(sector_addr, sector_count, data_buf);
+			error = mspro_read_user_sector(ms_mspro_info, sector_addr, sector_count, data_buf);
 		}	
 		read_sector_type=0;
 		return error;
@@ -714,7 +724,7 @@
 	
 	int error;
 	
-	unsigned char buf[8] = {0,0,0,0,0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 		
 	if(sector_count == 0)
 		return MS_MSPRO_ERROR_PARAMETER;
@@ -727,7 +737,7 @@
 		ms_mspro_buf->mspro.reg_set.write_addr = 0x11;
 		ms_mspro_buf->mspro.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->mspro.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -742,13 +752,13 @@
 	packet.param.out.buffer[4] = 0;
 	packet.param.out.buffer[5] = 0;
 	packet.param.out.buffer[6] = sector_addr;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
 	while(1)
 	{
-		error = ms_mspro_wait_int(&packet);
+		error = ms_mspro_wait_int(ms_mspro_info, &packet);
 		if(error)
 			return error;
 			
@@ -762,7 +772,7 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 			packet.param.in.count = 1;
 			packet.param.in.buffer = &ms_mspro_buf->mspro.regs.INT_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -785,7 +795,7 @@
 		packet.TPC_cmd.value = TPC_MSPRO_READ_LONG_DATA;    //READ_LONG_DATA
 		packet.param.in.count = MSPRO_SECTOR_SIZE;      //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = data_buf+data_offset;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -796,7 +806,7 @@
 	
 	}
 #endif
-
+	return 0;
 }
 
 int mspro_read_information_block()
diff -Nur drivers/amlogic/cardreader/ms/mspro_protocol.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/mspro_protocol.h
--- drivers/amlogic/cardreader/ms/mspro_protocol.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/mspro_protocol.h	2011-07-14 00:17:51.976739983 +0800
@@ -290,25 +290,5 @@
     
 //#define MSPRO_STARTUP_TIMEOUT                         (1000*TIMER_1MS)
 #define MSPRO_STARTUP_TIMEOUT                           300
-int mspro_media_type_identification(void);
-int mspro_cpu_startup(void);
-int mspro_confirm_attribute_information(unsigned char *data_buf);
-int mspro_confirm_system_information(unsigned char *data_buf);
-int mspro_recognize_file_system(void);
-int mspro_read_user_sector(unsigned long sector_addr,
-			     unsigned short sector_count,
-			     unsigned char *data_buf);
-int mspro_write_user_sector(unsigned long sector_addr,
-			     unsigned short sector_count,
-			     unsigned char *data_buf);
-int mspro_erase_user_sector(unsigned long sector_addr,
-			     unsigned short sector_count);
-int mspro_read_attribute_sector(unsigned long sector_addr,
-				 unsigned short sector_count,
-				 unsigned char *data_buf);
-int mspro_read_information_block(void);
-int mspro_update_imformation_block(void);
-int mspro_format(void);
-int mspro_sleep(void);
 
 #endif				//_H_MSPRO_PROTOCOL
diff -Nur drivers/amlogic/cardreader/ms/ms_protocol.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_protocol.c
--- drivers/amlogic/cardreader/ms/ms_protocol.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_protocol.c	2011-07-14 00:17:51.976739983 +0800
@@ -5,8 +5,10 @@
 
 extern unsigned check_one_boot_block;
 
-int ms_media_type_identification()
+int ms_media_type_identification(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
+	
 	if((ms_mspro_buf->ms.regs.Type_Reg >= 0x01) && (ms_mspro_buf->ms.regs.Type_Reg <= 0xFE))
 		return MS_MSPRO_ERROR_MEDIA_TYPE;
 		
@@ -51,18 +53,19 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_search_boot_block(unsigned char * data_buf)
+int ms_search_boot_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char * data_buf)
 {
 	int i;
 	
 	int error;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	ms_mspro_buf->ms.boot_area_protection_process_flag = 0;
 	ms_mspro_buf->ms.boot_block_nums = 0;
 	
 	for(i=0; i<=12; i++)
 	{
-		error = ms_read_page(i, 0, data_buf);
+		error = ms_read_page(ms_mspro_info, i, 0, data_buf);
 		if(error)
 			continue;
 			
@@ -109,12 +112,13 @@
 		return MS_MSPRO_NO_ERROR;
 }
 
-int ms_check_boot_block(unsigned char * data_buf)
+int ms_check_boot_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char * data_buf)
 {
 	int error;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	// Acquire Boot & Attribute Information form effective Boot Block
-	error = ms_read_page(ms_mspro_buf->ms.boot_block_no[0], 0, data_buf);
+	error = ms_read_page(ms_mspro_info, ms_mspro_buf->ms.boot_block_no[0], 0, data_buf);
 	if(error)
 		return error;
 		
@@ -324,14 +328,15 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_check_disabled_block(unsigned char * data_buf)
+int ms_check_disabled_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char * data_buf)
 {
 	int error;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	unsigned short block_no,i;
 	
 	// Acquire Boot & Attribute Information form effective Boot Block
-	error = ms_read_page(ms_mspro_buf->ms.boot_block_no[0], 1, data_buf);
+	error = ms_read_page(ms_mspro_info, ms_mspro_buf->ms.boot_block_no[0], 1, data_buf);
 	if(error)
 		return MS_ERROR_DISABLED_BLOCK;
 	
@@ -352,9 +357,10 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_boot_area_protection(unsigned char * data_buf)
+int ms_boot_area_protection(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned char * data_buf)
 {
 	int error,i,j,k;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	unsigned char last_block_no = 0;
 	unsigned long pages_per_block = ms_mspro_buf->ms.boot_attribute_information.Block_Size*2;
@@ -379,7 +385,7 @@
 				continue;
 		}
 		
-		error = ms_read_page(i, 0, data_buf);
+		error = ms_read_page(ms_mspro_info, i, 0, data_buf);
 		if(error)
 			continue;
 			
@@ -391,7 +397,7 @@
 			// copy the contents of this block to User Area (alternative block)
 			for(j=(last_block_no+1); j<(MS_BLOCKS_PER_SEGMENT-2); j++)
 			{
-				error = ms_read_page(j, 0, data_buf);
+				error = ms_read_page(ms_mspro_info, j, 0, data_buf);
 				if(error)
 					continue;
 					
@@ -399,7 +405,7 @@
 				{
 					for(k=0; k<pages_per_block; k++)
 					{
-						error = ms_copy_page(i, k, j, k, data_buf);
+						error = ms_copy_page(ms_mspro_info, i, k, j, k, data_buf);
 						if(error)
 							break;
 					}
@@ -411,7 +417,7 @@
 			}
 		}
 		
-		ms_overwrite_extra_data(i, 0, 0x7F);
+		ms_overwrite_extra_data(ms_mspro_info, i, 0, 0x7F);
 	}
 	
 	return MS_MSPRO_NO_ERROR;
@@ -437,10 +443,11 @@
 #endif
 
 static unsigned short logical_physical_table[MS_LOGICAL_SIZE_PER_SEGMENT], free_table[MS_BLOCKS_PER_SEGMENT];
-int ms_logical_physical_table_creation(unsigned short seg_no)
+int ms_logical_physical_table_creation(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned short seg_no)
 {
 	int error;
 	unsigned char US;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	//unsigned short logical_physical_table[MS_LOGICAL_SIZE_PER_SEGMENT], free_table[MS_BLOCKS_PER_SEGMENT];
 	unsigned long physical_blk_no,last_seg_no;
@@ -487,18 +494,18 @@
 		if(i != ms_mspro_buf->ms.disabled_block_data.disabled_block_nums)
 			continue;
 			
-		error = ms_read_extra_data(physical_blk_no, 0);
+		error = ms_read_extra_data(ms_mspro_info, physical_blk_no, 0);
 		if(error)
 		{
 			if(error == MS_MSPRO_ERROR_FLASH_READ)
-				ms_overwrite_extra_data(physical_blk_no, 0, ms_mspro_buf->ms.regs.Overwrite_Flag_Reg&0x7F);
+				ms_overwrite_extra_data(ms_mspro_info, physical_blk_no, 0, ms_mspro_buf->ms.regs.Overwrite_Flag_Reg&0x7F);
 			continue;
 		}
 				
 		if((seg_no == last_seg_no) &&
 		  !((MS_Management_Flag_Register_t*)(&ms_mspro_buf->ms.regs.Management_Flag_Reg))->ATFLG)
 		{
-			ms_erase_block(physical_blk_no);
+			ms_erase_block(ms_mspro_info, physical_blk_no);
 		}
 		
 		if(((MS_Overwrite_Flag_Register_t*)(&ms_mspro_buf->ms.regs.Overwrite_Flag_Reg))->BKST)
@@ -506,14 +513,14 @@
 			unsigned char PS = ((MS_Overwrite_Flag_Register_t*)(&ms_mspro_buf->ms.regs.Overwrite_Flag_Reg))->PGST1<<1 | ((MS_Overwrite_Flag_Register_t*)(&ms_mspro_buf->ms.regs.Overwrite_Flag_Reg))->PGST0;
 			if((PS != 0) && (PS != 3))
 			{
-				ms_overwrite_extra_data(physical_blk_no, 0, ms_mspro_buf->ms.regs.Overwrite_Flag_Reg&0x7F);
+				ms_overwrite_extra_data(ms_mspro_info, physical_blk_no, 0, ms_mspro_buf->ms.regs.Overwrite_Flag_Reg&0x7F);
 				continue;
 			}
 			
 			logical_address = ms_mspro_buf->ms.regs.Logical_Address_Reg1<<8 | ms_mspro_buf->ms.regs.Logical_Address_Reg0;
 			if((logical_address == 0xFFFF) || (logical_address < start_logical_addr) || (logical_address > end_logical_addr))
 			{
-				ms_erase_block(physical_blk_no);
+				ms_erase_block(ms_mspro_info, physical_blk_no);
 				free_table[free_table_data_nums++] = physical_blk_no;
 				continue;
 			}
@@ -525,7 +532,7 @@
 			}
 			
 			US = ((MS_Overwrite_Flag_Register_t*)(&ms_mspro_buf->ms.regs.Overwrite_Flag_Reg))->UDST;
-			error = ms_read_extra_data(physical_blk_no, 0);
+			error = ms_read_extra_data(ms_mspro_info, physical_blk_no, 0);
 			if(error)
 			{
 				continue;
@@ -534,12 +541,12 @@
 			{
 				if(physical_blk_no < logical_physical_table[logical_address-start_logical_addr])
 				{
-					ms_erase_block(physical_blk_no);
+					ms_erase_block(ms_mspro_info, physical_blk_no);
 					free_table[free_table_data_nums++] = physical_blk_no;
 				}
 				else
 				{
-					ms_erase_block(logical_physical_table[logical_address-start_logical_addr]);
+					ms_erase_block(ms_mspro_info, logical_physical_table[logical_address-start_logical_addr]);
 					free_table[free_table_data_nums++] = logical_physical_table[logical_address-start_logical_addr];
 					logical_physical_table[logical_address-start_logical_addr] = physical_blk_no;
 				}
@@ -548,13 +555,13 @@
 			{
 				if(US == 0)
 				{
-					ms_erase_block(logical_physical_table[logical_address-start_logical_addr]);
+					ms_erase_block(ms_mspro_info, logical_physical_table[logical_address-start_logical_addr]);
 					free_table[free_table_data_nums++] = logical_physical_table[logical_address-start_logical_addr];
 					logical_physical_table[logical_address-start_logical_addr] = physical_blk_no;
 				}
 				else
 				{
-					ms_erase_block(physical_blk_no);
+					ms_erase_block(ms_mspro_info, physical_blk_no);
 					free_table[free_table_data_nums++] = physical_blk_no;
 				}
 			}
@@ -570,7 +577,7 @@
 	  
 		if(logical_physical_table[logical_address-start_logical_addr] == 0xFFFF)
 		{
-			error = ms_read_extra_data(free_table[free_table_data_nums-1], 0);
+			error = ms_read_extra_data(ms_mspro_info, free_table[free_table_data_nums-1], 0);
 			if(error)
 			{
 				free_table_data_nums--;
@@ -579,7 +586,7 @@
 			{
 				ms_mspro_buf->ms.regs.Logical_Address_Reg1 = (logical_address >> 8) & 0xFF;
 				ms_mspro_buf->ms.regs.Logical_Address_Reg0 = logical_address & 0xFF;
-				error = ms_write_extra_data(free_table[free_table_data_nums-1], 0);
+				error = ms_write_extra_data(ms_mspro_info, free_table[free_table_data_nums-1], 0);
 					
 				logical_physical_table[logical_address-start_logical_addr] = free_table[free_table_data_nums-1];
 				free_table[free_table_data_nums-1] = 0xFFFF;
@@ -612,15 +619,16 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_read_page(unsigned long block_addr, unsigned char page_addr, unsigned char * data_buf)
+int ms_read_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
 	MS_Status_Register1_t * pStatusReg1;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
@@ -637,7 +645,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -658,7 +666,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -673,7 +681,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x20;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -681,11 +689,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_READ;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -699,7 +707,7 @@
 		packet.param.in.count = 0x19;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 #endif
 	packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -713,14 +721,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 		ms_mspro_buf->ms.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 		packet.param.in.count = 0x19-0x10;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.Block_Address_Reg2;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -748,7 +756,7 @@
 	packet.TPC_cmd.value = TPC_MS_READ_PAGE_DATA;       //READ_PAGE_DATA
 	packet.param.in.count = MS_PAGE_SIZE;           //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 	packet.param.in.buffer = data_buf;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -757,13 +765,14 @@
 
 #ifdef MS_WRITE_PATTERN_1
 //pattern 1
-int ms_write_page(unsigned long block_addr, unsigned char page_addr, unsigned char * data_buf)
+int ms_write_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
@@ -776,7 +785,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -793,7 +802,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x0A;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -815,7 +824,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x20;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -827,14 +836,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10+0x06;
 		ms_mspro_buf->ms.reg_set.write_size = 0x0A-0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_WRITE_REG;      //WRITE_REG
 		packet.param.out.count = 0x0A-0x06;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -844,11 +853,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_WRITE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -862,7 +871,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -878,11 +887,11 @@
 	packet.TPC_cmd.value = TPC_MS_WRITE_PAGE_DATA;      //WRITE_PAGE_DATA
 	packet.param.out.count = MS_PAGE_SIZE;          //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 	packet.param.out.buffer = data_buf;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -896,7 +905,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -911,10 +920,11 @@
 
 #ifdef MS_WRITE_PATTERN_2
 //pattern 2
-int ms_write_page(unsigned long block_addr, unsigned char page_addr, unsigned char * data_buf)
+int ms_write_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
@@ -931,7 +941,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}	
@@ -948,7 +958,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x0A;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -970,7 +980,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x20;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -982,14 +992,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10+0x06;
 		ms_mspro_buf->ms.reg_set.write_size = 0x0A-0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_WRITE_REG;      //WRITE_REG
 		packet.param.out.count = 0x0A-0x06;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -998,7 +1008,7 @@
 	packet.TPC_cmd.value = TPC_MS_WRITE_PAGE_DATA;      //WRITE_PAGE_DATA
 	packet.param.out.count = MS_PAGE_SIZE;          //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 	packet.param.out.buffer = data_buf;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1006,11 +1016,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_WRITE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -1024,7 +1034,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1040,15 +1050,16 @@
 }
 #endif //MS_WRITE_PATTERN_2
 
-int ms_copy_page(unsigned long source_block_addr, unsigned char source_page_addr, unsigned long dest_block_addr, unsigned char dest_page_addr, unsigned char * data_buf)
+int ms_copy_page(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long source_block_addr, unsigned char source_page_addr, unsigned long dest_block_addr, unsigned char dest_page_addr, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
 	MS_Status_Register1_t * pStatusReg1;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
@@ -1065,7 +1076,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1086,7 +1097,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1102,7 +1113,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x20;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = source_page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1110,11 +1121,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_READ;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 	
@@ -1128,7 +1139,7 @@
 		packet.param.in.count = 0x19;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 #endif
 	packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1142,14 +1153,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 		ms_mspro_buf->ms.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 		return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 		packet.param.in.count = 0x19-0x10;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.Block_Address_Reg2;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1174,7 +1185,7 @@
 		packet.TPC_cmd.value = TPC_MS_READ_PAGE_DATA;       //READ_PAGE_DATA
 		packet.param.in.count = MS_PAGE_SIZE;           //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = data_buf;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
@@ -1185,7 +1196,7 @@
 		packet.TPC_cmd.value = TPC_MS_WRITE_PAGE_DATA;      //WRITE_PAGE_DATA
 		packet.param.out.count = MS_PAGE_SIZE;          //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = data_buf;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1202,7 +1213,7 @@
 		ms_mspro_buf->ms.reg_set.write_size = 0x0A;
 #endif
 	packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1222,7 +1233,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x20;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = dest_page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1234,14 +1245,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10+0x06;
 		ms_mspro_buf->ms.reg_set.write_size = 0x0A-0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_WRITE_REG;      //WRITE_REG
 		packet.param.out.count = 0x0A-0x06;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1251,11 +1262,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_WRITE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -1269,7 +1280,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1284,16 +1295,17 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_read_block(unsigned long block_addr, unsigned char page_addr, unsigned short page_nums, unsigned char * data_buf)
+int ms_read_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr, unsigned short page_nums, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	unsigned long data_offset = 0;
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 		
 	if(page_nums == 0)
 		return MS_MSPRO_ERROR_PARAMETER;
@@ -1310,7 +1322,7 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 		ms_mspro_buf->ms.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1324,7 +1336,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x00;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1332,13 +1344,13 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_READ;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
 	while(1)
 	{
-		error = ms_mspro_wait_int(&packet);
+		error = ms_mspro_wait_int(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
@@ -1352,7 +1364,7 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 			packet.param.in.count = 1;
 			packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1381,14 +1393,14 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 			packet.param.in.count = 0x08;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 			packet.param.in.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 
 			packet.TPC_cmd.value = TPC_MS_READ_PAGE_DATA;       //READ_PAGE_DATA
 			packet.param.in.count = MS_PAGE_SIZE;           //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 			packet.param.in.buffer = data_buf+data_offset;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 
@@ -1404,7 +1416,7 @@
 			packet.param.out.count = 1;
 			packet.param.out.buffer = buf;
 			packet.param.out.buffer[0] = CMD_MS_BLOCK_END;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1415,14 +1427,14 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 		packet.param.in.count = 0x08;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 
 		packet.TPC_cmd.value = TPC_MS_READ_PAGE_DATA;       //READ_PAGE_DATA
 		packet.param.in.count = MS_PAGE_SIZE;           //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = data_buf+data_offset;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1430,16 +1442,17 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_write_block(unsigned long block_addr, unsigned char page_addr, unsigned short page_nums, unsigned char * data_buf)
+int ms_write_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr, unsigned short page_nums, unsigned char * data_buf)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	unsigned long data_offset = 0;
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 		
 	if(page_nums == 0)
 		return MS_MSPRO_ERROR_PARAMETER;
@@ -1455,7 +1468,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1472,7 +1485,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x0A;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1495,7 +1508,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x00;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1507,14 +1520,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10+0x06;
 		ms_mspro_buf->ms.reg_set.write_size = 0x0A-0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_WRITE_REG;      //WRITE_REG
 		packet.param.out.count = 0x0A-0x06;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1524,13 +1537,13 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_WRITE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
 	while(1)
 	{
-		error = ms_mspro_wait_int(&packet);
+		error = ms_mspro_wait_int(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
@@ -1544,7 +1557,7 @@
 			packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 			packet.param.in.count = 1;
 			packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1565,7 +1578,7 @@
 			packet.TPC_cmd.value = TPC_MS_WRITE_PAGE_DATA;      //WRITE_PAGE_DATA
 			packet.param.out.count = MS_PAGE_SIZE;          //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 			packet.param.out.buffer = data_buf+data_offset;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 
@@ -1577,7 +1590,7 @@
 			packet.param.out.count = 1;
 			packet.param.out.buffer = buf;
 			packet.param.out.buffer[0] = CMD_MS_BLOCK_END;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1586,14 +1599,15 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_erase_block(unsigned long block_addr)
+int ms_erase_block(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 		
 	if((ms_mspro_buf->ms.reg_set.write_addr != 0x10) ||
 	   (ms_mspro_buf->ms.reg_set.write_size != 0x04))
@@ -1603,7 +1617,7 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 		ms_mspro_buf->ms.reg_set.write_size = 0x04;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1615,7 +1629,7 @@
 	ms_mspro_buf->ms.regs.Block_Address_Reg1 = (block_addr >> 8) & 0xFF;
 	ms_mspro_buf->ms.regs.Block_Address_Reg0 = block_addr & 0xFF;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1623,11 +1637,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_ERASE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -1641,7 +1655,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1658,15 +1672,16 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_read_extra_data(unsigned long block_addr, unsigned char page_addr)
+int ms_read_extra_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
 	MS_Status_Register1_t * pStatusReg1;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
@@ -1683,7 +1698,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1704,7 +1719,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1720,7 +1735,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x40;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1728,11 +1743,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_READ;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 	
@@ -1746,7 +1761,7 @@
 		packet.param.in.count = 0x19;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 #endif
 	packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1760,14 +1775,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 		ms_mspro_buf->ms.reg_set.write_size = 0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_READ_REG;       //READ_REG
 		packet.param.in.count = 0x19-0x10;               //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.Block_Address_Reg2;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1792,14 +1807,15 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_write_extra_data(unsigned long block_addr, unsigned char page_addr)
+int ms_write_extra_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
@@ -1812,7 +1828,7 @@
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1829,7 +1845,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x0A;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1852,7 +1868,7 @@
 	ms_mspro_buf->ms.regs.CMD_Parameter_Reg = 0x40;
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1864,14 +1880,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10+0x06;
 		ms_mspro_buf->ms.reg_set.write_size = 0x0A-0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_WRITE_REG;      //WRITE_REG
 		packet.param.out.count = 0x0A-0x06;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1881,11 +1897,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_WRITE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -1899,7 +1915,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -1916,14 +1932,15 @@
 	return MS_MSPRO_NO_ERROR;
 }
 
-int ms_overwrite_extra_data(unsigned long block_addr, unsigned char page_addr, unsigned char mask_data)
+int ms_overwrite_extra_data(MS_MSPRO_Card_Info_t *ms_mspro_info, unsigned long block_addr, unsigned char page_addr, unsigned char mask_data)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	MS_MSPRO_INT_Register_t * pIntReg;
+	MS_MSPRO_Card_Buffer_t *ms_mspro_buf = (MS_MSPRO_Card_Buffer_t *)(ms_mspro_info->ms_mspro_buf);
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 
 #ifdef MS_MSPRO_HW_CONTROL
 	if(MS_WORK_MODE == CARD_HW_MODE)
@@ -1937,7 +1954,7 @@
 			ms_mspro_buf->ms.reg_set.write_size = 0x06;
 
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1954,7 +1971,7 @@
 			ms_mspro_buf->ms.reg_set.write_addr = 0x10;
 			ms_mspro_buf->ms.reg_set.write_size = 0x07;
 			packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-			error = ms_mspro_packet_communicate(&packet);
+			error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 			if(error)
 				return error;
 		}
@@ -1978,7 +1995,7 @@
 	ms_mspro_buf->ms.regs.Page_Address_Reg = page_addr;
 	ms_mspro_buf->ms.regs.Overwrite_Flag_Reg = mask_data;
 	packet.param.out.buffer = &ms_mspro_buf->ms.regs.System_Parameter_Reg;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
@@ -1990,14 +2007,14 @@
 		ms_mspro_buf->ms.reg_set.write_addr = 0x10+0x06;
 		ms_mspro_buf->ms.reg_set.write_size = 0x07-0x06;
 		packet.param.out.buffer = (unsigned char *)&ms_mspro_buf->ms.reg_set;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 		
 		packet.TPC_cmd.value = TPC_MS_MSPRO_WRITE_REG;      //WRITE_REG
 		packet.param.out.count = 0x07-0x06;              //READ_ADRS,READ_SIZE,WRITE_ADRS,WRITE_SIZE
 		packet.param.out.buffer = &ms_mspro_buf->ms.regs.Overwrite_Flag_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -2007,11 +2024,11 @@
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_BLOCK_WRITE;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 
-	error = ms_mspro_wait_int(&packet);
+	error = ms_mspro_wait_int(ms_mspro_info, &packet);
 	if(error)
 		return error;
 		
@@ -2025,7 +2042,7 @@
 		packet.TPC_cmd.value = TPC_MS_MSPRO_GET_INT;        //SET_CMD
 		packet.param.in.count = 1;
 		packet.param.in.buffer = &ms_mspro_buf->ms.regs.INT_Reg;
-		error = ms_mspro_packet_communicate(&packet);
+		error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 		if(error)
 			return error;
 	}
@@ -2057,19 +2074,19 @@
 	return 0;
 }
 
-int ms_reset(void)
+int ms_reset(MS_MSPRO_Card_Info_t *ms_mspro_info)
 {
 	MS_MSPRO_TPC_Packet_t packet;
 	
 	int error;
 	
-	unsigned char buf[4] = {0,0,0,0};
+	unsigned char* buf = ms_mspro_info->data_buf;
 	
 	packet.TPC_cmd.value = TPC_MS_MSPRO_SET_CMD;        //SET_CMD
 	packet.param.out.count = 1;
 	packet.param.out.buffer = buf;
 	packet.param.out.buffer[0] = CMD_MS_RESET;
-	error = ms_mspro_packet_communicate(&packet);
+	error = ms_mspro_packet_communicate(ms_mspro_info, &packet);
 	if(error)
 		return error;
 	return 0;
diff -Nur drivers/amlogic/cardreader/ms/ms_protocol.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_protocol.h
--- drivers/amlogic/cardreader/ms/ms_protocol.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/ms/ms_protocol.h	2011-07-14 00:17:51.976739983 +0800
@@ -249,33 +249,6 @@
     
 //#define MS_WRITE_PATTERN_1
 #define MS_WRITE_PATTERN_2
-int ms_media_type_identification(void);
-int ms_search_boot_block(unsigned char *data_buf);
-int ms_check_boot_block(unsigned char *data_buf);
-int ms_check_disabled_block(unsigned char *data_buf);
-int ms_boot_area_protection(unsigned char *data_buf);
-int ms_logical_physical_table_creation(unsigned short seg_no);
 
-//int ms_read_boot_idi(unsigned char * data_buf);
-int ms_read_page(unsigned long block_addr, unsigned char page_addr,
-		  unsigned char *data_buf);
-int ms_write_page(unsigned long block_addr, unsigned char page_addr,
-		   unsigned char *data_buf);
-int ms_copy_page(unsigned long source_block_addr,
-		  unsigned char source_page_addr, unsigned long dest_block_addr,
-		  unsigned char dest_page_addr, unsigned char *data_buf);
-int ms_read_block(unsigned long block_addr, unsigned char page_addr,
-		   unsigned short page_nums, unsigned char *data_buf);
-int ms_write_block(unsigned long block_addr, unsigned char page_addr,
-		    unsigned short page_nums, unsigned char *data_buf);
-int ms_erase_block(unsigned long block_addr);
-int ms_read_extra_data(unsigned long block_addr, unsigned char page_addr);
-int ms_write_extra_data(unsigned long block_addr, unsigned char page_addr);
-int ms_overwrite_extra_data(unsigned long block_addr, unsigned char page_addr,
-			     unsigned char mask_data);
-int ms_sleep(void);
-int ms_clear_buffer(void);
-int ms_flash_stop(void);
-int ms_reset(void);
 
 #endif				//_H_MS_PROTOCOL
diff -Nur drivers/amlogic/cardreader/sd/sd.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd.c
--- drivers/amlogic/cardreader/sd/sd.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd.c	2011-07-14 00:17:51.976739983 +0800
@@ -6,223 +6,553 @@
 **        Revision : 1.0                                        **
 **                                                              **
 *****************************************************************/
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/pagemap.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <mach/am_regs.h>
 #include <mach/irqs.h>
 #include <mach/card_io.h>
+#include <mach/power_gate.h>
+#include <linux/cardreader/card_block.h>
+#include <linux/cardreader/cardreader.h>
+#include <linux/cardreader/sdio.h>
 
+#include "sd_misc.h"
 #include "sd_protocol.h"
 
-unsigned char sd_insert_detector(void)
+static unsigned sd_backup_input_val = 0;
+static unsigned sd_backup_output_val = 0;
+static unsigned SD_BAKUP_INPUT_REG = (unsigned)&sd_backup_input_val;
+static unsigned SD_BAKUP_OUTPUT_REG = (unsigned)&sd_backup_output_val;
+
+unsigned SD_CMD_OUTPUT_EN_REG;
+unsigned SD_CMD_OUTPUT_EN_MASK;
+unsigned SD_CMD_INPUT_REG;
+unsigned SD_CMD_INPUT_MASK;
+unsigned SD_CMD_OUTPUT_REG;
+unsigned SD_CMD_OUTPUT_MASK;
+
+unsigned SD_CLK_OUTPUT_EN_REG;
+unsigned SD_CLK_OUTPUT_EN_MASK;
+unsigned SD_CLK_OUTPUT_REG;
+unsigned SD_CLK_OUTPUT_MASK;
+
+unsigned SD_DAT_OUTPUT_EN_REG;
+unsigned SD_DAT0_OUTPUT_EN_MASK;
+unsigned SD_DAT0_3_OUTPUT_EN_MASK;
+unsigned SD_DAT_INPUT_REG;
+unsigned SD_DAT_OUTPUT_REG;
+unsigned SD_DAT0_INPUT_MASK;
+unsigned SD_DAT0_OUTPUT_MASK;
+unsigned SD_DAT0_3_INPUT_MASK;
+unsigned SD_DAT0_3_OUTPUT_MASK;
+unsigned SD_DAT_INPUT_OFFSET;
+unsigned SD_DAT_OUTPUT_OFFSET;
+
+unsigned SD_INS_OUTPUT_EN_REG;
+unsigned SD_INS_OUTPUT_EN_MASK;
+unsigned SD_INS_INPUT_REG;
+unsigned SD_INS_INPUT_MASK;
+
+unsigned SD_WP_OUTPUT_EN_REG;
+unsigned SD_WP_OUTPUT_EN_MASK;
+unsigned SD_WP_INPUT_REG;
+unsigned SD_WP_INPUT_MASK;
+
+unsigned SD_PWR_OUTPUT_EN_REG;
+unsigned SD_PWR_OUTPUT_EN_MASK;
+unsigned SD_PWR_OUTPUT_REG;
+unsigned SD_PWR_OUTPUT_MASK;
+unsigned SD_PWR_EN_LEVEL;
+
+unsigned SD_WORK_MODE;
+
+struct memory_card *card_find_card(struct card_host *host, u8 card_type); 
+
+void sd_insert_detector(struct memory_card *card)
 {
-	int ret = sd_mmc_check_insert();
+	SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)card->card_info;
+
+	int ret = sd_mmc_check_insert(sd_mmc_info);
 	if(ret)
-        return CARD_INSERTED;
+        card->card_status = CARD_INSERTED;
     else
-        return CARD_REMOVED;
+        card->card_status = CARD_REMOVED;
+
+	return;
 }
 
-unsigned char sd_open(void)
+void sd_open(struct memory_card *card)
 {
 	int ret;
-	
-	ret = sd_mmc_init();
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+	SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)card->card_info;
+
+	if (aml_card_info->card_extern_init)
+		aml_card_info->card_extern_init();
+	ret = sd_mmc_init(sd_mmc_info);
+
+	card->capacity = sd_mmc_info->blk_nums;
+	card->sdio_funcs  = sd_mmc_info->sdio_function_nums;
+	memcpy(card->raw_cid, &(sd_mmc_info->raw_cid), sizeof(card->raw_cid));
+
 	if(ret)
-		return CARD_UNIT_READY;
+		card->unit_state = CARD_UNIT_READY;
 	else
-		return CARD_UNIT_PROCESSED;
-	}
+		card->unit_state = CARD_UNIT_PROCESSED;
 
-unsigned char sd_close(void)
+	return;
+}
+
+void sd_close(struct memory_card *card)
 {
-	sd_mmc_exit();
-	return CARD_UNIT_PROCESSED;
+	SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)card->card_info;
+
+	if(!sd_mmc_info)
+	{
+		printk("error: no card to exit\n");
+		return;
+	}
+	sd_mmc_exit(sd_mmc_info);
+	sd_mmc_free(sd_mmc_info);
+	sd_mmc_info = NULL;
+	card->card_info = NULL;
+	card->unit_state =  CARD_UNIT_PROCESSED;
+
+	return;
 }
 
-/*unsigned char sd_read_info(unsigned *blk_length, unsigned *capacity, u32 *raw_cid)
+void sd_suspend(struct memory_card *card)
 {
-	if(sd_info.inited_flag) {
-		if(blk_length)
-			*blk_length = 512;
-		if(capacity)
-			*capacity = sd_info.blk_nums;
-		if(raw_cid)
-			memcpy(raw_cid, &(sd_info.raw_cid), sizeof(sd_info.raw_cid));
-		return 0;
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+	
+	SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)card->card_info;
+
+	printk("***Entered %s:%s\n", __FILE__,__func__);	
+	
+	CLK_GATE_OFF(SDIO);  
+	 
+	if(card->card_type == CARD_SDIO)
+	{
+		return;
 	}
-	else
-		return 1;
-}*/
+		        
+	memset(sd_mmc_info, 0, sizeof(SD_MMC_Card_Info_t));
+	if (card->host->dma_buf != NULL) {
+		sd_mmc_info->sd_mmc_buf = card->host->dma_buf;
+		sd_mmc_info->sd_mmc_phy_buf = card->host->dma_phy_buf;
+	}	
+	card->card_io_init(card);
+	sd_mmc_info->io_pad_type = aml_card_info->io_pad_type;
+	sd_mmc_info->bus_width = SD_BUS_SINGLE;
+	sd_mmc_info->sdio_clk_unit = 3000;
+	sd_mmc_info->clks_nac = SD_MMC_TIME_NAC_DEFAULT;
+	sd_mmc_info->max_blk_count = card->host->max_blk_count;
+	
+}
 
-/*int sd_ioctl(unsigned dev, int req, void *argp)
+void sd_resume(struct memory_card *card)
 {
-	unsigned32 ret=0;
-    int errno;
-    blkdev_request1 *req1 =(blkdev_request1 *) argp;  
-    blkdev_request *r =&(req1->req); 
-    blkdev_sg_buffer* psgbuf ;
-    void * databuf;
-    avfs_status_code status;
-    INT32U capacity = 0;
-
-    switch (req)
-    {
-        case BLKIO_REQUEST:
-        {
-            psgbuf=&(r->bufs[0]);
-            databuf=psgbuf->buffer;
-            switch (r->req)
-            {
-                case BLKDEV_REQ_READ:
-                case BLKDEV_REQ_READ_DEV:
-                	card_get_dev();
-                    ret = sd_mmc_read_data(r->start,r->count*512,(INT8U *)databuf);
-                    if(ret)
-                    {
-                    	disable_high_speed = 1;
-                    	sd_mmc_info->inited_flag = 0;
-                        ret = sd_mmc_init(&sd_info);
-                        if(!ret)
-                            ret = sd_mmc_read_data(r->start,r->count*512,(INT8U *)databuf);
-                    }
-                    card_put_dev();
-                    if(!ret)
-                        status=AVFS_SUCCESSFUL;
-                    else
-                        status=AVFS_IO_ERROR;                   
-                    if(r->req_done)
-                        r->req_done(r->done_arg, status, ret);       
-                    break;
-                case BLKDEV_REQ_WRITE:
-                case BLKDEV_REQ_WRITE_DEV:
-                	card_get_dev();
-                    ret = sd_mmc_write_data(r->start,r->count*512,(INT8U *)databuf);
-                    //if((ret) && (ret!=SD_MMC_ERROR_WRITE_PROTECTED) && (sd_mmc_check_insert()))
-                    //{
-                    //	sd_mmc_info->inited_flag = 0;
-                    //    ret = sd_mmc_init(&sd_info);
-                    //    if(!ret)
-                    //        ret = sd_mmc_write_data(r->start,r->count*512,(INT8U *)databuf);
-                    //}                  
-                    card_put_dev();
-                    if(!ret)
-                        status=AVFS_SUCCESSFUL;
-                    else
-                        status=AVFS_IO_ERROR;                       
-                    if(r->req_done)
-                        r->req_done(r->done_arg, status, ret);       
-                    break;
-                case BLKDEV_REQ_ASYREAD_DEV:
-                case BLKDEV_REQ_ASYREAD_MEM:
-                    break;
-                default:
-                    errno = EBADRQC;
-                    ret=-1;
-                    break;
-            }
-            break;
-        }
-        case BLKIO_GETSIZE:
-        {
-            sd_read_info(NULL, &capacity);
-            r->status = capacity;
-            break;
-        }
-        case BLKIO_GET_TYPE_STR:
-        {
-        	//if(sd_info.card_type == CARD_TYPE_SD)
-        		*(char **)argp = "SD";
-        	//else
-        	//	*(char **)argp = "MMC";
-        	break;
-    	}
-    	case BLKIO_GET_DEVSTAT:
-    	{
-    		blkdev_stat_t *info = (blkdev_stat_t *)argp;
-    		sd_mmc_get_info(info);
-    		break;
-    	}
-        default:
-        {
-            errno = EBADRQC;
-            ret=-1;
-            break;
-        }
-    }
-    return 0; 
-    }*/
-
-static irqreturn_t sdio_interrupt_monitor(int irq, void *dev_id, struct pt_regs *regs) 
-{
-	unsigned sdio_interrupt_resource = sdio_check_interrupt();
-	switch (sdio_interrupt_resource) {
-		case SDIO_IF_INT:
-		    //sdio_if_int_handle();
-		    break;
+	printk("***Entered %s:%s\n", __FILE__,__func__);
+	CLK_GATE_ON(SDIO);
+}
 
-		case SDIO_CMD_INT:
-			sdio_cmd_int_handle();
+void sd_io_init(struct memory_card *card)
+{
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+	SD_WORK_MODE = aml_card_info->work_mode;
+
+	switch (aml_card_info->io_pad_type) {
+
+		case SDIO_GPIOA_0_5:
+			SD_CMD_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_CMD_OUTPUT_EN_MASK = PREG_IO_9_MASK;
+			SD_CMD_INPUT_REG = EGPIO_GPIOA_INPUT;
+			SD_CMD_INPUT_MASK = PREG_IO_9_MASK;
+			SD_CMD_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_CMD_OUTPUT_MASK = PREG_IO_9_MASK;
+
+			SD_CLK_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_CLK_OUTPUT_EN_MASK = PREG_IO_8_MASK;
+			SD_CLK_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_CLK_OUTPUT_MASK = PREG_IO_8_MASK;
+
+			SD_DAT_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_DAT0_OUTPUT_EN_MASK = PREG_IO_4_MASK;
+			SD_DAT0_3_OUTPUT_EN_MASK = PREG_IO_4_7_MASK;
+			SD_DAT_INPUT_REG = EGPIO_GPIOA_INPUT;
+			SD_DAT_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_DAT0_INPUT_MASK = PREG_IO_4_MASK;
+			SD_DAT0_OUTPUT_MASK = PREG_IO_4_MASK;
+			SD_DAT0_3_INPUT_MASK = PREG_IO_4_7_MASK;
+			SD_DAT0_3_OUTPUT_MASK = PREG_IO_4_7_MASK;
+			SD_DAT_INPUT_OFFSET = 4;
+			SD_DAT_OUTPUT_OFFSET = 4;
 			break;
 
-		case SDIO_TIMEOUT_INT:
-			sdio_timeout_int_handle();
+		case SDIO_GPIOA_9_14:
+			SD_CMD_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_CMD_OUTPUT_EN_MASK = PREG_IO_18_MASK;
+			SD_CMD_INPUT_REG = EGPIO_GPIOA_INPUT;
+			SD_CMD_INPUT_MASK = PREG_IO_18_MASK;
+			SD_CMD_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_CMD_OUTPUT_MASK = PREG_IO_18_MASK;
+
+			SD_CLK_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_CLK_OUTPUT_EN_MASK = PREG_IO_17_MASK;
+			SD_CLK_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_CLK_OUTPUT_MASK = PREG_IO_17_MASK;
+
+			SD_DAT_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_DAT0_OUTPUT_EN_MASK = PREG_IO_13_MASK;
+			SD_DAT0_3_OUTPUT_EN_MASK = PREG_IO_13_16_MASK;
+			SD_DAT_INPUT_REG = EGPIO_GPIOA_INPUT;
+			SD_DAT_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_DAT0_INPUT_MASK = PREG_IO_13_MASK;
+			SD_DAT0_OUTPUT_MASK = PREG_IO_13_MASK;
+			SD_DAT0_3_INPUT_MASK = PREG_IO_13_16_MASK;
+			SD_DAT0_3_OUTPUT_MASK = PREG_IO_13_16_MASK;
+			SD_DAT_INPUT_OFFSET = 13;
+			SD_DAT_OUTPUT_OFFSET = 13;
 			break;
-	
-		case SDIO_SOFT_INT:
-		    //AVDetachIrq(sdio_int_handler);
-		    //sdio_int_handler = -1;
-		    break;
-	
-		case SDIO_NO_INT:	
+
+		case SDIO_GPIOB_2_7:
+			SD_CMD_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_CMD_OUTPUT_EN_MASK = PREG_IO_21_MASK;
+			SD_CMD_INPUT_REG = EGPIO_GPIOA_INPUT;
+			SD_CMD_INPUT_MASK = PREG_IO_21_MASK;
+			SD_CMD_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_CMD_OUTPUT_MASK = PREG_IO_21_MASK;
+
+			SD_CLK_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_CLK_OUTPUT_EN_MASK = PREG_IO_22_MASK;
+			SD_CLK_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_CLK_OUTPUT_MASK = PREG_IO_22_MASK;
+
+			SD_DAT_OUTPUT_EN_REG = EGPIO_GPIOA_ENABLE;
+			SD_DAT0_OUTPUT_EN_MASK = PREG_IO_23_MASK;
+			SD_DAT0_3_OUTPUT_EN_MASK = PREG_IO_23_26_MASK;
+			SD_DAT_INPUT_REG = EGPIO_GPIOA_INPUT;
+			SD_DAT_OUTPUT_REG = EGPIO_GPIOA_OUTPUT;
+			SD_DAT0_INPUT_MASK = PREG_IO_23_MASK;
+			SD_DAT0_OUTPUT_MASK = PREG_IO_23_MASK;
+			SD_DAT0_3_INPUT_MASK = PREG_IO_23_26_MASK;
+			SD_DAT0_3_OUTPUT_MASK = PREG_IO_23_26_MASK;
+			SD_DAT_INPUT_OFFSET = 23;
+			SD_DAT_OUTPUT_OFFSET = 23;
+			break;
+
+		case SDIO_GPIOE_6_11:
+			SD_CMD_OUTPUT_EN_REG = EGPIO_GPIOE_ENABLE;
+			SD_CMD_OUTPUT_EN_MASK = PREG_IO_7_MASK;
+			SD_CMD_INPUT_REG = EGPIO_GPIOE_INPUT;
+			SD_CMD_INPUT_MASK = PREG_IO_7_MASK;
+			SD_CMD_OUTPUT_REG = EGPIO_GPIOE_OUTPUT;
+			SD_CMD_OUTPUT_MASK = PREG_IO_7_MASK;
+
+			SD_CLK_OUTPUT_EN_REG = EGPIO_GPIOE_ENABLE;
+			SD_CLK_OUTPUT_EN_MASK = PREG_IO_6_MASK;
+			SD_CLK_OUTPUT_REG = EGPIO_GPIOE_OUTPUT;
+			SD_CLK_OUTPUT_MASK = PREG_IO_6_MASK;
+
+			SD_DAT_OUTPUT_EN_REG = EGPIO_GPIOE_ENABLE;
+			SD_DAT0_OUTPUT_EN_MASK = PREG_IO_8_MASK;
+			SD_DAT0_3_OUTPUT_EN_MASK = PREG_IO_8_11_MASK;
+			SD_DAT_INPUT_REG = EGPIO_GPIOE_INPUT;
+			SD_DAT_OUTPUT_REG = EGPIO_GPIOE_OUTPUT;
+			SD_DAT0_INPUT_MASK = PREG_IO_8_MASK;
+			SD_DAT0_OUTPUT_MASK = PREG_IO_8_MASK;
+			SD_DAT0_3_INPUT_MASK = PREG_IO_8_11_MASK;
+			SD_DAT0_3_OUTPUT_MASK = PREG_IO_8_11_MASK;
+			SD_DAT_INPUT_OFFSET = 8;
+			SD_DAT_OUTPUT_OFFSET = 8;
 			break;
 
-		default:	
-			break;	
+        default:
+			printk("Warning couldn`t find any valid hw io pad!!!\n");
+            break;
+	}
+
+	if (aml_card_info->card_ins_en_reg) {
+		SD_INS_OUTPUT_EN_REG = aml_card_info->card_ins_en_reg;
+		SD_INS_OUTPUT_EN_MASK = aml_card_info->card_ins_en_mask;
+		SD_INS_INPUT_REG = aml_card_info->card_ins_input_reg;
+		SD_INS_INPUT_MASK = aml_card_info->card_ins_input_mask;
+	}
+	else {
+		SD_INS_OUTPUT_EN_REG = SD_BAKUP_OUTPUT_REG;
+		SD_INS_OUTPUT_EN_MASK = 1;
+		SD_INS_INPUT_REG = SD_BAKUP_INPUT_REG;
+		SD_INS_INPUT_MASK =
+		SD_WP_INPUT_MASK = 1;
+	}
+
+	if (aml_card_info->card_power_en_reg) {
+		SD_PWR_OUTPUT_EN_REG = aml_card_info->card_power_en_reg;
+		SD_PWR_OUTPUT_EN_MASK = aml_card_info->card_power_en_mask;
+		SD_PWR_OUTPUT_REG = aml_card_info->card_power_output_reg;
+		SD_PWR_OUTPUT_MASK = aml_card_info->card_power_output_mask;
+		SD_PWR_EN_LEVEL = aml_card_info->card_power_en_lev;
+	}
+	else {
+		SD_PWR_OUTPUT_EN_REG = SD_BAKUP_OUTPUT_REG;
+		SD_PWR_OUTPUT_EN_MASK = 1;
+		SD_PWR_OUTPUT_REG = SD_BAKUP_OUTPUT_REG;
+		SD_PWR_OUTPUT_MASK = 1;
+		SD_PWR_EN_LEVEL = 0;	
 	}
 
-    return IRQ_HANDLED; 
+	if (aml_card_info->card_wp_en_reg) {
+		SD_WP_OUTPUT_EN_REG = aml_card_info->card_wp_en_reg;
+		SD_WP_OUTPUT_EN_MASK = aml_card_info->card_wp_en_mask;
+		SD_WP_INPUT_REG = aml_card_info->card_wp_input_reg;
+		SD_WP_INPUT_MASK = aml_card_info->card_wp_input_mask;
+	}
+	else {
+		SD_WP_OUTPUT_EN_REG = SD_BAKUP_OUTPUT_REG;
+		SD_WP_OUTPUT_EN_MASK = 1;
+		SD_WP_INPUT_REG = SD_BAKUP_INPUT_REG;
+		SD_WP_INPUT_MASK = 1;
+	}
 
+	return;
 }
 
-static int __init sd_init(void)
+static int sd_request(struct memory_card *card, struct card_blk_request *brq)
 {
-	cr_mon.card_detector[CARD_SECURE_DIGITAL] = sd_insert_detector;
-	cr_mon.card_insert_process[CARD_SECURE_DIGITAL] = sd_open;
-	cr_mon.card_remove_process[CARD_SECURE_DIGITAL] = sd_close;
-	cr_mon.card_read_data[CARD_SECURE_DIGITAL] = sd_mmc_read_data;
-	cr_mon.card_write_data[CARD_SECURE_DIGITAL] = sd_mmc_write_data;
-	strcpy(cr_mon.name[CARD_SECURE_DIGITAL], CARD_SD_NAME_STR);
+	SD_MMC_Card_Info_t *sd_mmc_info = (SD_MMC_Card_Info_t *)card->card_info;
+	unsigned int lba, byte_cnt;
+	unsigned char *data_buf;
+	struct card_host *host = card->host;
+	struct memory_card *sdio_card;
 	
-	if (request_irq(INT_SDIO, (irq_handler_t) sdio_interrupt_monitor, 0, "sd_mmc", (void *)(&cr_mon))) {
-		printk("request SDIO irq error!!!\n");
-		return -1;
+	lba = brq->card_data.lba;
+	byte_cnt = brq->card_data.blk_size * brq->card_data.blk_nums;
+	data_buf = brq->crq.buf;
+
+	if(sd_mmc_info == NULL){
+		brq->card_data.error = SD_MMC_ERROR_NO_CARD_INS;
+		printk("[sd_request] sd_mmc_info == NULL, return SD_MMC_ERROR_NO_CARD_INS\n");
+		return 0;
+	}
+
+	sdio_close_host_interrupt(SDIO_IF_INT);
+	sd_sdio_enable(sd_mmc_info->io_pad_type);
+	if(brq->crq.cmd == READ) {
+		brq->card_data.error = sd_mmc_read_data(sd_mmc_info, lba, byte_cnt, data_buf);
+	}
+	else if(brq->crq.cmd == WRITE) {
+		brq->card_data.error = sd_mmc_write_data(sd_mmc_info, lba, byte_cnt, data_buf);
+	}
+
+	sd_gpio_enable(sd_mmc_info->io_pad_type);
+
+	sdio_card = card_find_card(host, CARD_SDIO);
+	if(sdio_card)
+	{
+		sd_mmc_info = (SD_MMC_Card_Info_t *)sdio_card->card_info;
+		sd_sdio_enable(sd_mmc_info->io_pad_type);
+		sdio_open_host_interrupt(SDIO_IF_INT);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+	    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+	      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
+    		}
+	}
+	return 0;
+}
+
+static int sdio_request(struct memory_card *card, struct card_blk_request *brq)
+{
+	SD_MMC_Card_Info_t *sdio_info = (SD_MMC_Card_Info_t *)card->card_info;
+	int incr_addr, err;
+	unsigned addr, blocks, blksz, fn, read_after_write;
+	u8 *in, *out, *buf;
+
+	sd_sdio_enable(sdio_info->io_pad_type);
+	if (brq->crq.cmd & SDIO_OPS_REG) {
+
+		WARN_ON(brq->card_data.blk_size != 1);
+		WARN_ON(brq->card_data.blk_nums != 1);
+	
+		in = brq->crq.buf;
+		addr = brq->card_data.lba;
+		fn = brq->card_data.flags;
+		out = brq->crq.back_buf;
+
+		if (brq->crq.cmd & READ_AFTER_WRITE)
+			read_after_write = 1;
+		else
+			read_after_write = 0;
+
+		if ((brq->crq.cmd & 0x1 )== WRITE) {
+			err = sdio_write_reg(sdio_info, fn, addr, in, read_after_write);
+			if (err) {
+				printk("sdio card write_reg failed %d at addr: %x \n", err, addr);
+				brq->card_data.error = err;
+				goto err;
+			}
+		}
+		else {
+			err = sdio_read_reg(sdio_info, fn, addr, out);
+			if (err) {
+				printk("sdio card read_reg failed %d at addr: %x  \n", err, addr);
+				brq->card_data.error = err;
+				goto err;
+			}
+		}
+	}
+	else {
+
+		if (brq->crq.cmd & SDIO_FIFO_ADDR)
+			incr_addr = 1;
+		else
+			incr_addr = 0;
+
+		buf = brq->crq.buf;
+		addr = brq->card_data.lba;
+		blksz = brq->card_data.blk_size;
+		blocks = brq->card_data.blk_nums;
+		fn = brq->card_data.flags;
+		sdio_info->sdio_blk_len[fn] = card->sdio_func[fn-1]->cur_blksize;
+
+		if ((brq->crq.cmd & 0x1)== WRITE) {
+			err = sdio_write_data(sdio_info, fn, incr_addr, addr, blocks*blksz, buf);
+			if (err) {
+				printk("sdio card write_data failed %d at addr: %x, function: %d \n", err, addr, fn);
+				brq->card_data.error = err;
+				goto err;
+			}
+		}
+		else {
+			err = sdio_read_data(sdio_info, fn, incr_addr, addr, blocks*blksz, buf);
+			if (err) {
+				printk("sdio card read_data failed %d at addr: %x, function: %d\n", err, addr, fn);
+				brq->card_data.error = err;
+				goto err;
+			}
+		}
+	}
+
+	//sd_gpio_enable(sdio_info->io_pad_type);
+	brq->card_data.error = 0;
+	return 0;
+
+err:
+	//sd_gpio_enable(sdio_info->io_pad_type);
+	return err;
+}
+
+int sd_mmc_probe(struct memory_card *card)
+{
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+
+	SD_MMC_Card_Info_t *sd_mmc_info = sd_mmc_malloc(sizeof(SD_MMC_Card_Info_t), GFP_KERNEL);
+	if (sd_mmc_info == NULL)
+		return -ENOMEM;
+
+	if (card->host->dma_buf != NULL) {
+		sd_mmc_info->sd_mmc_buf = card->host->dma_buf;
+		sd_mmc_info->sd_mmc_phy_buf = card->host->dma_phy_buf;
 	}
 
-	//sd_io_init();
-	sd_mmc_prepare_init();
+	card->card_info = sd_mmc_info;
+	card->card_io_init = sd_io_init;
+	card->card_detector = sd_insert_detector;
+	card->card_insert_process = sd_open;
+	card->card_remove_process = sd_close;
+	card->card_request_process = sd_request;
+	card->card_suspend = sd_suspend;
+	card->card_resume = sd_resume;
+	if (aml_card_info->card_extern_init)
+		aml_card_info->card_extern_init();
+	card->card_io_init(card);
+	sd_mmc_prepare_init(sd_mmc_info);
+	sd_mmc_info->io_pad_type = aml_card_info->io_pad_type;
+	sd_mmc_info->bus_width = SD_BUS_SINGLE;
+	sd_mmc_info->sdio_clk_unit = 3000;
+	sd_mmc_info->clks_nac = SD_MMC_TIME_NAC_DEFAULT;
+	sd_mmc_info->max_blk_count = card->host->max_blk_count;
+
 	return 0;
 }
 
-static void __exit sd_exit(void)
+int sdio_probe(struct memory_card *card)
 {
-	cr_mon.card_detector[CARD_SECURE_DIGITAL] = NULL;
-	cr_mon.card_insert_process[CARD_SECURE_DIGITAL] = NULL;
-	cr_mon.card_remove_process[CARD_SECURE_DIGITAL] = NULL;
-	cr_mon.card_read_data[CARD_SECURE_DIGITAL] = NULL;
-	cr_mon.card_write_data[CARD_SECURE_DIGITAL] = NULL;
-	strcpy(cr_mon.name[CARD_SECURE_DIGITAL], CARD_UNKNOW_NAME_STR);
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+
+	SD_MMC_Card_Info_t *sdio_info = sd_mmc_malloc(sizeof(SD_MMC_Card_Info_t), GFP_KERNEL);
+	if (sdio_info == NULL)
+		return -ENOMEM;
+
+	if (card->host->dma_buf != NULL) {
+		sdio_info->sd_mmc_buf = card->host->dma_buf;
+		sdio_info->sd_mmc_phy_buf = card->host->dma_phy_buf;
+	}
+
+	card->card_info = sdio_info;
+	card->card_io_init = sd_io_init;
+	card->card_detector = sd_insert_detector;
+	card->card_insert_process = sd_open;
+	card->card_remove_process = sd_close;
+	card->card_request_process = sdio_request;
+        card->card_suspend = sd_suspend;
+        card->card_resume = sd_resume;
+	if (aml_card_info->card_extern_init)
+		aml_card_info->card_extern_init();
+	card->card_io_init(card);
+	sd_mmc_prepare_init(sdio_info);
+	sdio_info->io_pad_type = aml_card_info->io_pad_type;
+	sdio_info->bus_width = SD_BUS_SINGLE;
+	sdio_info->sdio_clk_unit = 3000;
+	sdio_info->clks_nac = SD_MMC_TIME_NAC_DEFAULT;
+	sdio_info->max_blk_count = card->host->max_blk_count;
 
-	free_irq(INT_SDIO, (void *)(&cr_mon));
-	sd_mmc_exit();
+	return 0;
 }
 
-module_init(sd_init);
+#ifdef CONFIG_INAND
+
+
+
+int inand_probe(struct memory_card *card)
+{
+	struct aml_card_info *aml_card_info = card->card_plat_info;
+
+	SD_MMC_Card_Info_t *sdio_info = sd_mmc_malloc(sizeof(SD_MMC_Card_Info_t), GFP_KERNEL);
+	if (sdio_info == NULL)
+		return -ENOMEM;
+
+	if (card->host->dma_buf != NULL) {
+		sdio_info->sd_mmc_buf = card->host->dma_buf;
+		sdio_info->sd_mmc_phy_buf = card->host->dma_phy_buf;
+	}
+
+	card->card_info = sdio_info;
+	card->card_io_init = sd_io_init;
+	card->card_detector = sd_insert_detector;
+	card->card_insert_process = sd_open;
+	card->card_remove_process = sd_close;
+	card->card_request_process = sd_request;
+
+	if (aml_card_info->card_extern_init)
+		aml_card_info->card_extern_init();
+	card->card_io_init(card);
+	sd_mmc_prepare_init(sdio_info);
+	sdio_info->io_pad_type = aml_card_info->io_pad_type;
+	sdio_info->bus_width = SD_BUS_SINGLE;
+	sdio_info->sdio_clk_unit = 3000;
+	sdio_info->clks_nac = SD_MMC_TIME_NAC_DEFAULT;
+	sdio_info->max_blk_count = card->host->max_blk_count;
 
-module_exit(sd_exit);
+	return 0;
+}
 
+#endif
 
-MODULE_DESCRIPTION("Amlogic SD Card Interface driver");
+MODULE_DESCRIPTION("Amlogic sd card Interface driver");
 
 MODULE_LICENSE("GPL");
 
diff -Nur drivers/amlogic/cardreader/sd/sd_misc.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_misc.c
--- drivers/amlogic/cardreader/sd/sd_misc.c	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_misc.c	2011-07-14 00:17:51.976739983 +0800
@@ -96,6 +96,7 @@
 	if(SD_WORK_MODE == CARD_SW_MODE)
 		return 10*(sd_mmc_TAAC(TAAC)/1000*FREQ_OP/1000000 + NSAC*100);
 #endif
+	return 3*(sd_mmc_TAAC(TAAC)/1000*FREQ_OP/1000000 + NSAC*100);
 }
 
 
diff -Nur drivers/amlogic/cardreader/sd/sd_misc.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_misc.h
--- drivers/amlogic/cardreader/sd/sd_misc.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_misc.h	2011-07-14 00:17:51.976739983 +0800
@@ -43,7 +43,7 @@
 */ 
     
 #ifdef SD_MMC_ALLOC_MEMORY
-#define sd_mmc_malloc				kmalloc
+#define sd_mmc_malloc				kzalloc
 #define sd_mmc_free					kfree
 #endif				/*  */
     
diff -Nur drivers/amlogic/cardreader/sd/sd_port.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_port.h
--- drivers/amlogic/cardreader/sd/sd_port.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_port.h	2011-07-14 00:17:51.976739983 +0800
@@ -7,7 +7,7 @@
     
 //Following I/O configurations are just for default case if no any known PCB defined
     
-//#define SD_IO_EXTERNAL
+#define SD_IO_EXTERNAL
     
 //Port operation for SD BUS
 //write it as such form that could be replaced by function later if needed
@@ -61,9 +61,8 @@
 #define SD_MMC_POWER_CONTROL
 //#define SD_MMC_WP_CHECK
 
-extern void sd_sdio_enable(void);
-
-extern void sd_gpio_enable(void);
+extern void sd_sdio_enable(SDIO_Pad_Type_t io_pad_type);
+extern void sd_gpio_enable(SDIO_Pad_Type_t io_pad_type);
 
 #else				//SD_IO_EXTERNAL
 
@@ -226,7 +225,8 @@
 #define sd_set_cmd_output()				{(*(volatile unsigned int *)SD_CMD_OUTPUT_EN_REG) &= (~SD_CMD_OUTPUT_EN_MASK);}
 #define sd_set_cmd_value(data)			{if(data){(*(volatile unsigned int *)SD_CMD_OUTPUT_REG) |= SD_CMD_OUTPUT_MASK;}else{(*(volatile unsigned int *)SD_CMD_OUTPUT_REG) &= (~SD_CMD_OUTPUT_MASK);}}
 #define sd_get_cmd_value()				((*(volatile unsigned int *)SD_CMD_INPUT_REG & SD_CMD_INPUT_MASK)?1:0)
-    
+
+#define sd_set_clk_input()				{(*(volatile unsigned int *)SD_CLK_OUTPUT_EN_REG) |= SD_CLK_OUTPUT_EN_MASK; for(i_GPIO_timer=0;i_GPIO_timer<15;i_GPIO_timer++);}    
 #define sd_set_clk_output()    			{(*(volatile unsigned int *)SD_CLK_OUTPUT_EN_REG) &= (~SD_CLK_OUTPUT_EN_MASK);}
 #define sd_set_clk_high()				{(*(volatile unsigned int *)SD_CLK_OUTPUT_REG) |= SD_CLK_OUTPUT_MASK;}
 #define sd_set_clk_low()				{(*(volatile unsigned int *)SD_CLK_OUTPUT_REG) &= (~SD_CLK_OUTPUT_MASK);}
diff -Nur drivers/amlogic/cardreader/sd/sd_protocol.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_protocol.c
--- drivers/amlogic/cardreader/sd/sd_protocol.c	2011-07-21 16:03:41.764739985 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_protocol.c	2011-07-14 00:17:51.980739983 +0800
@@ -1,12 +1,10 @@
+#include <linux/clk.h>
 #include "sd_port.h"
 #include "sd_misc.h"
 #include "sd_protocol.h"
-#include <asm/cacheflush.h>
-
-#define SD_MMC_DEBUG 1
 
 //Global struct variable, to hold all card information need to operate card
-static SD_MMC_Card_Info_t _sd_mmc_info = {CARD_TYPE_NONE,           //card_type
+/*static SD_MMC_Card_Info_t _sd_mmc_info = {CARD_TYPE_NONE,           //card_type
 										  CARD_TYPE_NONE_SDIO,		//sdio_card_type
 										 CARD_INDENTIFICATION_MODE, //operation_mode
 										 SD_BUS_SINGLE,             //bus_width
@@ -30,33 +28,11 @@
 										 NULL,						//sd_mmc_get_ins
 										 NULL,						//sd_get_wp
 										 NULL						//sd_mmc_io_release
-										 };
-SD_MMC_Card_Info_t *sd_mmc_info = &_sd_mmc_info;
-
-#define SD_MMC_BUFFER_SIZE				(512*256)
+										 };*/
+//SD_MMC_Card_Info_t *sd_mmc_info = &_sd_mmc_info;
 
 extern unsigned sdio_timeout_int_times;
 
-#ifdef SD_MMC_ALLOC_MEMORY
-unsigned char *sd_mmc_phy_buf = NULL;
-unsigned char *sd_mmc_buf = NULL;
-static unsigned sd_mmc_buf_from_sys = 0;
-#else
-static unsigned char sd_mmc_buf[SD_MMC_BUFFER_SIZE];
-#endif
-
-static unsigned long sd_save_hw_reg_flag;
-static unsigned long sd_save_hw_io_config;
-static unsigned long sd_save_hw_io_mult_config;
-
-static unsigned read_multi_block_failed=0;
-static unsigned write_multi_block_failed = 0;
-static unsigned long sd_mmc_buf_size = SD_MMC_BUFFER_SIZE;
-static unsigned sdio_read_crc_close = 0;
-unsigned sd_mmc_power_delay = 0;
-unsigned disable_high_speed = 0;
-unsigned disable_wide_bus = 0;
-
 static char * sd_error_string[]={
 	"SD_MMC_NO_ERROR",
 	"SD_MMC_ERROR_OUT_OF_RANGE",        //Bit 31
@@ -98,19 +74,19 @@
 //All local function definitions, only used in this .C file
 char * sd_error_to_string(int errcode);
 
-void sd_delay_clocks_z(int num_clk);
-void sd_delay_clocks_h(int num_clk);
+void sd_delay_clocks_z(SD_MMC_Card_Info_t *sd_mmc_info, int num_clk);
+void sd_delay_clocks_h(SD_MMC_Card_Info_t *sd_mmc_info, int num_clk);
 
 void sd_clear_response(unsigned char * res_buf);
-int sd_write_cmd_data(unsigned long byte_cnt, unsigned char * data_buf);
-int sd_get_dat0_data(unsigned long byte_cnt, unsigned char * data_buf, unsigned short * crc16);
+int sd_write_cmd_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long byte_cnt, unsigned char * data_buf);
+int sd_get_dat0_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long byte_cnt, unsigned char * data_buf, unsigned short * crc16);
 int sd_get_response_length(SD_Response_Type_t res_type);
-int sd_read_response_data(unsigned long byte_cnt, unsigned char * res_buf);
+int sd_read_response_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long byte_cnt, unsigned char * res_buf);
 #ifdef SD_MMC_SW_CONTROL
-int sd_send_cmd_sw(unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf);
+int sd_send_cmd_sw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf);
 #endif
 #ifdef SD_MMC_HW_CONTROL
-int sd_send_cmd_hw(unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf, unsigned char *data_buf, unsigned long data_cnt, int retry_flag);
+int sd_send_cmd_hw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf, unsigned char *data_buf, unsigned long data_cnt, int retry_flag);
 #endif
 
 int sd_check_response_r1(unsigned char cmd, SD_Response_R1_t * r1);
@@ -123,45 +99,46 @@
 int sd_check_response_r2_csd(unsigned char cmd, SD_Response_R2_CSD_t * r2_csd);
 int sd_check_response(unsigned char cmd, SD_Response_Type_t res_type, unsigned char * res_buf);
 
-int sd_hw_reset(void);
-int sd_sw_reset(void);
-int sd_voltage_validation(void);
-int sd_identify_process(void);
-int sd_mmc_switch_function(void);
-int sd_check_sdio_card_type(void);
-int sdio_data_transfer_abort(int function_no);
-int sdio_card_reset(void);
+int sd_hw_reset(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_sw_reset(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_voltage_validation(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_identify_process(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_mmc_switch_function(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_check_sdio_card_type(SD_MMC_Card_Info_t *sd_mmc_info);
+int sdio_data_transfer_abort(SD_MMC_Card_Info_t *sd_mmc_info, int function_no);
+int sdio_card_reset(SD_MMC_Card_Info_t *sd_mmc_info);
+void sd_mmc_set_input(SD_MMC_Card_Info_t *sd_mmc_info);
 
 //Read single block data from SD card
-int sd_read_single_block(unsigned long lba, unsigned char * data_buf);
+int sd_read_single_block(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned char * data_buf);
 //Read multi block data from SD card
-int sd_read_multi_block(unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf);
+int sd_read_multi_block(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf);
 //Write single block data to SD card
-int sd_write_single_block(unsigned long lba, unsigned char * data_buf);
+int sd_write_single_block(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned char * data_buf);
 //Write multi block data to SD card
-int sd_write_multi_block(unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf);
+int sd_write_multi_block(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf);
 
 //Read Operation Conditions Register
-int sd_read_reg_ocr(SD_REG_OCR_t * ocr);
+int sd_read_reg_ocr(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_OCR_t * ocr);
 //Read Card_Identification Register
-int sd_read_reg_cid(SD_REG_CID_t * cid);
+int sd_read_reg_cid(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_CID_t * cid);
 //Read Card-Specific Data Register
-int sd_read_reg_csd(SD_REG_CSD_t * csd);
+int sd_read_reg_csd(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_CSD_t * csd);
 //Read Relative Card Address Register
-int sd_read_reg_rca(unsigned short * rca);
+int sd_read_reg_rca(SD_MMC_Card_Info_t *sd_mmc_info, unsigned short * rca);
 //Read Driver Stage Register
-int sd_read_reg_dsr(SD_REG_DSR_t * dsr);
+int sd_read_reg_dsr(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_DSR_t * dsr);
 //Read SD CARD Configuration Register
-int sd_read_reg_scr(SD_REG_SCR_t * scr);
+int sd_read_reg_scr(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_SCR_t * scr);
 
-int sd_check_data_consistency(void);
+int sd_check_data_consistency(SD_MMC_Card_Info_t *sd_mmc_info);
 
-void sd_mmc_prepare_power(void);
-void sd_mmc_io_config(void);
-int sd_mmc_staff_init(void);
-int sd_mmc_cmd_test(void);
+void sd_mmc_prepare_power(SD_MMC_Card_Info_t *sd_mmc_info);
+void sd_mmc_io_config(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_mmc_staff_init(SD_MMC_Card_Info_t *sd_mmc_info);
+int sd_mmc_cmd_test(SD_MMC_Card_Info_t *sd_mmc_info);
 
-int sd_mmc_check_wp(void);
+int sd_mmc_check_wp(SD_MMC_Card_Info_t *sd_mmc_info);
 
 //Return the string buf address of specific errcode
 char * sd_error_to_string(int errcode)
@@ -170,7 +147,7 @@
 }
 
 //Set clock delay, Z-bit is driven to (respectively kept) HIGH by the pull-up resistors RCMD respectively RDAT.
-void sd_delay_clocks_z(int num_clk)
+void sd_delay_clocks_z(SD_MMC_Card_Info_t *sd_mmc_info, int num_clk)
 {
 	int i;
 	
@@ -195,7 +172,7 @@
 }
 
 //Set clock delay, P-bit is actively driven to HIGH by the card respectively host output driver.
-void sd_delay_clocks_h(int num_clk)
+void sd_delay_clocks_h(SD_MMC_Card_Info_t *sd_mmc_info, int num_clk)
 {
 	int i;
 	
@@ -233,7 +210,7 @@
 }
 
 //Put data bytes to cmd line
-int sd_write_cmd_data(unsigned long byte_cnt, unsigned char * data_buf)
+int sd_write_cmd_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	unsigned long data_cnt,data;
 	int i;
@@ -279,7 +256,7 @@
 }
 
 //Get data bytes from data0 line
-int sd_get_dat0_data(unsigned long byte_cnt, unsigned char * data_buf, unsigned short * crc16)
+int sd_get_dat0_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long byte_cnt, unsigned char * data_buf, unsigned short * crc16)
 {
 	unsigned long data_cnt,data,temp, num_nac=0;
 	int busy = 1, i;
@@ -444,7 +421,7 @@
 
 //Send command with response
 #ifdef SD_MMC_SW_CONTROL
-int sd_send_cmd_sw(unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf)
+int sd_send_cmd_sw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf)
 {
 	int ret = SD_MMC_NO_ERROR, num_res;
 	unsigned char cmd_buf[6];
@@ -460,27 +437,27 @@
 	if(ret)
 		return SD_MMC_ERROR_COM_CRC;
 
-	sd_write_cmd_data(6, cmd_buf);
+	sd_write_cmd_data(sd_mmc_info, 6, cmd_buf);
 	
 	if(res_type == RESPONSE_NONE)
 	{
-		sd_delay_clocks_z(SD_MMC_TIME_NRC_NCC);
+		sd_delay_clocks_z(sd_mmc_info, SD_MMC_TIME_NRC_NCC);
 		return SD_MMC_NO_ERROR;
 	}
 
 	//A delay before dealing with response
-	sd_delay_clocks_z(SD_MMC_Z_CMD_TO_RES);
+	sd_delay_clocks_z(sd_mmc_info,SD_MMC_Z_CMD_TO_RES);
 	
 	num_res = sd_get_response_length(res_type);
 	
 	sd_clear_response(res_buf);
-	ret = sd_read_response_data(num_res, res_buf); 
+	ret = sd_read_response_data(sd_mmc_info, num_res, res_buf); 
 	if(ret)
 		return ret;
 
 	ret = sd_check_response(cmd, res_type, res_buf);
 
-	sd_delay_clocks_z(SD_MMC_TIME_NRC_NCC);
+	sd_delay_clocks_z(sd_mmc_info, SD_MMC_TIME_NRC_NCC);
 	
 	return ret;
 }
@@ -489,23 +466,23 @@
 
 //Send command with response
 #ifdef SD_MMC_HW_CONTROL
-int sd_send_cmd_hw(unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf, unsigned char *data_buf, unsigned long data_cnt, int retry_flag)
+int sd_send_cmd_hw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned char cmd, unsigned long arg, SD_Response_Type_t res_type, unsigned char * res_buf, unsigned char *data_buf, unsigned long data_cnt, int retry_flag)
 {
 	int ret = SD_MMC_NO_ERROR, num_res;
 	unsigned char *buffer = NULL;
 	unsigned int cmd_ext, cmd_send;
-	dma_addr_t data_dma_to_device_addr=0;
-	dma_addr_t data_dma_from_device_addr=0;
 
 	MSHW_IRQ_Config_Reg_t *irq_config_reg;
 	SDIO_Status_IRQ_Reg_t *status_irq_reg;
 	SDHW_CMD_Send_Reg_t *cmd_send_reg;
 	SDHW_Extension_Reg_t *cmd_ext_reg;
 	unsigned int irq_config, status_irq, timeout;
+	dma_addr_t data_dma_to_device_addr=0;
+	dma_addr_t data_dma_from_device_addr=0;
 
 	cmd_send = 0;
 	cmd_send_reg = (void *)&cmd_send;
-	if(cmd == SD_SWITCH_FUNCTION)
+	if ((cmd == SD_SWITCH_FUNCTION) || (cmd == MMC_SEND_EXT_CSD))
 		cmd_send_reg->cmd_data  = 0x40 | (cmd-40);          //for distinguish ACMD6 and CMD6,Maybe more good way but now I cant find
 	else	
 	    cmd_send_reg->cmd_data = 0x40 | cmd;
@@ -547,7 +524,6 @@
 	{
 		case SD_MMC_READ_SINGLE_BLOCK:
 		case SD_MMC_READ_MULTIPLE_BLOCK:
-			//inv_dcache_range((unsigned long)sd_mmc_buf, ((unsigned long)sd_mmc_buf + data_cnt));
 			cmd_send_reg->res_with_data = 1;
 			cmd_send_reg->repeat_package_times = data_cnt/sd_mmc_info->blk_len - 1;
 			if(sd_mmc_info->bus_width == SD_BUS_WIDE)
@@ -555,17 +531,11 @@
 			else
 				cmd_ext_reg->data_rw_number = sd_mmc_info->blk_len * 8 + 16 - 1;
 
-			if(data_buf == sd_mmc_buf)/*data_buf == cq->bounce_buf, sg > 1*/
-				buffer = sd_mmc_phy_buf;
-			else{/*sg = 1, map directly*/
-				//data_dma_from_device_addr = dma_map_single(NULL, (void *)data_buf, data_cnt, DMA_FROM_DEVICE );
-				dmac_map_area(data_buf, data_cnt, DMA_FROM_DEVICE);
-				data_dma_from_device_addr = virt_to_dma(NULL, data_buf);
-				buffer = data_dma_from_device_addr;
-			}
+			buffer = sd_mmc_info->sd_mmc_phy_buf;
 			break;
 
         case SD_SWITCH_FUNCTION:
+        case MMC_SEND_EXT_CSD:
             //inv_dcache_range((unsigned long)sd_mmc_buf, ((unsigned long)sd_mmc_buf + data_cnt));
 			cmd_send_reg->res_with_data = 1;
 			cmd_send_reg->repeat_package_times = 0;
@@ -573,7 +543,7 @@
 				cmd_ext_reg->data_rw_number = data_cnt * 8 + (16 - 1) * 4;
 			else
 				cmd_ext_reg->data_rw_number = data_cnt * 8 + 16 - 1;
-			buffer = sd_mmc_phy_buf;
+			buffer = sd_mmc_info->sd_mmc_phy_buf;
 			break;
 
 		case SD_MMC_WRITE_BLOCK:
@@ -585,20 +555,8 @@
 			else
 				cmd_ext_reg->data_rw_number = sd_mmc_info->blk_len * 8 + 16 - 1;
 			
-			if(data_buf == sd_mmc_buf)/*data_buf == cq->bounce_buf, sg > 1*/
-				buffer = sd_mmc_phy_buf;
-			else{/*sg = 1, map directly*/
-				//data_dma_to_device_addr=dma_map_single(NULL, (void *)data_buf, data_cnt, DMA_TO_DEVICE);	
-				dmac_map_area(data_buf, data_cnt, DMA_TO_DEVICE);
-				data_dma_to_device_addr = virt_to_dma(NULL, data_buf);
-				buffer = data_dma_to_device_addr;
-			}
-			
-			//data_dma_to_device_addr=dma_map_single(NULL, (void *)data_buf, data_cnt, DMA_TO_DEVICE);	
-			//buffer = (unsigned char*)data_dma_to_device_addr;
-
-			//buffer = sd_mmc_phy_buf;
-			//inv_dcache_range((unsigned long)buffer, ((unsigned long)buffer + data_cnt));
+			buffer = sd_mmc_info->sd_mmc_phy_buf;
+                        wmb();
 			break;
 
 		case IO_RW_EXTENDED:
@@ -622,14 +580,17 @@
 			if(arg & (1<<31))
 			{
 				cmd_send_reg->cmd_send_data = 1;
-				buffer = sd_mmc_phy_buf;
-				//inv_dcache_range((unsigned long)sd_mmc_buf, ((unsigned long)sd_mmc_buf + data_cnt));
+				//memcpy(sd_mmc_info->sd_mmc_buf, data_buf, data_cnt);
+				//buffer = sd_mmc_info->sd_mmc_phy_buf;
+				data_dma_to_device_addr=dma_map_single(NULL, (void *)data_buf, data_cnt, DMA_TO_DEVICE);	
+				buffer = (unsigned char*)data_dma_to_device_addr;
 			}
 			else
 			{
 				cmd_send_reg->res_with_data = 1;
-				//inv_dcache_range((unsigned long)sd_mmc_buf, ((unsigned long)sd_mmc_buf + data_cnt));
-				buffer = sd_mmc_phy_buf;
+				//buffer = sd_mmc_info->sd_mmc_phy_buf;
+				data_dma_from_device_addr = dma_map_single(NULL, (void *)data_buf, data_cnt, DMA_FROM_DEVICE );
+				buffer = (unsigned char*)data_dma_from_device_addr;
 			}
 			break;
 
@@ -646,7 +607,7 @@
 				cmd_ext_reg->data_rw_number = data_cnt * 8 + (16 - 1) * 4;
 			else
 				cmd_ext_reg->data_rw_number = data_cnt * 8 + 16 - 1;
-			buffer = sd_mmc_phy_buf;
+			buffer = sd_mmc_info->sd_mmc_phy_buf;
 			break;
 			
 		default:
@@ -682,6 +643,7 @@
 			
 	}
 
+	#define SD_MMC_CMD_COUNT				20000//20
 	#define SD_MMC_READ_BUSY_COUNT		2000000//20
 	#define SD_MMC_WRITE_BUSY_COUNT		50000000//500000
 	#define SD_MMC_WAIT_STOP_COUNT		50000000
@@ -703,7 +665,7 @@
     	else if(cmd == IO_RW_EXTENDED)
     		timeout = SD_MMC_READ_BUSY_COUNT * (cmd_send_reg->repeat_package_times + 1);
         else
-    	    timeout = SD_MMC_READ_BUSY_COUNT;
+    	    timeout = SD_MMC_CMD_COUNT;
     }
     
     if(cmd == SD_MMC_STOP_TRANSMISSION)
@@ -746,48 +708,19 @@
 
 	WRITE_CBUS_REG(CMD_SEND, cmd_send);
 
-	//interruptible_sleep_on(&sdio_wait_event);
-	wait_for_completion(&sdio_int_complete);
-	/*timeout_count = 0;
-    while(1)
-    {
-    	status_irq = READ_CBUS_REG(SDIO_STATUS_IRQ);
-
-    	if(!status_irq_reg->cmd_busy && status_irq_reg->cmd_int)
-    		break;
-
-    	if(!sd_mmc_check_insert())
-        	return SD_MMC_ERROR_NO_CARD_INS;
+	timeout =500;/*5s*/
+	timeout = wait_for_completion_timeout(&sdio_int_complete,timeout);
+	//wait_for_completion(&sdio_int_complete);
 
-    	if((++timeout_count) > timeout)
-        {
-        	if(!retry_flag)
-        		return SD_MMC_ERROR_TIMEOUT;	
-
-        	irq_config_reg->soft_reset = 1;
-            WRITE_CBUS_REG(SDIO_IRQ_CONFIG, irq_config);
-
-            if((++repeat_time) > SD_MMC_RETRY_COUNT)
-            {
-				return SD_MMC_ERROR_TIMEOUT;
-			}
-
-            //goto CMD_RETRY;
-            return SD_MMC_ERROR_TIMEOUT;
-        }
-
-		sd_delay_us(10);
-		if(cmd == SD_MMC_STOP_TRANSMISSION)
-		    sd_delay_ms(1);	
-    }*/
-
-	if(sdio_timeout_int_times == 0){
+	if(sdio_timeout_int_times == 0 || timeout == 0){
 		ret = SD_MMC_ERROR_TIMEOUT;
+		if(timeout == 0)
+			printk("[sd_send_cmd_hw] wait_for_completion_timeout\n");
 		goto error;
 	}
 
 	status_irq = READ_CBUS_REG(SDIO_STATUS_IRQ);
-	if(cmd_send_reg->cmd_res_bits && !cmd_send_reg->res_without_crc7 && !status_irq_reg->res_crc7_ok && !sdio_read_crc_close){
+	if(cmd_send_reg->cmd_res_bits && !cmd_send_reg->res_without_crc7 && !status_irq_reg->res_crc7_ok && !sd_mmc_info->sdio_read_crc_close){
 		ret = SD_MMC_ERROR_COM_CRC;
 		goto error;
 	}
@@ -830,6 +763,7 @@
 		case SD_MMC_READ_SINGLE_BLOCK:
 		case SD_MMC_READ_MULTIPLE_BLOCK:
 		case SD_SWITCH_FUNCTION:
+                case MMC_SEND_EXT_CSD:
 			if(!status_irq_reg->data_read_crc16_ok){
 				ret = SD_MMC_ERROR_DATA_CRC;
 				goto error;
@@ -863,7 +797,7 @@
 			}
 			else
 			{
-				if(!sdio_read_crc_close)
+				if(!sd_mmc_info->sdio_read_crc_close)
 				{
 					if(!status_irq_reg->data_read_crc16_ok){
 						ret = SD_MMC_ERROR_DATA_CRC;
@@ -876,29 +810,28 @@
 			break;
 			
 	}
-
-	//if(cmd_send_reg->res_with_data && buffer && (data_buf != sd_mmc_phy_buf))
-	//{
-	//	memcpy(data_buf, sd_mmc_buf, data_cnt);
-	//}
-	//if(data_dma_from_device_addr)
-	//	dmac_unmap_area(data_buf, data_cnt, DMA_FROM_DEVICE);
-	//if(data_dma_to_device_addr)
-	//	dmac_unmap_area(data_buf, data_cnt, DMA_TO_DEVICE);
-
-	return SD_MMC_NO_ERROR;
+	/*error need dma_unmap_single also*/
 error:
-	
-	//if(data_dma_from_device_addr)
-	//	dmac_unmap_area(data_buf, data_cnt, DMA_FROM_DEVICE);
-	//if(data_dma_to_device_addr)
-	//	dmac_unmap_area(data_buf, data_cnt, DMA_TO_DEVICE);
+	if(data_dma_from_device_addr)
+	{
+		dma_unmap_single(NULL, data_dma_from_device_addr, data_cnt, DMA_FROM_DEVICE);
+	}
+	if(data_dma_to_device_addr)
+	{
+		dma_unmap_single(NULL, data_dma_to_device_addr, data_cnt, DMA_TO_DEVICE);
+	}
+	if(cmd_send_reg->res_with_data && buffer && (data_buf != sd_mmc_info->sd_mmc_buf)
+		&& (!data_dma_from_device_addr) && (!data_dma_to_device_addr))
+	{
+		memcpy(data_buf, sd_mmc_info->sd_mmc_buf, data_cnt);
+	}
+
 	return ret;
 }
 #endif
 
 //Read SD Response Data
-int sd_read_response_data(unsigned long byte_cnt, unsigned char * res_buf)
+int sd_read_response_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long byte_cnt, unsigned char * res_buf)
 {
 	unsigned long data_cnt, num_ncr = 0;
 	unsigned char data, temp;
@@ -1242,13 +1175,13 @@
 
 //Read single block data from SD card
 #ifdef SD_MMC_HW_CONTROL
-int sd_read_single_block_hw(unsigned long lba, unsigned char * data_buf)
+int sd_read_single_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned char * data_buf)
 {
 	int ret, read_retry_count, read_single_block_hw_failed = 0;
 	unsigned long data_addr;
 	unsigned char response[MAX_RESPONSE_BYTES];
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -1260,9 +1193,10 @@
 
     for(read_retry_count=0; read_retry_count<3; read_retry_count++)
     {
-	    ret = sd_send_cmd_hw(SD_MMC_READ_SINGLE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, sd_mmc_info->blk_len, 1);
+	    ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_READ_SINGLE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, sd_mmc_info->blk_len, 1);
 	    if(ret)
 	    {
+	    	printk(" sd_read_single_block_hw ret %d \n", ret);
 	        read_single_block_hw_failed++;
 	        continue;
 	    }
@@ -1271,10 +1205,7 @@
     }
 
     if(read_single_block_hw_failed >= 3)
-    {
-        //SD_WORK_MODE = CARD_SW_MODE;
         return SD_MMC_ERROR_READ_DATA_FAILED;
-    }
 
     if(ret)
         return ret;
@@ -1285,7 +1216,7 @@
 
 //Read single block data from SD card
 #ifdef SD_MMC_SW_CONTROL
-int sd_read_single_block_sw(unsigned long lba, unsigned char * data_buf)
+int sd_read_single_block_sw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned char * data_buf)
 {
 	unsigned long data = 0, res = 0, temp = 0;
 	int ret, data_busy = 1, res_busy = 1;
@@ -1316,7 +1247,7 @@
 		sd_set_dat0_input();
 	}
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -1326,12 +1257,12 @@
 	data_addr *= lba;
 	}
 	
-	ret = sd_send_cmd_sw(SD_MMC_READ_SINGLE_BLOCK, data_addr, RESPONSE_NONE, 0);
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_READ_SINGLE_BLOCK, data_addr, RESPONSE_NONE, 0);
 	if(ret)
 		return ret;
 	
 	sd_clear_response(response);
-	sd_delay_clocks_z(SD_MMC_Z_CMD_TO_RES);
+	sd_delay_clocks_z(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 	
 	sd_set_cmd_input();
 	//wait until both response and data is valid    
@@ -1619,7 +1550,7 @@
 	sd_clk_transfer_low();      //for end bit
 	sd_clk_transfer_high();
 	
-	sd_delay_clocks_z(SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
+	sd_delay_clocks_z(sd_mmc_info, SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
 
 #ifdef SD_MMC_CRC_CHECK
 	if(error == SD_MMC_ERROR_DATA_CRC)
@@ -1636,7 +1567,7 @@
 #endif
 
 #ifdef SD_MMC_HW_CONTROL
-int sd_read_multi_block_hw(unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
+int sd_read_multi_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
 {
 	int ret, read_retry_count, i, read_multi_block_hw_failed = 0;
 	unsigned long data_addr, lba_num, data_offset = 0;
@@ -1645,7 +1576,7 @@
 	if(lba_cnt == 0)
 		return SD_MMC_ERROR_BLOCK_LEN;
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -1655,16 +1586,16 @@
 		data_addr *= lba;
 	}
 	
-    if(read_multi_block_failed == 0)
+    if(sd_mmc_info->read_multi_block_failed == 0)
 	{	
         while(lba_cnt)
         {
-            if(lba_cnt > sd_mmc_buf_size/512)
-                lba_num = sd_mmc_buf_size/512;
+            if(lba_cnt > sd_mmc_info->max_blk_count)
+                lba_num = sd_mmc_info->max_blk_count;
             else
                 lba_num = lba_cnt;
 
-            if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+            if((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
                 data_addr += data_offset/512;
             else
                 data_addr += data_offset;
@@ -1672,11 +1603,11 @@
             data_buf += data_offset;
             for(read_retry_count=0; read_retry_count<3; read_retry_count++)
             {
-	            ret = sd_send_cmd_hw(SD_MMC_READ_MULTIPLE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, sd_mmc_info->blk_len*lba_num, 1);
+	            ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_READ_MULTIPLE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, sd_mmc_info->blk_len*lba_num, 1);
 	            if(ret)
 	            {
 	                read_multi_block_hw_failed++;
-	                ret = sd_send_cmd_hw(SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
+	                ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
 	                if(ret)
 	                    return ret;
                 }
@@ -1686,7 +1617,7 @@
 
             if(read_multi_block_hw_failed >= 3)
             {
-                read_multi_block_failed = 1;
+                sd_mmc_info->read_multi_block_failed = 1;
                 return SD_MMC_ERROR_READ_DATA_FAILED;
             }	
 
@@ -1696,7 +1627,7 @@
             }
             else
             {        
-	            ret = sd_send_cmd_hw(SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
+	            ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
 	            if(ret)
 	                return ret;
 	        }
@@ -1709,7 +1640,7 @@
     {
 	    for(i=0; i<lba_cnt; i++)
 	    {
-		    ret = sd_read_single_block_hw(lba++, data_buf);
+		    ret = sd_read_single_block_hw(sd_mmc_info, lba++, data_buf);
 		    if(ret)
 			    return ret;
 		
@@ -1725,7 +1656,7 @@
 #endif
 
 #ifdef SD_MMC_SW_CONTROL
-int sd_read_multi_block_sw(unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
+int sd_read_multi_block_sw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
 {
 	unsigned long data = 0, res = 0, temp = 0;
 	int ret, data_busy = 1, res_busy = 1;
@@ -1759,7 +1690,7 @@
 		sd_set_dat0_input();
 	}
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -1768,12 +1699,12 @@
         data_addr = sd_mmc_info->blk_len;
         data_addr *= lba;
 	}
-	ret = sd_send_cmd_sw(SD_MMC_READ_MULTIPLE_BLOCK, data_addr, RESPONSE_NONE, 0);
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_READ_MULTIPLE_BLOCK, data_addr, RESPONSE_NONE, 0);
 	if(ret)
 		return ret;
 	
 	sd_clear_response(response);
-	sd_delay_clocks_z(SD_MMC_Z_CMD_TO_RES);
+	sd_delay_clocks_z(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 	
 	sd_set_cmd_input();
 	//wait until both response and data is valid    
@@ -2101,9 +2032,9 @@
 #endif
 	}
 
-	sd_delay_clocks_z(SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
+	sd_delay_clocks_z(sd_mmc_info, SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
 	
-	ret = sd_send_cmd_sw(SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response);
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response);
 
 #ifdef SD_MMC_CRC_CHECK
 	if(error == SD_MMC_ERROR_DATA_CRC)
@@ -2120,14 +2051,14 @@
 #endif 
 
 #ifdef SD_MMC_HW_CONTROL
-int sd_write_single_block_hw(unsigned long lba, unsigned char * data_buf)
+int sd_write_single_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned char * data_buf)
 {
 	int ret, write_retry_count;
 	unsigned long data_addr;
 	unsigned char response[MAX_RESPONSE_BYTES];
-	unsigned char *status_data_buf = sd_mmc_buf;
+	unsigned char *status_data_buf = sd_mmc_info->sd_mmc_buf;
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -2139,7 +2070,7 @@
 	
 	for(write_retry_count=0; write_retry_count<4; write_retry_count++)
 	{
-	    ret = sd_send_cmd_hw(SD_MMC_WRITE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, sd_mmc_info->blk_len, 1);
+	    ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_WRITE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, sd_mmc_info->blk_len, 1);
 		if(ret == SD_MMC_ERROR_DATA_CRC || ret == SD_MMC_ERROR_COM_CRC)
 		{
 		    if(sd_mmc_info->spec_version || sd_mmc_info->card_type == CARD_TYPE_SDHC)
@@ -2147,7 +2078,7 @@
                 memset(status_data_buf, 0, 64);
 #ifdef SD_MMC_HW_CONTROL
 	            if(SD_WORK_MODE == CARD_HW_MODE)
-		            ret = sd_send_cmd_hw(SD_SWITCH_FUNCTION, 0x00FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);
+		            ret = sd_send_cmd_hw(sd_mmc_info, SD_SWITCH_FUNCTION, 0x00FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);
 #endif
             }
             //for some sdhc card write problem on 7216 picframe
@@ -2170,7 +2101,7 @@
 #endif
 
 #ifdef SD_MMC_SW_CONTROL
-int sd_write_single_block_sw(unsigned long lba, unsigned char * data_buf)
+int sd_write_single_block_sw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned char * data_buf)
 {
 	int ret, i, j;
 	unsigned long crc_status, data;
@@ -2207,7 +2138,7 @@
 		sd_clk_transfer_high();
 	}
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -2217,12 +2148,12 @@
 	data_addr *= lba;
 	}
 	
-	ret = sd_send_cmd_sw(SD_MMC_WRITE_BLOCK, data_addr, RESPONSE_R1, response);
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_WRITE_BLOCK, data_addr, RESPONSE_R1, response);
 	if(ret)
 		return ret;
 		
 	//Nwr cycles delay
-	sd_delay_clocks_h(SD_MMC_TIME_NWR);
+	sd_delay_clocks_h(sd_mmc_info, SD_MMC_TIME_NWR);
 	
 	//Start bit
 	sd_clk_transfer_low();
@@ -2333,7 +2264,7 @@
 		sd_set_dat0_input();
 	}
 
-	sd_delay_clocks_h(SD_MMC_Z_CMD_TO_RES);
+	sd_delay_clocks_h(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 	
 	crc_status = 0;
 	//Check CRC status
@@ -2379,17 +2310,17 @@
 #endif
 
 #ifdef SD_MMC_HW_CONTROL
-int sd_write_multi_block_hw(unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
+int sd_write_multi_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
 {
 	int ret, write_retry_count;
 	unsigned long lba_num, data_addr, data_offset = 0;
-	unsigned char *status_data_buf = sd_mmc_buf;
+	unsigned char *status_data_buf = sd_mmc_info->sd_mmc_buf;
 	unsigned char response[MAX_RESPONSE_BYTES];
 	
 	if(lba_cnt == 0)
 		return SD_MMC_ERROR_BLOCK_LEN;
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -2399,11 +2330,11 @@
 		data_addr *= lba;
 	}
 
-    if(write_multi_block_failed)
+    if(sd_mmc_info->write_multi_block_failed)
     {
         for(lba_num=lba; lba_num<(lba+lba_cnt); lba_num++)
 	    {
-		    ret = sd_write_single_block_hw(lba_num, data_buf+data_offset);
+		    ret = sd_write_single_block_hw(sd_mmc_info, lba_num, data_buf+data_offset);
 		    if(ret)
 			    return ret;
 		
@@ -2414,22 +2345,22 @@
     {
         while(lba_cnt)
         {
-            if(lba_cnt>0x100)
-                lba_num = 0x100;
+            if(lba_cnt > sd_mmc_info->max_blk_count)
+                lba_num = sd_mmc_info->max_blk_count;
             else
                 lba_num = lba_cnt;
 	        if(sd_mmc_info->card_type == CARD_TYPE_SD || sd_mmc_info->card_type == CARD_TYPE_SDHC)
 	        {
-		        ret = sd_send_cmd_hw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, NULL, 0, 0);
+		        ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, NULL, 0, 0);
 		        if (ret) 
 		            return ret;
 		
-		        ret = sd_send_cmd_hw(SD_SET_WR_BLK_ERASE_COUNT, lba_num, RESPONSE_R1, response, NULL, 0, 0);
+		        ret = sd_send_cmd_hw(sd_mmc_info, SD_SET_WR_BLK_ERASE_COUNT, lba_num, RESPONSE_R1, response, NULL, 0, 0);
 		        if (ret) 
 		            return ret;
 	        }
 
-            if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+            if((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	            data_addr += data_offset/512;
 	        else
 	            data_addr += data_offset;
@@ -2437,10 +2368,10 @@
             data_buf += data_offset;
 	        for(write_retry_count=0; write_retry_count<4; write_retry_count++)
 	        {
-	            ret = sd_send_cmd_hw(SD_MMC_WRITE_MULTIPLE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, lba_num*512, 1);
+	            ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_WRITE_MULTIPLE_BLOCK, data_addr, RESPONSE_R1, response, data_buf, lba_num*512, 1);
 	            if(ret == SD_MMC_ERROR_DATA_CRC || ret == SD_MMC_ERROR_COM_CRC)
 	            {
-	                ret = sd_send_cmd_hw(SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
+	                ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
 	                if(ret)
 	                {
 	                    return ret;
@@ -2452,7 +2383,7 @@
                             memset(status_data_buf, 0, 64);
 #ifdef SD_MMC_HW_CONTROL
 	                        if(SD_WORK_MODE == CARD_HW_MODE)
-		                        ret = sd_send_cmd_hw(SD_SWITCH_FUNCTION, 0x00FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);
+		                        ret = sd_send_cmd_hw(sd_mmc_info, SD_SWITCH_FUNCTION, 0x00FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);
 #endif
                         //for some sdhc card write problem on 7216 picframe
                         }
@@ -2465,7 +2396,7 @@
 
             if(write_retry_count >= 4)
             {
-                write_multi_block_failed = 1;
+                sd_mmc_info->write_multi_block_failed = 1;
                 return SD_MMC_ERROR_DATA_CRC;
             }
 
@@ -2475,7 +2406,7 @@
             }
             else
             {        
-	            ret = sd_send_cmd_hw(SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
+	            ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_STOP_TRANSMISSION, 0, RESPONSE_R1B, response, NULL, 0, 0);
 	            if(ret)
 	                return ret;
 	        }
@@ -2490,7 +2421,7 @@
 #endif
 
 #ifdef SD_MMC_SW_CONTROL
-int sd_write_multi_block_sw(unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
+int sd_write_multi_block_sw(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long lba_cnt, unsigned char * data_buf)
 {
 	int ret,i,j;
 	unsigned long crc_status, data;
@@ -2514,10 +2445,10 @@
 		
 	if (sd_mmc_info->card_type == CARD_TYPE_SD || sd_mmc_info->card_type == CARD_TYPE_SDHC)
 	{
-		ret = sd_send_cmd_sw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
 		if (ret) return ret;
 		
-		ret = sd_send_cmd_sw(SD_SET_WR_BLK_ERASE_COUNT, lba_cnt, RESPONSE_R1, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_SET_WR_BLK_ERASE_COUNT, lba_cnt, RESPONSE_R1, response);
 		if (ret) return ret;
 	}
 
@@ -2543,7 +2474,7 @@
 		sd_clk_transfer_high();
 	}
 
-	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+	if ((sd_mmc_info->card_type == CARD_TYPE_SDHC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 	{
 		data_addr = lba;
 	}
@@ -2553,7 +2484,7 @@
 	    data_addr *= lba;
 	}
 	
-	ret = sd_send_cmd_sw(SD_MMC_WRITE_MULTIPLE_BLOCK, data_addr, RESPONSE_R1, response);
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_WRITE_MULTIPLE_BLOCK, data_addr, RESPONSE_R1, response);
 	if(ret)
 		return ret;
 	
@@ -2563,7 +2494,7 @@
 		org_buf = data_buf;
 		
 		//Nwr cycles delay
-		sd_delay_clocks_h(SD_MMC_TIME_NWR);
+		sd_delay_clocks_h(sd_mmc_info, SD_MMC_TIME_NWR);
 		
 		//Start bit
 		if(sd_mmc_info->bus_width == SD_BUS_WIDE)
@@ -2681,7 +2612,7 @@
 			sd_set_dat0_input();
 		}
 
-		sd_delay_clocks_h(SD_MMC_Z_CMD_TO_RES);
+		sd_delay_clocks_h(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 	
 		crc_status = 0;
 	
@@ -2724,7 +2655,7 @@
 		}
 	}
 	
-	ret = sd_send_cmd_sw(SD_MMC_STOP_TRANSMISSION, 0 , RESPONSE_R1B, response);
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_STOP_TRANSMISSION, 0 , RESPONSE_R1B, response);
 	if(ret)
 		return ret;
 	
@@ -2753,31 +2684,30 @@
 #endif
 
 //Functions for SD INIT
-int sd_hw_reset()
+int sd_hw_reset(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int ret=SD_MMC_NO_ERROR;
-	
 	sd_mmc_info->operation_mode = CARD_INDENTIFICATION_MODE;
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0, 0, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
 	{
-		sd_delay_clocks_h(74);  //74 is enough according to spec
+		sd_delay_clocks_h(sd_mmc_info, 74);  //74 is enough according to spec
 	
 		sd_delay_ms(1);
 		
-		ret = sd_send_cmd_sw(SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0);
 	}
 #endif
 	
 	return ret;
 }
 
-int sd_sw_reset()
+int sd_sw_reset(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int ret=SD_MMC_NO_ERROR;
 	
@@ -2785,17 +2715,17 @@
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0, 0, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)	
-		ret = sd_send_cmd_sw(SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_GO_IDLE_STATE, 0, RESPONSE_NONE, 0);
 #endif
 	
 	return ret;
 }
 
-int sd_voltage_validation()
+int sd_voltage_validation(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	unsigned char response[MAX_RESPONSE_BYTES];
 	SD_Response_R3_t * r3;
@@ -2803,7 +2733,7 @@
 	SDIO_Response_R4_t *r4;
 	int ret = 0,error = 0,delay_time,delay_cnt;
 
-	sd_delay_ms(10);
+	//sd_delay_ms(10);
 	
 	delay_time = 10;
 	delay_cnt = 1;
@@ -2813,15 +2743,23 @@
 	{
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			ret = sd_send_cmd_hw(IO_SEND_OP_COND, 0x00200000, RESPONSE_R4, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
+			ret = sd_send_cmd_hw(sd_mmc_info, IO_SEND_OP_COND, 0x00200000, RESPONSE_R4, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
 #endif
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			ret = sd_send_cmd_sw(IO_SEND_OP_COND, 0x00200000, RESPONSE_R4, response);   // 0x00200000: 3.3v~3.4v
+			ret = sd_send_cmd_sw(sd_mmc_info, IO_SEND_OP_COND, 0x00200000, RESPONSE_R4, response);   // 0x00200000: 3.3v~3.4v
 #endif
-	    if(ret)
+#ifdef SD_MMC_HW_CONTROL
+		if(SD_WORK_MODE == CARD_HW_MODE)
+			ret = sd_send_cmd_hw(sd_mmc_info, IO_SEND_OP_COND, 0x00200000, RESPONSE_R4, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
+#endif
+#ifdef SD_MMC_SW_CONTROL
+		if(SD_WORK_MODE == CARD_SW_MODE)
+			ret = sd_send_cmd_sw(sd_mmc_info, IO_SEND_OP_COND, 0x00200000, RESPONSE_R4, response);   // 0x00200000: 3.3v~3.4v
+#endif
+	    if(ret == SD_MMC_ERROR_TIMEOUT)
 	    {	
-		    error = sd_hw_reset();
+		    error = sd_hw_reset(sd_mmc_info);
 		    if(error)
 		    {
 #ifdef  SD_MMC_DEBUG
@@ -2838,10 +2776,15 @@
             if(r4->Card_Ready)
             {
                 sd_mmc_info->card_type = CARD_TYPE_SDIO;
+                sd_mmc_info->sdio_function_nums = r4->IO_Function_No;
                 if(r4->Memory_Present)
-                    break;
-                else
+                   break;
+                else {
+#ifdef SD_MMC_DEBUG
+					Debug_Printf("Actual delay time in sdio_voltage_validation() = %d ms\n", delay_time*delay_cnt);
+#endif
                     return SD_MMC_NO_ERROR;
+            	}
             }
 
             sd_delay_ms(delay_time);
@@ -2849,25 +2792,32 @@
         }
     } while(delay_cnt < (SD_MMC_IDENTIFY_TIMEOUT/delay_time));
 
+	sd_delay_ms(10);
+
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(SD_SEND_IF_COND, 0x000001aa, RESPONSE_R7, response, 0, 0, 0);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_SEND_IF_COND, 0x000001aa, RESPONSE_R7, response, 0, 0, 0);
 #endif		
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		ret = sd_send_cmd_sw(SD_SEND_IF_COND, 0x000001aa, RESPONSE_R7, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_SEND_IF_COND, 0x000001aa, RESPONSE_R7, response);
 #endif
 
-	if(ret == SD_MMC_ERROR_TIMEOUT)
+
+	if(ret)
 	{
-		error = sd_hw_reset();
-		if(error)
-		{
+		if(ret == SD_MMC_ERROR_TIMEOUT) {
+			error = sd_hw_reset(sd_mmc_info);
+			if(error)
+			{
 #ifdef  SD_MMC_DEBUG
-			Debug_Printf("#%s error occured in sd_hw_reset()\n", sd_error_to_string(error));
+				Debug_Printf("#%s error occured in sd_hw_reset()\n", sd_error_to_string(error));
 #endif
-			return error;
+				return error;
+			}
 		}
+		else
+			return ret;
 	}
 	else
 	{
@@ -2876,23 +2826,18 @@
 			sd_mmc_info->card_type = CARD_TYPE_SDHC;
 		else
 			sd_mmc_info->card_type = CARD_TYPE_SD;
-#ifdef SD_MMC_DEBUG
-			Debug_Printf("Actual sd cmd 8 check pattern = %d\n", r7->check_pattern);
-#endif
 	}
 
-	sd_delay_ms(10);
-
 	delay_cnt = 2;
     do
     {
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			ret = sd_send_cmd_hw(SD_APP_CMD, 0, RESPONSE_R1, response, 0, 0, 0);
+			ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_CMD, 0, RESPONSE_R1, response, 0, 0, 0);
 #endif		
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			ret = sd_send_cmd_sw(SD_APP_CMD, 0, RESPONSE_R1, response);
+			ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, 0, RESPONSE_R1, response);
 #endif
 					
 		if(ret)
@@ -2910,22 +2855,22 @@
 		{	
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
-				ret = sd_send_cmd_hw(SD_APP_OP_COND, 0x40200000, RESPONSE_R3, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_OP_COND, 0x40200000, RESPONSE_R3, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
 #endif
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
-				ret = sd_send_cmd_sw(SD_APP_OP_COND, 0x40200000, RESPONSE_R3, response);   // 0x00200000: 3.3v~3.4v
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_OP_COND, 0x40200000, RESPONSE_R3, response);   // 0x00200000: 3.3v~3.4v
 #endif
 		}
 		else
 		{	
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			ret = sd_send_cmd_hw(SD_APP_OP_COND, 0x00200000, RESPONSE_R3, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
+			ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_OP_COND, 0x00200000, RESPONSE_R3, response, 0, 0, 0);   // 0x00200000: 3.3v~3.4v
 #endif
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			ret = sd_send_cmd_sw(SD_APP_OP_COND, 0x00200000, RESPONSE_R3, response);   // 0x00200000: 3.3v~3.4v
+			ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_OP_COND, 0x00200000, RESPONSE_R3, response);   // 0x00200000: 3.3v~3.4v
 #endif
 		}	
 
@@ -2935,17 +2880,17 @@
 #ifdef SD_MMC_DEBUG
 			Debug_Printf("Actual delay time in sd_voltage_validation() = %d ms\n", delay_time*delay_cnt);
 #endif
-			if(!r3->ocr.Card_Capacity_Status)
+			if(!r3->ocr.Card_Capacity_Status) 
 				sd_mmc_info->card_type = CARD_TYPE_SD;
-					
+
 			return SD_MMC_NO_ERROR;
 		}
-			
+
 		sd_delay_ms(delay_time);
 		delay_cnt++;
 	} while(delay_cnt < (SD_MMC_IDENTIFY_TIMEOUT/delay_time));
 
-	sd_sw_reset();
+	sd_sw_reset(sd_mmc_info);
 	sd_delay_ms(10);
 
 	delay_cnt = 2;
@@ -2954,11 +2899,11 @@
 	{
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			ret = sd_send_cmd_hw(MMC_SEND_OP_COND, 0x00200000, RESPONSE_R3, response, 0, 0, 0); // 0x00200000: 3.3v~3.4v
+			ret = sd_send_cmd_hw(sd_mmc_info, MMC_SEND_OP_COND, 0x40FF8000, RESPONSE_R3, response, 0, 0, 0); // 0x00200000: 3.3v~3.4v
 #endif 
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			ret = sd_send_cmd_sw(MMC_SEND_OP_COND, 0x00200000, RESPONSE_R3, response); // 0x00200000: 3.3v~3.4v
+			ret = sd_send_cmd_sw(sd_mmc_info, MMC_SEND_OP_COND, 0x40FF8000, RESPONSE_R3, response); // 0x00200000: 3.3v~3.4v
 #endif
 			r3 = (SD_Response_R3_t *)response;
 		if(ret == SD_MMC_ERROR_TIMEOUT)
@@ -2970,7 +2915,10 @@
 #ifdef SD_MMC_DEBUG
 			Debug_Printf("Actual delay time in sd_voltage_validation() = %d ms\n", delay_time*delay_cnt);
 #endif
+			if(!r3->ocr.Card_Capacity_Status)
 			sd_mmc_info->card_type = CARD_TYPE_MMC;
+			else
+				sd_mmc_info->card_type = CARD_TYPE_EMMC;
 			
 			return SD_MMC_NO_ERROR;
 		}
@@ -2985,7 +2933,7 @@
 	return SD_MMC_ERROR_DRIVER_FAILURE;
 }
 
-int sd_identify_process()
+int sd_identify_process(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int ret = 0, slot_id, times;
 	unsigned temp;  ///< for compiler bug
@@ -2998,25 +2946,28 @@
 	
 	unsigned short c_size;
 	unsigned char c_size_multi;
-	unsigned char write_reg_data;
-	unsigned long sdio_config;
+	unsigned char read_reg_data, write_reg_data;
+	unsigned sdio_config;
+	SDIO_Config_Reg_t *config_reg = NULL;
+	
+	unsigned char *mmc_ext_csd_buf = sd_mmc_info->sd_mmc_buf;
+	MMC_REG_EXT_CSD_t *mmc_ext_csd_reg;
 	
-	SDIO_Config_Reg_t *config_reg;
-
 	//Request all devices to send their CIDs
 	if(sd_mmc_info->card_type != CARD_TYPE_SDIO)
 	{
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(SD_MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID, response, 0, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID, response, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		ret = sd_send_cmd_sw(SD_MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_ALL_SEND_CID, 0, RESPONSE_R2_CID, response);
 #endif
 	}
 
-	sd_delay_ms(10);  //for samsung card
+	sd_delay_ms(50);  //for MUSE 64MB CARD sd_identify_process timeout
+	//sd_delay_ms(10);  //for samsung card
 	/* Assign IDs to all devices found */
 	slot_id = 1;
 	delay_time = 10;
@@ -3026,18 +2977,18 @@
 		if(SD_WORK_MODE == CARD_HW_MODE)
 		{
 			if(sd_mmc_info->card_type == CARD_TYPE_SD || sd_mmc_info->card_type == CARD_TYPE_SDHC || sd_mmc_info->card_type == CARD_TYPE_SDIO)
-				ret = sd_send_cmd_hw(SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R6, response, 0, 0, 0);   ///* Send out a byte to read RCA*/
-			else if(sd_mmc_info->card_type == CARD_TYPE_MMC)   
-				ret = sd_send_cmd_hw(SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R1, response, 0, 0, 0);   ///* Send out a byte to read RCA*/
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R6, response, 0, 0, 0);   ///* Send out a byte to read RCA*/
+			else if((sd_mmc_info->card_type == CARD_TYPE_MMC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC)) 
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R1, response, 0, 0, 0);   ///* Send out a byte to read RCA*/
 		}
 #endif			
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
 		{
 			if(sd_mmc_info->card_type == CARD_TYPE_SD || sd_mmc_info->card_type == CARD_TYPE_SDHC || sd_mmc_info->card_type == CARD_TYPE_SDIO)
-				ret = sd_send_cmd_sw(SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R6, response);   ///* Send out a byte to read RCA*/
-			else if(sd_mmc_info->card_type == CARD_TYPE_MMC)   
-				ret = sd_send_cmd_sw(SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R1, response);   ///* Send out a byte to read RCA*/
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R6, response);   ///* Send out a byte to read RCA*/
+			else if((sd_mmc_info->card_type == CARD_TYPE_MMC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SEND_RELATIVE_ADDR, slot_id<<16, RESPONSE_R1, response);   ///* Send out a byte to read RCA*/
 		}
 #endif
 
@@ -3047,12 +2998,12 @@
 			break;
 
 				/* Get device information and assign an RCA to it. */
-		if ((sd_mmc_info->card_type == CARD_TYPE_MMC) && ( ret == SD_MMC_NO_ERROR))
+		if (((sd_mmc_info->card_type == CARD_TYPE_MMC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC)) && ( ret == SD_MMC_NO_ERROR))
 		{
 			/* There isn't any more device found */
 			break;        
 		}
-		else if(sd_mmc_info->card_type == CARD_TYPE_MMC)
+		else if((sd_mmc_info->card_type == CARD_TYPE_MMC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 		{
 			/* The RCA is returned in pc->LastResponse[4] */
 			slot_id += 1;
@@ -3069,27 +3020,31 @@
 	
 	if(sd_mmc_info->card_type == CARD_TYPE_SD || sd_mmc_info->card_type == CARD_TYPE_SDHC || sd_mmc_info->card_type == CARD_TYPE_SDIO)
 		sd_mmc_info->card_rca = ((SD_Response_R6_t *)response)->rca_high << 8 | ((SD_Response_R6_t *)response)->rca_low;
-	else if(sd_mmc_info->card_type == CARD_TYPE_MMC)
+	else if((sd_mmc_info->card_type == CARD_TYPE_MMC)  || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
 		sd_mmc_info->card_rca = slot_id;
 	
     if(sd_mmc_info->card_type == CARD_TYPE_SDIO)
     {
 #ifdef SD_MMC_HW_CONTROL
 	    if(SD_WORK_MODE == CARD_HW_MODE)
-		    ret = sd_send_cmd_hw(SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response, 0, 0, 1);
+		    ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	    if(SD_WORK_MODE == CARD_SW_MODE)
-		    ret = sd_send_cmd_sw(SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response);
+		    ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response);
 #endif
 
+		ret = sdio_read_reg(sd_mmc_info, 0, BUS_Interface_Control_REG, &read_reg_data);
+		if(ret)
+			return ret;
+
 		sd_mmc_info->operation_mode = DATA_TRANSFER_MODE;
-		write_reg_data = SDIO_Wide_bus_Bit;
-		ret = sdio_write_reg(0, BUS_Interface_Control_REG, &write_reg_data, SDIO_Read_After_Write);
+		write_reg_data = ((read_reg_data & 0xfc) | SDIO_Wide_bus_Bit);
+		ret = sdio_write_reg(sd_mmc_info, 0, BUS_Interface_Control_REG, &write_reg_data, SDIO_Read_After_Write);
 		if(ret)
 		{
 			write_reg_data = SDIO_Single_bus_Bit;
-    		ret = sdio_write_reg(0, BUS_Interface_Control_REG, &write_reg_data, SDIO_Read_After_Write);
+    		ret = sdio_write_reg(sd_mmc_info, 0, BUS_Interface_Control_REG, &write_reg_data, SDIO_Read_After_Write);
     		if(ret)
 				return ret;
 
@@ -3113,27 +3068,32 @@
 		}    
     }
 
-	ret = sd_read_reg_cid(&sd_mmc_info->raw_cid);
+	ret = sd_read_reg_cid(sd_mmc_info, &sd_mmc_info->raw_cid);
 	if(ret)
 		return ret;
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(SD_MMC_SEND_CSD, sd_mmc_info->card_rca<<16, RESPONSE_R2_CSD, response, 0, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SEND_CSD, sd_mmc_info->card_rca<<16, RESPONSE_R2_CSD, response, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		ret = sd_send_cmd_sw(SD_MMC_SEND_CSD, sd_mmc_info->card_rca<<16, RESPONSE_R2_CSD, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SEND_CSD, sd_mmc_info->card_rca<<16, RESPONSE_R2_CSD, response);
 #endif
 	if(ret)
+	{
+#ifdef  SD_MMC_DEBUG
+		Debug_Printf("#%s error occured at line: %d in file %s\n", sd_error_to_string(ret),__LINE__,__FILE__);
+#endif
 		return ret;
+	}
 	
 	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
 		sdhc_r2_csd = (SDHC_Response_R2_CSD_t *)response;
 	else
 	    r2_csd = (SD_Response_R2_CSD_t *)response;
 
-	if(sd_mmc_info->card_type == CARD_TYPE_MMC)
+	if((sd_mmc_info->card_type == CARD_TYPE_MMC) || (sd_mmc_info->card_type == CARD_TYPE_EMMC))
     	sd_mmc_info->mmc_spec_version = r2_csd->csd.MMC_SPEC_VERS;
 
 	if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
@@ -3166,26 +3126,44 @@
 		    sd_mmc_info->blk_len = 512;
 	    }
 	}
-	
+	if(sd_mmc_info->card_type == CARD_TYPE_EMMC)
+	{
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response, 0, 0, 1);
+		
+		ret = sd_send_cmd_hw(sd_mmc_info,MMC_SEND_EXT_CSD, 0, RESPONSE_R1, response, mmc_ext_csd_buf, sizeof(MMC_REG_EXT_CSD_t), 1);		
+        if(ret)
+            return ret;
+            
+        mmc_ext_csd_reg = (MMC_REG_EXT_CSD_t *)mmc_ext_csd_buf;
+        sd_mmc_info->blk_nums = *((unsigned *)&mmc_ext_csd_reg->SEC_COUNT);	
+        sd_mmc_info->blk_len = 512;
+        printk("sd_mmc_info->blk_nums : 0x%x \n",sd_mmc_info->blk_nums);
+	}
+
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response, 0, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		ret = sd_send_cmd_sw(SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SELECT_DESELECT_CARD, sd_mmc_info->card_rca<<16, RESPONSE_R1B, response);
 #endif
 
 	if(sd_mmc_info->card_type == CARD_TYPE_SD || sd_mmc_info->card_type == CARD_TYPE_SDHC)
 	{
 		SD_REG_SCR_t scr;
-		ret = sd_read_reg_scr(&scr);
+		ret = sd_read_reg_scr(sd_mmc_info, &scr);
 		if(ret)
+		{
+#ifdef  SD_MMC_DEBUG
+			Debug_Printf("#%s error occured at line: %d in file %s\n", sd_error_to_string(ret),__LINE__,__FILE__);
+#endif			
 			return ret;
+		}
 
 		sd_mmc_info->spec_version = scr.SD_SPEC;
 		
-		if(disable_wide_bus)
+		if(sd_mmc_info->disable_wide_bus)
 			scr.SD_BUS_WIDTHS = SD_BUS_SINGLE;
 			
 		if(!scr.SD_BUS_WIDTHS)
@@ -3196,15 +3174,15 @@
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
 			{
-				ret = sd_send_cmd_hw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, 0, 0, 1);
-				ret = sd_send_cmd_hw(SD_SET_BUS_WIDTHS, 2, RESPONSE_R1, response, 0, 0, 1); //0 1bit, 10=4bits
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, 0, 0, 1);
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_SET_BUS_WIDTHS, 2, RESPONSE_R1, response, 0, 0, 1); //0 1bit, 10=4bits
 			}
 #endif			
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
 			{
-				ret = sd_send_cmd_sw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
-				ret = sd_send_cmd_sw(SD_SET_BUS_WIDTHS, 2, RESPONSE_R1, response); //0 1bit, 10=4bits
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_SET_BUS_WIDTHS, 2, RESPONSE_R1, response); //0 1bit, 10=4bits
 			}
 #endif
 			if(ret)
@@ -3231,16 +3209,16 @@
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
 			{
-				ret = sd_send_cmd_hw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, 0, 0, 1);
-				ret = sd_send_cmd_hw(SD_SET_BUS_WIDTHS, 0, RESPONSE_R1, response, 0, 0, 1); //0 1bit, 10=4bits
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, 0, 0, 1);
+				ret = sd_send_cmd_hw(sd_mmc_info, SD_SET_BUS_WIDTHS, 0, RESPONSE_R1, response, 0, 0, 1); //0 1bit, 10=4bits
 			}
 #endif
 
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
 			{
-				ret = sd_send_cmd_sw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
-				ret = sd_send_cmd_sw(SD_SET_BUS_WIDTHS, 0, RESPONSE_R1, response); //0 1bit, 10=4bits
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
+				ret = sd_send_cmd_sw(sd_mmc_info, SD_SET_BUS_WIDTHS, 0, RESPONSE_R1, response); //0 1bit, 10=4bits
 			}
 #endif
 			
@@ -3254,13 +3232,13 @@
 #ifdef SD_MMC_HW_CONTROL
             if(SD_WORK_MODE == CARD_HW_MODE)
             {
-                ret = sd_send_cmd_hw(MMC_SWITCH_FUNTION, 0x03b70100, RESPONSE_R1, response, 0, 0, 1);
+                ret = sd_send_cmd_hw(sd_mmc_info, MMC_SWITCH_FUNTION, 0x03b70100, RESPONSE_R1, response, 0, 0, 1);
             }
 #endif			
 #ifdef SD_MMC_SW_CONTROL
             if(SD_WORK_MODE == CARD_SW_MODE)
             {
-                ret = sd_send_cmd_sw(MMC_SWITCH_FUNTION, 0x03b70100, RESPONSE_R1, response);
+                ret = sd_send_cmd_sw(sd_mmc_info, MMC_SWITCH_FUNTION, 0x03b70100, RESPONSE_R1, response);
             }
 #endif
             if(ret)
@@ -3294,14 +3272,15 @@
 		unsigned long sdio_config = 0;
 		SDIO_Config_Reg_t *config_reg = (void *)&sdio_config;
 		sdio_config = READ_CBUS_REG(SDIO_CONFIG);
-		if(disable_high_speed == 1)
+		if(sd_mmc_info->disable_high_speed == 1)
 		{
 			config_reg->cmd_clk_divide = 4;
 			sd_mmc_info->sdio_clk_unit = 1000/SD_MMC_TRANSFER_SLOWER_CLK;
 		}
 		else
 		{
-			config_reg->cmd_clk_divide = 3;
+			//config_reg->cmd_clk_divide = 3;
+			config_reg->cmd_clk_divide = 4;
 			sd_mmc_info->sdio_clk_unit = 1000/SD_MMC_TRANSFER_CLK;
 		}
 
@@ -3311,34 +3290,36 @@
 
 	sd_mmc_info->operation_mode = DATA_TRANSFER_MODE;
 	
-	sd_mmc_check_wp();
+	sd_mmc_check_wp(sd_mmc_info);
 
 	return SD_MMC_NO_ERROR;
 }
 
-int sd_mmc_init(void)
+int sd_mmc_init(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int error;
 	
-	sd_save_hw_io_config = 0;
-	sd_save_hw_io_mult_config = 0;
-	sd_save_hw_reg_flag = 0;
-		
+	
+	/*close IF INT before change to sd to avoid error IF INT*/
+	sdio_close_host_interrupt(SDIO_IF_INT);
+	WRITE_CBUS_REG(SDIO_CONFIG, 0);
+	WRITE_CBUS_REG(SDIO_MULT_CONFIG, 0);
+
 	if(sd_mmc_info->inited_flag && !sd_mmc_info->removed_flag)
 	{
 #ifdef SD_MMC_HW_CONTROL
 	    if(SD_WORK_MODE == CARD_HW_MODE)
-		    sd_sdio_enable();
+		    sd_sdio_enable(sd_mmc_info->io_pad_type);
 #endif
 #ifdef SD_MMC_SW_CONTROL
 	    if(SD_WORK_MODE == CARD_SW_MODE)
 	    {	
-		    sd_gpio_enable();
+		    sd_gpio_enable(sd_mmc_info->io_pad_type);
 	    }
 #endif		
-			error = sd_mmc_cmd_test();
+			error = sd_mmc_cmd_test(sd_mmc_info);
 			if(!error)
-				return error;
+				goto error;
 	}
 	if(++sd_mmc_info->init_retry > SD_MMC_INIT_RETRY)
 		return SD_MMC_ERROR_DRIVER_FAILURE;
@@ -3347,58 +3328,54 @@
 	Debug_Printf("\nSD/MMC initialization started......\n");
 #endif
 	
-	error = sd_mmc_staff_init();
+	error = sd_mmc_staff_init(sd_mmc_info);
+	
 	if(error)
 	{
 #ifdef  SD_MMC_DEBUG
 		Debug_Printf("#%s error occured in sd_mmc_staff_init()()\n", sd_error_to_string(error));
 #endif
-		return error;
+		goto error;
 	}
-	
-	error = sd_hw_reset();
+	sd_mmc_set_input(sd_mmc_info);
+	error = sd_hw_reset(sd_mmc_info);
 	if(error)
 	{
 #ifdef  SD_MMC_DEBUG
 		Debug_Printf("#%s error occured in sd_hw_reset()\n", sd_error_to_string(error));
 #endif
-		return error;
+		goto error;
 	}
 
-	error = sd_voltage_validation();
+	error = sd_voltage_validation(sd_mmc_info);
+	
 	if(error)
 	{
 #ifdef  SD_MMC_DEBUG
 		Debug_Printf("#%s error occured in sd_voltage_validation()\n", sd_error_to_string(error));
 #endif
-		return error;
+		goto error;
 	}
 
-	cr_mon.card_in_event_status[CARD_SECURE_DIGITAL] = CARD_EVENT_INSERTED;
-	//AVSysEvent_Post(EV_DRV_DEVCARD_DETECT_IN);
-	
-	error = sd_identify_process();
+	error = sd_identify_process(sd_mmc_info);
 	if(error)
 	{
 #ifdef  SD_MMC_DEBUG
 		Debug_Printf("#%s error occured in sd_identify_process()\n", sd_error_to_string(error));
 #endif
-		return error;
+		goto error;
 	}
 	
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-	{  	if(!disable_high_speed)	
 		{
-	    	error = sd_mmc_switch_function();
+		if(!sd_mmc_info->disable_high_speed)	
+		{
+	    	error = sd_mmc_switch_function(sd_mmc_info);
 	    	if(error)
 	    	{
 #ifdef  SD_MMC_DEBUG
 		    	Debug_Printf("#%s error occured in sd_switch_funtion()\n", sd_error_to_string(error));
-		    	Debug_Printf("#### CARD_TYPE_SDIO         == %d\n", CARD_TYPE_SDIO);
-		    	Debug_Printf("#### sd_mmc_info->card_type == %d\n", sd_mmc_info->card_type);
-		    	Debug_Printf("#### HIGH_SPEED               == %d\n", HIGH_SPEED);
-		    	Debug_Printf("#### sd_mmc_info->speed_class == %d\n", sd_mmc_info->speed_class);
 #endif
 			//return error;
 	    	}
@@ -3408,23 +3385,23 @@
 
 	if(sd_mmc_info->card_type == CARD_TYPE_SDIO)
 	{
-		error = sd_check_sdio_card_type();
+		error = sd_check_sdio_card_type(sd_mmc_info);
 		if(error)
 	    {
 #ifdef  SD_MMC_DEBUG
-		    Debug_Printf("#%s error occured in sd_switch_funtion()\n", sd_error_to_string(error));
+		    Debug_Printf("#%s error occured in sd_check_sdio_card_type()\n", sd_error_to_string(error));
 #endif
-			return error;
+			goto error;
 	    }
 	}
 
-//	error = sd_check_data_consistency();
+//	error = sd_check_data_consistency(sd_mmc_info);
 //	if(error)
 //	{
 //#ifdef  SD_MMC_DEBUG
 //		Debug_Printf("#%s error occured in sd_check_data_consistency()!\n", sd_error_to_string(error));
 //#endif
-//		return error;
+//		goto error;
 //	}
 
 #ifdef SD_MMC_DEBUG
@@ -3481,23 +3458,27 @@
 	}
 #endif
 
+/*	if (sd_mmc_info->card_type == CARD_TYPE_EMMC)
+		emmc_test_upgrade(); */
+	
 	sd_mmc_info->inited_flag = 1;
 	sd_mmc_info->init_retry = 0;
 
-	sd_save_hw_io_config = READ_CBUS_REG(SDIO_CONFIG);
-	sd_save_hw_io_mult_config = READ_CBUS_REG(SDIO_MULT_CONFIG);
-	sd_save_hw_reg_flag = 1;
-		
-	cr_mon.blk_length[CARD_SECURE_DIGITAL] = 512;
-	cr_mon.capacity[CARD_SECURE_DIGITAL] = sd_mmc_info->blk_nums;
-	memcpy(&cr_mon.raw_cid[CARD_SECURE_DIGITAL][0], &(sd_mmc_info->raw_cid), sizeof(sd_mmc_info->raw_cid));
+	sd_mmc_info->sd_save_hw_io_flag = 1;
+	sd_mmc_info->sd_save_hw_io_config = READ_CBUS_REG(SDIO_CONFIG);
+	sd_mmc_info->sd_save_hw_io_mult_config = READ_CBUS_REG(SDIO_MULT_CONFIG);
+	sd_gpio_enable(sd_mmc_info->io_pad_type);
 
 	return SD_MMC_NO_ERROR;
+
+error:
+	sd_gpio_enable(sd_mmc_info->io_pad_type);
+	return error;
 }
 
-void sd_mmc_io_config()
+void sd_mmc_io_config(SD_MMC_Card_Info_t *sd_mmc_info)
 {
-	sd_gpio_enable();
+	sd_gpio_enable(sd_mmc_info->io_pad_type);
 	
 	sd_set_cmd_output();
 	sd_set_cmd_value(1);
@@ -3506,37 +3487,14 @@
 	sd_set_dat0_3_input();
 }
 
-int sd_mmc_staff_init()
+int sd_mmc_staff_init(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	unsigned int sdio_config, sdio_multi_config;
 	SDIO_Config_Reg_t *config_reg;
-#ifdef SD_MMC_ALLOC_MEMORY
-	if(sd_mmc_buf == NULL)
-	{
-	    /*_phymem_node_t *memmap = Am_GetSystemMem(MEMMAP_DEFAULT, MEMITEM_DMA_DRAM);
-        if(memmap != NULL && (memmap->end - memmap->start + 1)/512)
-        {
-            sd_mmc_buf = (void *)(memmap->start);
-            sd_mmc_buf_size = memmap->end - memmap->start + 1;
-            sd_mmc_buf_from_sys = 1;
-            memset(sd_mmc_buf, 0, sd_mmc_buf_size);
-        }
-        else
-        {*/
-		    //sd_mmc_phy_buf = (dma_addr_t *)sd_mmc_malloc(SD_MMC_BUFFER_SIZE, GFP_KERNEL);
-		    sd_mmc_buf = dma_alloc_coherent(NULL, SD_MMC_BUFFER_SIZE, (dma_addr_t *)&sd_mmc_phy_buf, GFP_KERNEL);
-		    if(sd_mmc_buf == NULL)
-			    return SD_MMC_ERROR_NO_MEMORY;
-			sd_mmc_buf_size = SD_MMC_BUFFER_SIZE;
-			sd_mmc_buf_from_sys = 0;
-		    memset(sd_mmc_buf, 0, sd_mmc_buf_size);
-	    //}
-	}
-#endif
 
-    sd_mmc_prepare_power();
-	sd_mmc_power_on();
-	
+    sd_mmc_prepare_power(sd_mmc_info);
+   
+	sd_mmc_power_on(sd_mmc_info);
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
 	{
@@ -3553,12 +3511,12 @@
 		WRITE_CBUS_REG(SDIO_CONFIG, sdio_config);
 		sd_mmc_info->sdio_clk_unit = (1000/SD_MMC_IDENTIFY_CLK)*1000;
 
-		sd_sdio_enable();
+		sd_sdio_enable(sd_mmc_info->io_pad_type);
 	}
 #endif
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		sd_mmc_io_config();
+		sd_mmc_io_config(sd_mmc_info);
 #endif
 
 	sd_mmc_info->card_type = CARD_TYPE_NONE;
@@ -3584,9 +3542,9 @@
 }
 
 //Read Operation Conditions Register
-int sd_read_reg_ocr(SD_REG_OCR_t * ocr);
+int sd_read_reg_ocr(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_OCR_t * ocr);
 //Read Card_Identification Register
-int sd_read_reg_cid(SD_REG_CID_t * cid)
+int sd_read_reg_cid(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_CID_t * cid)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
@@ -3596,7 +3554,7 @@
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
 	{
-		ret = sd_send_cmd_hw(SD_MMC_SEND_CID, sd_mmc_info->card_rca<<16, RESPONSE_R2_CID, response, NULL, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_MMC_SEND_CID, sd_mmc_info->card_rca<<16, RESPONSE_R2_CID, response, NULL, 0, 1);
 		if(ret)
 			return ret;
 		memcpy(cid, response, sizeof(SD_REG_CID_t));
@@ -3606,7 +3564,7 @@
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
 	{
-		ret = sd_send_cmd_sw(SD_MMC_SEND_CID,sd_mmc_info->card_rca<<16, RESPONSE_R2_CID, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SEND_CID,sd_mmc_info->card_rca<<16, RESPONSE_R2_CID, response);
 		if(ret)
 			return ret;
 		memcpy(cid, response, sizeof(SD_REG_CID_t));
@@ -3617,13 +3575,13 @@
 }
 
 //Read Card-Specific Data Register
-int sd_read_reg_csd(SD_REG_CSD_t * csd);
+int sd_read_reg_csd(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_CSD_t * csd);
 //Read Relative Card Address Register
-int sd_read_reg_rca(unsigned short * rca);
+int sd_read_reg_rca(SD_MMC_Card_Info_t *sd_mmc_info, unsigned short * rca);
 //Read Driver Stage Register
-int sd_read_reg_dsr(SD_REG_DSR_t * dsr);
+int sd_read_reg_dsr(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_DSR_t * dsr);
 //Read SD CARD Configuration Register
-int sd_read_reg_scr(SD_REG_SCR_t * scr)
+int sd_read_reg_scr(SD_MMC_Card_Info_t *sd_mmc_info, SD_REG_SCR_t * scr)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
@@ -3636,28 +3594,28 @@
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
 	{
-		ret = sd_send_cmd_hw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, 0, 0, 1);   
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response, 0, 0, 1);   
 		 if(ret)
 			return ret;
 		
-		ret = sd_send_cmd_hw(SD_SEND_SCR, 0, RESPONSE_R1, response, sd_mmc_buf, sizeof(SD_REG_SCR_t), 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_SEND_SCR, 0, RESPONSE_R1, response, sd_mmc_info->sd_mmc_buf, sizeof(SD_REG_SCR_t), 1);
 		if(ret)
 			return ret;
-		memcpy(scr, sd_mmc_buf, sizeof(SD_REG_SCR_t));
+		memcpy(scr, sd_mmc_info->sd_mmc_buf, sizeof(SD_REG_SCR_t));
 	}
 #endif		
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
 	{
-		ret = sd_send_cmd_sw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);   
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);   
 		if(ret)
 			return ret;
 	
-		ret = sd_send_cmd_sw(SD_SEND_SCR, 0, RESPONSE_NONE, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_SEND_SCR, 0, RESPONSE_NONE, response);
 		if(ret)
 			return ret;
 
-		ret = sd_get_dat0_data(sizeof(SD_REG_SCR_t), (unsigned char *)scr, &crc16);
+		ret = sd_get_dat0_data(sd_mmc_info, sizeof(SD_REG_SCR_t), (unsigned char *)scr, &crc16);
 		   if(ret)
 			return ret;
 	}
@@ -3668,7 +3626,7 @@
 
 //Check if any card is connected to adapter
 #ifdef SD_MMC_SW_CONTROL
-SD_Card_Type_t sd_mmc_check_present()
+SD_Card_Type_t sd_mmc_check_present(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int retry, ret;
 	
@@ -3678,23 +3636,23 @@
 	//Detect if SD card is inserted first
 	for(retry = 0; retry < MAX_CHECK_INSERT_RETRY; retry++)
 	{
-		ret = sd_send_cmd_sw(SD_APP_CMD, 0, RESPONSE_R1, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, 0, RESPONSE_R1, response);
 		if(ret)
 			continue;
 
-		ret = sd_send_cmd_sw(SD_APP_OP_COND, 0x00200000, RESPONSE_R3, response);   // 0x00200000: 3.3v~3.4v
+		ret = sd_send_cmd_sw(sd_mmc_info, SD_APP_OP_COND, 0x00200000, RESPONSE_R3, response);   // 0x00200000: 3.3v~3.4v
 		r3 = (SD_Response_R3_t *)response;
 		
 		if((ret == SD_MMC_NO_ERROR) && r3->ocr.Card_Busy)
 			return CARD_TYPE_SD;
 	} 
 	
-	sd_sw_reset();
+	sd_sw_reset(sd_mmc_info);
 	
 	//No SD card, detect if MMC card is inserted then
 	for(retry = 0; retry < MAX_CHECK_INSERT_RETRY; retry++)
 	{
-		ret = sd_send_cmd_sw(MMC_SEND_OP_COND, 0x00200000, RESPONSE_R3, response); // 0x00200000: 3.3v~3.4v
+		ret = sd_send_cmd_sw(sd_mmc_info, MMC_SEND_OP_COND, 0x00200000, RESPONSE_R3, response); // 0x00200000: 3.3v~3.4v
 		r3 = (SD_Response_R3_t *)response;
 		
 		if((ret == SD_MMC_NO_ERROR) && r3->ocr.Card_Busy)
@@ -3705,7 +3663,7 @@
 }
 #endif
 //Check if any card is inserted according to pull up resistor
-int sd_mmc_check_insert()
+int sd_mmc_check_insert(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int level;
 	
@@ -3723,17 +3681,16 @@
 	{
 		if(sd_mmc_info->init_retry)
 		{
-			sd_mmc_power_off();
+			sd_mmc_power_off(sd_mmc_info);
 			sd_mmc_info->init_retry = 0;
 		}
-			
 		if(sd_mmc_info->inited_flag)
 		{
-			sd_mmc_power_off();
+			sd_mmc_power_off(sd_mmc_info);
 			sd_mmc_info->removed_flag = 1;
 			sd_mmc_info->inited_flag = 0;
 		}
-			
+
 		return 0;       //No card is inserted
 	}
 	else
@@ -3742,22 +3699,62 @@
 	}
 }
 
+/*
+int sd_mmc_access_boot_area(unsigned partition_num)
+{
+	int ret = 0;
+	unsigned cmd_argument;
+	unsigned char response[MAX_RESPONSE_BYTES];
+	unsigned char mmc_ext_csd_buf[512];
+	MMC_REG_EXT_CSD_t *mmc_ext_csd_reg;
+
+	if (!sd_mmc_info->emmc_boot_support)
+		return SD_ERROR_SWITCH_FUNCTION_COMUNICATION;
+
+	if (partition_num == 2)
+		cmd_argument = 0x03b31200;
+	else if (partition_num == 1)
+		cmd_argument = 0x03b30900;
+	else
+		cmd_argument = 0x03b30000;
+    if(sd_mmc_info->mmc_spec_version == SPEC_VERSION_40_41)
+    {
+    	sd_delay_ms(2);
+        ret = sd_send_cmd_hw(MMC_SWITCH_FUNTION, cmd_argument, RESPONSE_R1, response, 0, 0, 1);
+        if(ret)
+            return ret;
+
+        sd_delay_ms(2);
+        ret = sd_send_cmd_hw(MMC_SEND_EXT_CSD, 0, RESPONSE_R1, response, mmc_ext_csd_buf, sizeof(MMC_REG_EXT_CSD_t), 1);
+        if(ret)
+            return ret;
+        mmc_ext_csd_reg = (MMC_REG_EXT_CSD_t *)mmc_ext_csd_buf;
+        if (!mmc_ext_csd_reg->PARTITION_CONFIG)
+        	return SD_ERROR_SWITCH_FUNCTION_COMUNICATION;
+    }
+
+	return SD_MMC_NO_ERROR;
+}*/
+
 //Read data from SD/MMC card
-int sd_mmc_read_data(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int sd_mmc_read_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error = 0;
 	unsigned long lba_nums;
 
-	if(cr_mon.card_status[CARD_SECURE_DIGITAL] != CARD_INSERTED)
-		return SD_MMC_ERROR_NO_CARD_INS;
-
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-    		sd_sdio_enable();
+	{
+		//sd_sdio_enable(sd_mmc_info->io_pad_type);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+	    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+	      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
+	    	}		
+	}
 #endif       
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-	   		sd_mmc_io_config();
+	   	sd_mmc_io_config(sd_mmc_info);
 #endif
 
 	lba_nums = sd_mmc_info->blk_len;
@@ -3774,11 +3771,11 @@
 	{
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			error = sd_read_single_block_hw(lba, data_buf);
+			error = sd_read_single_block_hw(sd_mmc_info, lba, data_buf);
 #endif 
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-					error = sd_read_single_block_sw(lba, data_buf);
+					error = sd_read_single_block_sw(sd_mmc_info, lba, data_buf);
 #endif 		
 		if(error)
 		{			
@@ -3793,14 +3790,14 @@
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
 		{
-			error = sd_read_multi_block_hw(lba, lba_nums, data_buf);
+			error = sd_read_multi_block_hw(sd_mmc_info, lba, lba_nums, data_buf);
 			if(error)
-				error = sd_read_multi_block_hw(lba, lba_nums, data_buf);
+				error = sd_read_multi_block_hw(sd_mmc_info, lba, lba_nums, data_buf);
 		}
 #endif 
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			error = sd_read_multi_block_sw(lba, lba_nums, data_buf);
+			error = sd_read_multi_block_sw(sd_mmc_info, lba, lba_nums, data_buf);
 #endif		
 
 		if(error)
@@ -3816,14 +3813,11 @@
 }
 
 //Write data to SD/MMC card
-int sd_mmc_write_data(unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
+int sd_mmc_write_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long byte_cnt, unsigned char * data_buf)
 {
 	int error = 0;
 	unsigned long lba_nums;
 
-	if(cr_mon.card_status[CARD_SECURE_DIGITAL] != CARD_INSERTED)
-		return SD_MMC_ERROR_NO_CARD_INS;
-
 	if(sd_mmc_info->write_protected_flag)
 	{
 		error = SD_MMC_ERROR_WRITE_PROTECTED;
@@ -3835,11 +3829,17 @@
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-        sd_sdio_enable();
+	{
+		//sd_sdio_enable(sd_mmc_info->io_pad_type);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
+    	}		
+	}
 #endif        	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)    	    
-       	sd_mmc_io_config();	  	
+       	sd_mmc_io_config(sd_mmc_info);	  	
 #endif
 
 	//memcpy(sd_write_buf, data_buf, byte_cnt);
@@ -3857,11 +3857,11 @@
 	{
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			error = sd_write_single_block_hw(lba, data_buf);
+			error = sd_write_single_block_hw(sd_mmc_info, lba, data_buf);
 #endif 
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			error = sd_write_single_block_sw(lba, data_buf);
+			error = sd_write_single_block_sw(sd_mmc_info, lba, data_buf);
 #endif		
 		if(error)
 		{
@@ -3875,11 +3875,11 @@
 	{
 #ifdef SD_MMC_HW_CONTROL
 		if(SD_WORK_MODE == CARD_HW_MODE)
-			error = sd_write_multi_block_hw(lba, lba_nums, data_buf);
+			error = sd_write_multi_block_hw(sd_mmc_info, lba, lba_nums, data_buf);
 #endif 
 #ifdef SD_MMC_SW_CONTROL
 		if(SD_WORK_MODE == CARD_SW_MODE)
-			error = sd_write_multi_block_sw(lba, lba_nums, data_buf);
+			error = sd_write_multi_block_sw(sd_mmc_info, lba, lba_nums, data_buf);
 #endif		
 		if(error)
 		{
@@ -3894,28 +3894,26 @@
 }
 
 #ifdef SD_MMC_SW_CONTROL
-int sd_mmc_cmd_test()
+int sd_mmc_cmd_test(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
 
 	sd_clear_response(response);
 	
-	sd_mmc_io_config();
+	sd_mmc_io_config(sd_mmc_info);
 	
-	ret = sd_send_cmd_sw(SD_MMC_SEND_STATUS, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);   
+	ret = sd_send_cmd_sw(sd_mmc_info, SD_MMC_SEND_STATUS, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);   
 	
 	return ret;
 }
 #endif 
 
-void sd_mmc_power_on()
+void sd_mmc_power_on(SD_MMC_Card_Info_t *sd_mmc_info)
 {
-	sd_delay_ms(sd_mmc_power_delay+1);
+	sd_delay_ms(sd_mmc_info->sd_mmc_power_delay+1);
 	
 #ifdef SD_MMC_POWER_CONTROL
-	//if(card_share_ins_pwr_flag[CARD_MODULE_SD_MMC])
-		//card_power_off_flag[CARD_SECURE_DIGITAL] = 1;
 
 	if(sd_mmc_info->sd_mmc_power)
 	{
@@ -3925,32 +3923,29 @@
 	{
 		sd_set_disable();
 	}
-	sd_delay_ms(10);
+	sd_delay_ms(200);
 
 	if(sd_mmc_info->sd_mmc_power)
 	{
-		if(sd_mmc_check_insert()) //ensure card wasn't removed at this time 
+		if(sd_mmc_check_insert(sd_mmc_info)) //ensure card wasn't removed at this time 
 		{
 			sd_mmc_info->sd_mmc_power(1);
 		}
 	}
 	else
 	{
-		if(sd_mmc_check_insert()) //ensure card wasn't removed at this time 
+		if(sd_mmc_check_insert(sd_mmc_info)) //ensure card wasn't removed at this time 
 		{
 			sd_set_enable();
 		}
 	}
-	sd_delay_ms(10);
+	sd_delay_ms(200);
 #else
 	sd_delay_ms(10);
 #endif
-
-	//if(card_share_ins_pwr_flag[CARD_MODULE_SD_MMC])
-		//card_power_off_flag[CARD_SECURE_DIGITAL] = 0;
 }
 
-void sd_mmc_power_off()
+void sd_mmc_power_off(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 #ifdef SD_MMC_POWER_CONTROL
 	if(sd_mmc_info->sd_mmc_power)
@@ -3965,7 +3960,7 @@
 }
 
 //Check if Write-Protected switch is on
-int sd_mmc_check_wp()
+int sd_mmc_check_wp(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 #ifdef SD_MMC_WP_CHECK
 	int ret = 0;
@@ -3995,15 +3990,64 @@
 #endif
 }
 
+/*
+#define SPI_DEV "/dev/mtd0"
+int emmc_test_upgrade(void)
+{
+	int i = 0, fd, error, read_count;
+	unsigned char *emmc_wite_buf;
+	unsigned char *emmc_read_buf;
+	emmc_wite_buf = (unsigned char *)sd_mmc_malloc(8192, GFP_KERNEL);
+	emmc_read_buf = (unsigned char *)sd_mmc_malloc(8192, GFP_KERNEL);
+	if ((!emmc_wite_buf) || (!emmc_read_buf))
+		return -1;
+
+    error = sd_mmc_access_boot_area(0);
+    if (error)
+    	printk("emmc access_boot_area error\n");
+    error = sd_mmc_read_data(0, sd_mmc_info->blk_len*8, emmc_wite_buf);
+	if (error)
+		return error;
+	fd = sys_open(SPI_DEV, O_RDWR, 0);
+	if (fd < 0) {
+		printk("spi open error\n");
+		return -1;
+	}
+	for (i=0; i<0x50000; i+=8192)
+	{
+		error = sys_lseek(fd, i, 0);
+		read_count = sys_read(fd, emmc_wite_buf, 8192);
+		if (read_count != 8192)
+			return -1;
+
+		error = sd_mmc_write_data(i/512, 8192, emmc_wite_buf);
+		if (error)
+			return error;
+	    error = sd_mmc_read_data(i/512, 8192, emmc_read_buf);
+	    if (error)
+		    return error;
+		if(memcmp(emmc_wite_buf, emmc_read_buf, 8192))
+			printk("emmc upgrade error at addr %x \n", i);
+	}
+	sd_mmc_access_boot_area(0);
+	sd_mmc_free(emmc_wite_buf);
+	sd_mmc_free(emmc_read_buf);
+	printk("emmc upgrade completely\n");
+
+	return SD_MMC_NO_ERROR;
+} */
+
 //check data lines consistency
-int sd_check_data_consistency(void)
+int sd_check_data_consistency(SD_MMC_Card_Info_t *sd_mmc_info)
 {
-	int error;
+	int error, func_num=0;
+	unsigned char read_reg_data;
+	unsigned read_addr, sdio_cis_addr;
 #ifdef SD_MMC_SW_CONTROL
 	unsigned char response[MAX_RESPONSE_BYTES];
 #endif
 	
-	unsigned char mbr_buf[sd_mmc_info->blk_len*2];
+	unsigned char *mbr_buf = sd_mmc_info->sd_mmc_buf;
 
 	//This card is working in wide bus mode!
 	memset(mbr_buf, 0, sd_mmc_info->blk_len);
@@ -4011,28 +4055,38 @@
 	{
 		if(sd_mmc_info->card_type == CARD_TYPE_SDIO)
 		{
-			mbr_buf[0] = 0x55;
-			mbr_buf[1] = 0xaa;
-			error = sdio_write_data(1, 1, 0x462, 4, mbr_buf);
+			for (func_num=0; func_num<sd_mmc_info->sdio_function_nums; func_num++) {
+
+				read_addr = ((func_num << 8) | Common_CIS_Pointer3_REG);
+				error = sdio_read_reg(sd_mmc_info, 0, read_addr, &read_reg_data);
 			if(error)
 				return error;
+				sdio_cis_addr = read_reg_data;
 
-			memset(mbr_buf, 0, 4);
-			error = sdio_read_data(1, 1, 0x462, 4, mbr_buf);
+				read_addr = ((func_num << 8) | Common_CIS_Pointer2_REG);
+				error = sdio_read_reg(sd_mmc_info, 0, read_addr, &read_reg_data);
 			if(error)
 				return error;
+				sdio_cis_addr = ((sdio_cis_addr << 8) | read_reg_data);
 
-			if((mbr_buf[0] != 0x55) || (mbr_buf[1] != 0xaa))
-				return SD_MMC_ERROR_DRIVER_FAILURE;
+				read_addr = ((func_num << 8) | Common_CIS_Pointer1_REG);
+				error = sdio_read_reg(sd_mmc_info, 0, read_addr, &read_reg_data);
+				if (error)
+					return error;
+				sdio_cis_addr = ((sdio_cis_addr << 8) | read_reg_data);
+				sd_mmc_info->sdio_cis_addr[func_num] = sdio_cis_addr;
+				//printk("sdio cis addr is %x \n", sdio_cis_addr);
+
+			}
 
 			return SD_MMC_NO_ERROR;
 		}
 		//read MBR information
-		error = sd_mmc_read_data(0, sd_mmc_info->blk_len, mbr_buf);
+		error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len, mbr_buf);
 		if(error)
 		{
 			//error! retry again!
-			error = sd_mmc_read_data(0, sd_mmc_info->blk_len, mbr_buf);
+			error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len, mbr_buf);
 			if(error)
 				return error;
 		}
@@ -4041,7 +4095,7 @@
 		if((mbr_buf[510] != 0x55) || (mbr_buf[511] != 0xAA))
 		{
 			//data consistency error! retry again!
-			error = sd_mmc_read_data(0, sd_mmc_info->blk_len*2, mbr_buf);
+			error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len*2, mbr_buf);
 			if(error)
 				return error;
 
@@ -4056,10 +4110,10 @@
 #ifdef SD_MMC_SW_CONTROL
 				if(SD_WORK_MODE == CARD_SW_MODE)	
 				{				
-					error = sd_send_cmd_sw(SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
+					error = sd_send_cmd_sw(sd_mmc_info, SD_APP_CMD, sd_mmc_info->card_rca<<16, RESPONSE_R1, response);
 					if(error)
 						return error;
-					error = sd_send_cmd_sw(SD_SET_BUS_WIDTHS, 0, RESPONSE_R1, response); //0 1bit, 10=4bits
+					error = sd_send_cmd_sw(sd_mmc_info, SD_SET_BUS_WIDTHS, 0, RESPONSE_R1, response); //0 1bit, 10=4bits
 					if(error)
 						return error;
 				}
@@ -4092,13 +4146,13 @@
 	//This card is working in single bus mode!
 	memset(mbr_buf, 0, sd_mmc_info->blk_len);
 	//read MBR information
-	error = sd_mmc_read_data(0, sd_mmc_info->blk_len, mbr_buf);
+	error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len, mbr_buf);
 	//For Kingston MMC mobile card
-	error = sd_mmc_read_data(0, sd_mmc_info->blk_len, mbr_buf);
+	error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len, mbr_buf);
 	if(error)
 	{
 		//error! retry again!
-		error = sd_mmc_read_data(0, sd_mmc_info->blk_len, mbr_buf);
+		error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len, mbr_buf);
 		if(error)
 			return error;
 	}
@@ -4107,7 +4161,7 @@
 	if((mbr_buf[510] != 0x55) || (mbr_buf[511] != 0xAA))
 	{
 		//data consistency error! retry again!
-		error = sd_mmc_read_data(0, sd_mmc_info->blk_len*2, mbr_buf);
+		error = sd_mmc_read_data(sd_mmc_info, 0, sd_mmc_info->blk_len*2, mbr_buf);
 		if(error)
 			return error;
 
@@ -4125,24 +4179,24 @@
 	return SD_MMC_NO_ERROR;
 }
 
-void sd_mmc_exit(void)
+void sd_mmc_exit(SD_MMC_Card_Info_t *sd_mmc_info)
 {
-	read_multi_block_failed = 0;
-	write_multi_block_failed = 0;
 	if(sd_mmc_info->sd_mmc_io_release != NULL)
 		sd_mmc_info->sd_mmc_io_release();
-	
-#ifdef SD_MMC_ALLOC_MEMORY
-	if(sd_mmc_phy_buf != NULL)
-	{
-	   dma_free_coherent(NULL, SD_MMC_BUFFER_SIZE, sd_mmc_buf, (dma_addr_t )sd_mmc_phy_buf);
-	   sd_mmc_phy_buf = NULL;
-	   sd_mmc_buf = NULL;
-	}
-#endif	
+
+	if(sd_mmc_info->card_type == CARD_TYPE_SD)
+		Debug_Printf("SD card unpluged!\n\n");
+	else if(sd_mmc_info->card_type == CARD_TYPE_SDHC)
+		Debug_Printf("SDHC card unpluged!\n\n");
+	else if(sd_mmc_info->card_type == CARD_TYPE_SDIO)
+		Debug_Printf("SDIO card unpluged!\n\n");
+	else
+		Debug_Printf("MMC card unpluged!\n\n");
+
+	return;
 }
 
-void sd_mmc_prepare_init(void)
+void sd_mmc_prepare_init(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	if(sd_mmc_power_register != NULL)
 		sd_mmc_info->sd_mmc_power = sd_mmc_power_register;
@@ -4154,10 +4208,10 @@
 		sd_mmc_info->sd_mmc_io_release = sd_mmc_io_release_register;
 }
 
-void sd_mmc_prepare_power(void)
+void sd_mmc_prepare_power(SD_MMC_Card_Info_t *sd_mmc_info)
 {
-    sd_gpio_enable();
-    
+    sd_gpio_enable(sd_mmc_info->io_pad_type);
+
 	sd_set_cmd_output();
 	sd_set_cmd_value(0);
 	sd_set_clk_output();
@@ -4166,22 +4220,31 @@
 	sd_set_dat0_3_value(0);
 }
 
-int sd_mmc_switch_function(void)
+void sd_mmc_set_input(SD_MMC_Card_Info_t *sd_mmc_info)
+{
+	sd_set_cmd_input();
+	sd_set_clk_input();
+	sd_set_dat0_3_input();
+}
+
+int sd_mmc_switch_function(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
-	unsigned char *status_data_buf = sd_mmc_buf;
+	unsigned char *status_data_buf = sd_mmc_info->sd_mmc_buf;
+	unsigned char *mmc_ext_csd_buf = sd_mmc_info->sd_mmc_buf;
 	SD_Switch_Function_Status_t *switch_funtion_status;
-
+	MMC_REG_EXT_CSD_t *mmc_ext_csd_reg;
+	int i;
 	unsigned char read_reg_data;
 	unsigned char write_reg_data;
 	unsigned long sdio_config = 0;
-	SDIO_Config_Reg_t *config_reg;
+	SDIO_Config_Reg_t *config_reg = NULL;
 
 	if(sd_mmc_info->spec_version || sd_mmc_info->card_type == CARD_TYPE_SDHC)
 	{    
 	    memset(status_data_buf, 0, 64);
-		ret = sd_send_cmd_hw(SD_SWITCH_FUNCTION, 0x00FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, SD_SWITCH_FUNCTION, 0x00FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);
 	    if(ret)
 		    return ret;
 
@@ -4196,7 +4259,7 @@
 	    else	
 	    {
 		    memset(status_data_buf, 0, 64);
-			ret = sd_send_cmd_hw(SD_SWITCH_FUNCTION, 0x80FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);	
+			ret = sd_send_cmd_hw(sd_mmc_info, SD_SWITCH_FUNCTION, 0x80FFFF01, RESPONSE_R1, response, status_data_buf, 64, 1);	
 		    if(ret)
 			    return ret;
 
@@ -4214,9 +4277,21 @@
             sd_mmc_info->speed_class = HIGH_SPEED;		
 	    }
 	}
-    else if(sd_mmc_info->mmc_spec_version == SPEC_VERSION_40_41 && sd_mmc_info->card_type == CARD_TYPE_MMC)
+    else if(sd_mmc_info->mmc_spec_version == SPEC_VERSION_40_41)
     {
-        ret = sd_send_cmd_hw(MMC_SWITCH_FUNTION, 0x03b90100, RESPONSE_R1, response, 0, 0, 1);
+    	sd_delay_ms(2);	  
+    	 
+        ret = sd_send_cmd_hw(sd_mmc_info,MMC_SEND_EXT_CSD, 0, RESPONSE_R1, response, mmc_ext_csd_buf, sizeof(MMC_REG_EXT_CSD_t), 1);
+        if(ret)
+            return ret;
+            
+        mmc_ext_csd_reg = (MMC_REG_EXT_CSD_t *)mmc_ext_csd_buf;
+        if (mmc_ext_csd_reg->PARTITIONING_SUPPORT)
+    	{
+        	sd_mmc_info->emmc_boot_support = 1;
+        	sd_mmc_info->emmc_boot_partition_size[0] = sd_mmc_info->emmc_boot_partition_size[1] = mmc_ext_csd_reg->BOOT_SIZE_MULTI * EMMC_BOOT_SIZE_UNIT;
+        }
+        ret = sd_send_cmd_hw(sd_mmc_info, MMC_SWITCH_FUNTION, 0x03b90100, RESPONSE_R1, response, 0, 0, 1);
         if(ret)
             return ret;
 
@@ -4231,16 +4306,12 @@
     }
     else if(sd_mmc_info->card_type == CARD_TYPE_SDIO)
     {
-		ret = sdio_read_reg(0, High_Speed_REG, &read_reg_data);
-		if(ret)
-			return ret;
-
-    	if(read_reg_data & SDIO_Support_High_Speed)
+		ret = sdio_read_reg(sd_mmc_info, 0, High_Speed_REG, &read_reg_data);
+    	if(read_reg_data & SDIO_Support_High_Speed & (!ret))
     	{
-			write_reg_data = SDIO_Enable_High_Speed;
-			ret = sdio_write_reg(0, High_Speed_REG, &write_reg_data, SDIO_Read_After_Write);
-			if(ret)
-				return ret;
+			write_reg_data = ((read_reg_data & 0xfd) | SDIO_Enable_High_Speed);
+			ret = sdio_write_reg(sd_mmc_info, 0, High_Speed_REG, &write_reg_data, SDIO_Read_After_Write);
+			if(!ret) {
 
         	sdio_config = 0;
         	config_reg = (void *)&sdio_config;
@@ -4251,58 +4322,68 @@
 			sd_mmc_info->sdio_clk_unit = 1000/SD_MMC_TRANSFER_HIGHSPEED_CLK;
         	sd_mmc_info->speed_class = HIGH_SPEED;
         }
+        }
 
 		sdio_config = 0;
         config_reg = (void *)&sdio_config;
         sdio_config = READ_CBUS_REG(SDIO_CONFIG);
-        config_reg->cmd_clk_divide = 3;
+        config_reg->cmd_clk_divide = 5;
         WRITE_CBUS_REG(SDIO_CONFIG, sdio_config);
 
 		sd_mmc_info->sdio_clk_unit = 1000/SD_MMC_TRANSFER_CLK;
     }
 
-	printk("set sd_mmc config_reg->cmd_clk_divide %d, CLK %dM\n", 
-			config_reg->cmd_clk_divide, 90/(config_reg->cmd_clk_divide + 1) );
+	if(!config_reg){
+		sdio_config = READ_CBUS_REG(SDIO_CONFIG);
+		config_reg = (void *)&sdio_config;
+	}
+	printk("set sd_mmc config_reg->cmd_clk_divide %d, CLK %ldM\n", 
+		config_reg->cmd_clk_divide, 
+		clk_get_rate(clk_get_sys("clk81", NULL))/2000000/(config_reg->cmd_clk_divide + 1));
+	
 	return SD_MMC_NO_ERROR;
 }
 
-int sd_check_sdio_card_type()
+int sd_check_sdio_card_type(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int error, function_no, timeout_count = SDIO_FUNCTION_TIMEOUT;
 	unsigned char read_reg_data;
 	unsigned char write_reg_data;
+	unsigned write_addr;
 
-	for(function_no=1; function_no<8; function_no++)
+	for(function_no=1; function_no<sd_mmc_info->sdio_function_nums; function_no++)
 	{
-		error = sdio_read_reg(0, function_no<<8, &read_reg_data);
+		sd_mmc_info->sdio_blk_len[function_no] = 1;
+		read_reg_data = 0;
+		error = sdio_read_reg(sd_mmc_info, 0, function_no<<8, &read_reg_data);
 		if(error)
 			return error;
 
-		if(read_reg_data)
-		{
-			sd_mmc_info->sdio_function_no = function_no;
-			switch(read_reg_data)
-			{
+		switch(read_reg_data) {
+
+			case 0:
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_NONE_SDIO;
+				break;
 				case 1:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_STD_UART;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_STD_UART;
 					break;
 				case 2:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_BT_TYPEA;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_BT_TYPEA;
 					break;
 				case 3:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_BT_TYPEB;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_BT_TYPEB;
 					break;
 				case 4:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_GPS;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_GPS;
 					break;
 				case 5:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_CAMERA;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_CAMERA;
 					break;
 				case 6:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_PHS;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_PHS;
 					break;	
 				case 7:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_WLAN;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_WLAN;
 					break;
 				case 8:
 				case 9:
@@ -4311,44 +4392,45 @@
 				case 12:
 				case 13:
 				case 14:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_NONE;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_NONE;
 					break;
 				case 15:
-					sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_OTHER_IF;
+				sd_mmc_info->sdio_card_type[function_no] = CARD_TYPE_SDIO_OTHER_IF;
 					break;
 				default:
 					break;
 			}
-			break;
-		}
 	}
 
-	if(function_no >= 8)
-	{
-		sd_mmc_info->sdio_function_no = 1;
-		sd_mmc_info->sdio_card_type = CARD_TYPE_SDIO_WLAN;
-	}
+	error = sdio_read_reg(sd_mmc_info, 0, IO_READY_REG, &write_reg_data);
+	if(error)
+		return error;
 
-	write_reg_data = (1<<sd_mmc_info->sdio_function_no);
-    error = sdio_write_reg(0, IO_ENABLE_REG, &write_reg_data, SDIO_Read_After_Write);
+	//function enable would do at up layer
+	/*write_reg_data |= 2;//((1<<sd_mmc_info->sdio_function_nums)-2);
+    error = sdio_write_reg(sd_mmc_info, 0, IO_ENABLE_REG, &write_reg_data, SDIO_Read_After_Write);
     if(error)
     	return error;	
 
 	while(timeout_count--)
 	{
-		error = sdio_read_reg(0, IO_READY_REG, &read_reg_data);
+		error = sdio_read_reg(sd_mmc_info, 0, IO_READY_REG, &read_reg_data);
 		if(error)
 			return error;
 
-		if(read_reg_data == (1<<sd_mmc_info->sdio_function_no))
+		if(read_reg_data == write_reg_data)
 			break;
 		else
 			sd_delay_ms(1);
 	}
 
-	if(timeout_count)
+#ifdef  SD_MMC_DEBUG
+	Debug_Printf("#read_reg_data %x timeout_count %d \n", read_reg_data, timeout_count);
+#endif*/
+
+	if(timeout_count > 0)
 	{
-		error = sdio_read_reg(0, Card_Capability_REG, &read_reg_data);
+		error = sdio_read_reg(sd_mmc_info, 0, Card_Capability_REG, &read_reg_data);
 		if(error)
 			return error;
 
@@ -4357,36 +4439,42 @@
 			if(SDIO_BLOCK_SIZE&0xFF)
 			{
 				write_reg_data = (SDIO_BLOCK_SIZE & 0xFF);
-				error = sdio_write_reg(0, FN0_Block_Size_Low_REG, &write_reg_data, SDIO_Read_After_Write);
+				error = sdio_write_reg(sd_mmc_info, 0, FN0_Block_Size_Low_REG, &write_reg_data, SDIO_Read_After_Write);
 				if(error)
 				{
-					sd_mmc_info->blk_len = 1;
+					sd_mmc_info->sdio_blk_len[0] = 1;
 					return SD_MMC_NO_ERROR;
 				}
 
-				error = sdio_write_reg(0, FN1_Block_Size_Low_REG, &write_reg_data, SDIO_Read_After_Write);
+				write_addr = ((2 << 8) | 0x10);
+				error = sdio_write_reg(sd_mmc_info, 0, write_addr, &write_reg_data, SDIO_Read_After_Write);
 				if(error)
 				{
-					sd_mmc_info->blk_len = 1;
+					sd_mmc_info->sdio_blk_len[2] = 1;
 					return SD_MMC_NO_ERROR;
 				}
 			}
 
 			write_reg_data = (SDIO_BLOCK_SIZE>>8);
-			error = sdio_write_reg(0, FN0_Block_Size_High_REG, &write_reg_data, SDIO_Read_After_Write);
+			error = sdio_write_reg(sd_mmc_info, 0, FN0_Block_Size_High_REG, &write_reg_data, SDIO_Read_After_Write);
 			if(error)
 			{
-				sd_mmc_info->blk_len = 1;
+				sd_mmc_info->sdio_blk_len[0] = 1;
+			}
+			else
+			{
+				sd_mmc_info->sdio_blk_len[0] = SDIO_BLOCK_SIZE;
 			}
 
-			error = sdio_write_reg(0, FN1_Block_Size_High_REG, &write_reg_data, SDIO_Read_After_Write);
+			write_addr = ((2 << 8) | 0x11);
+			error = sdio_write_reg(sd_mmc_info, 0, write_addr, &write_reg_data, SDIO_Read_After_Write);
 			if(error)
 			{
-				sd_mmc_info->blk_len = 1;
+				sd_mmc_info->sdio_blk_len[1] = 1;
 			}
 			else
 			{
-				sd_mmc_info->blk_len = SDIO_BLOCK_SIZE;
+				sd_mmc_info->sdio_blk_len[2] = SDIO_BLOCK_SIZE;
 			}
 		}
 		else
@@ -4399,8 +4487,6 @@
 		return SD_SDIO_ERROR_NO_FUNCTION;
 	}
 
-	//sdio_open_host_interrupt();
-	//error = sdio_open_target_interrupt(sd_mmc_info->sdio_function_no);
 	if(error)
 	{
 #ifdef  SD_MMC_DEBUG
@@ -4412,25 +4498,41 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_read_reg(int function_no, unsigned long sdio_register, unsigned char *reg_data)
+int sdio_read_reg(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, unsigned long sdio_register, unsigned char *reg_data)
 {
 	int ret = 0;
+	unsigned long sdio_direct_rw = 0;
 	unsigned char response[MAX_RESPONSE_BYTES];
+	SDIO_IO_RW_CMD_ARG_t *sdio_io_direct_rw;
 	SDIO_RW_CMD_Response_R5_t * sdio_rw_response = (SDIO_RW_CMD_Response_R5_t *)response;
 
-	unsigned long sdio_direct_rw = 0;
-	SDIO_IO_RW_CMD_ARG_t *sdio_io_direct_rw = (void *)&sdio_direct_rw;
+#ifdef SD_MMC_HW_CONTROL
+	if(SD_WORK_MODE == CARD_HW_MODE)
+	{
+		//sd_sdio_enable(sd_mmc_info->io_pad_type);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
+      	}	
+	}
+#endif       
+#ifdef SD_MMC_SW_CONTROL
+	if(SD_WORK_MODE == CARD_SW_MODE)
+		sd_mmc_io_config(sd_mmc_info);
+#endif
+
+	sdio_io_direct_rw = (void *)&sdio_direct_rw;
 
 	sdio_io_direct_rw->Function_No = function_no;
 	sdio_io_direct_rw->Register_Address = (sdio_register & 0x1FFFF);
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response, 0, 0, 1);
+		ret = sd_send_cmd_hw(sd_mmc_info, IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response, 0, 0, 1);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		ret = sd_send_cmd_sw(IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response);
 #endif
 	if(ret)
 		return ret;
@@ -4440,14 +4542,30 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_write_reg(int function_no, unsigned long sdio_register, unsigned char *reg_data, unsigned read_after_write_flag)
+int sdio_write_reg(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, unsigned int sdio_register, unsigned char *reg_data, unsigned read_after_write_flag)
 {
 	int ret = 0;
+	unsigned long sdio_direct_rw = 0;
+	SDIO_IO_RW_CMD_ARG_t *sdio_io_direct_rw;
 	unsigned char response[MAX_RESPONSE_BYTES];
 	SDIO_RW_CMD_Response_R5_t * sdio_rw_response = (SDIO_RW_CMD_Response_R5_t *)response;
 
-	unsigned long sdio_direct_rw = 0;
-	SDIO_IO_RW_CMD_ARG_t *sdio_io_direct_rw = (void *)&sdio_direct_rw;
+#ifdef SD_MMC_HW_CONTROL
+	if(SD_WORK_MODE == CARD_HW_MODE)
+	{
+		//sd_sdio_enable(sd_mmc_info->io_pad_type);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
+      	}		
+	}
+#endif       
+#ifdef SD_MMC_SW_CONTROL
+	if(SD_WORK_MODE == CARD_SW_MODE)
+		sd_mmc_io_config(sd_mmc_info);
+#endif
+
+	sdio_io_direct_rw = (void *)&sdio_direct_rw;
 
     sdio_io_direct_rw->R_W_Flag = SDIO_Write_Data;
     sdio_io_direct_rw->RAW_Flag = read_after_write_flag;
@@ -4457,48 +4575,57 @@
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
-		ret = sd_send_cmd_hw(IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response, 0, 0, 0);
+		ret = sd_send_cmd_hw(sd_mmc_info, IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response, 0, 0, 0);
 #endif	
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		ret = sd_send_cmd_sw(IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, IO_RW_DIRECT, sdio_direct_rw, RESPONSE_R5, response);
+#endif
+
+#ifdef  SD_MMC_DEBUG
+	//Debug_Printf("#sdio_write_reg write: %x addr: %x read: %x function_no %d\n", (*reg_data), sdio_register, sdio_rw_response->read_or_write_data, function_no);
 #endif
+
 	if(ret)
 		return ret;
 
-	if(read_after_write_flag && (sdio_rw_response->read_or_write_data != (*reg_data)))
-		return SD_MMC_ERROR_DRIVER_FAILURE;
+	if(read_after_write_flag && (sdio_rw_response->read_or_write_data != (*reg_data))) {
+#ifdef  SD_MMC_DEBUG
+		Debug_Printf("#this sdio card could not support read after write\n");
+#endif
+		return SD_MMC_NO_ERROR;
+	}
 
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_card_reset(void)
+int sdio_card_reset(SD_MMC_Card_Info_t *sd_mmc_info)
 {
 	int ret;
 	unsigned char write_reg_data;
 
 	write_reg_data = SDIO_RES_bit;
-    ret = sdio_write_reg(0, IO_ABORT_REG, &write_reg_data, SDIO_DONT_Read_After_Write);
+    ret = sdio_write_reg(sd_mmc_info, 0, IO_ABORT_REG, &write_reg_data, SDIO_DONT_Read_After_Write);
     if(ret)
     	return ret;
 
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_data_transfer_abort(int function_no)
+int sdio_data_transfer_abort(SD_MMC_Card_Info_t *sd_mmc_info, int function_no)
 {
 	int ret;
 	unsigned char write_reg_data;
 
 	write_reg_data = function_no;
-    ret = sdio_write_reg(0, IO_ABORT_REG, &write_reg_data, SDIO_DONT_Read_After_Write);
+    ret = sdio_write_reg(sd_mmc_info, 0, IO_ABORT_REG, &write_reg_data, SDIO_DONT_Read_After_Write);
     if(ret)
     	return ret;
 
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_read_data_block_hw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
+int sdio_read_data_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
@@ -4509,8 +4636,8 @@
 
 	while(block_count)
 	{
-		if(block_count > sd_mmc_buf_size/sd_mmc_info->blk_len)
-			read_block_count = sd_mmc_buf_size/sd_mmc_info->blk_len;
+		if(block_count > sd_mmc_info->max_blk_count)
+			read_block_count = sd_mmc_info->max_blk_count;
 		else
 			read_block_count = block_count;
 
@@ -4521,7 +4648,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = read_block_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_hw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, data_buf+data_offset, read_block_count*sd_mmc_info->blk_len, 0);
+		ret = sd_send_cmd_hw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, data_buf+data_offset, read_block_count*sd_mmc_info->blk_len, 0);
 		if(ret)
 			return ret;
 
@@ -4532,7 +4659,7 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_read_data_block_sw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
+int sdio_read_data_block_sw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
 {
 	unsigned long data = 0, res = 0, temp = 0;
 	int ret, data_busy = 1, res_busy = 1;
@@ -4560,8 +4687,8 @@
 
 	while(block_count)
 	{
-		if(block_count > sd_mmc_buf_size/sd_mmc_info->blk_len)
-			read_block_count = sd_mmc_buf_size/sd_mmc_info->blk_len;
+		if(block_count > sd_mmc_info->max_blk_count)
+			read_block_count = sd_mmc_info->max_blk_count;
 		else
 			read_block_count = block_count;
 
@@ -4572,7 +4699,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = read_block_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_sw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_NONE, NULL);
+		ret = sd_send_cmd_sw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_NONE, NULL);
 		if(ret)
 			return ret;
 
@@ -4586,7 +4713,7 @@
 		}
 
 		sd_clear_response(response);
-		sd_delay_clocks_z(SD_MMC_Z_CMD_TO_RES);
+		sd_delay_clocks_z(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 	
 		sd_set_cmd_input();
 		//wait until both response and data is valid    
@@ -4914,7 +5041,7 @@
 #endif
 		}
 
-		sd_delay_clocks_z(SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
+		sd_delay_clocks_z(sd_mmc_info, SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
 	
 		data_offset += read_block_count*sd_mmc_info->blk_len;
 		block_count -= read_block_count;
@@ -4923,7 +5050,8 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_read_data_byte_hw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+unsigned char sdio_4bytes_buf[PAGE_SIZE];
+int sdio_read_data_byte_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
@@ -4947,26 +5075,26 @@
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
 		if(read_byte_count%4)
-			sdio_read_crc_close = 1;
+			sd_mmc_info->sdio_read_crc_close = 1;
 		else
-			sdio_read_crc_close = 0;
+			sd_mmc_info->sdio_read_crc_close = 0;
 
 		four_byte_count = (read_byte_count + 3) / 4;
 		four_byte_count *= 4;
-		ret = sd_send_cmd_hw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, sd_mmc_buf, four_byte_count, 0);
+		ret = sd_send_cmd_hw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, sdio_4bytes_buf, four_byte_count, 0);
 		if(ret)
 			return ret;
-		memcpy(data_buf + data_offset, sd_mmc_buf, read_byte_count);
+		memcpy(data_buf + data_offset, sdio_4bytes_buf, read_byte_count);
 
 		data_offset += read_byte_count;
 		byte_count -= read_byte_count;
 	}
 
-	sdio_read_crc_close = 0;
+	sd_mmc_info->sdio_read_crc_close = 0;
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_read_data_byte_sw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+int sdio_read_data_byte_sw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
 {
 	unsigned long data = 0, res = 0, temp = 0;
 	int ret, data_busy = 1, res_busy = 1;
@@ -5006,7 +5134,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = read_byte_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_sw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_NONE, NULL);
+		ret = sd_send_cmd_sw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_NONE, NULL);
 		if(ret)
 			return ret;
 
@@ -5020,7 +5148,7 @@
 		}
 
 		sd_clear_response(response);
-		sd_delay_clocks_z(SD_MMC_Z_CMD_TO_RES);
+		sd_delay_clocks_z(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 	
 		sd_set_cmd_input();
 		//wait until both response and data is valid    
@@ -5331,7 +5459,7 @@
 		sd_clk_transfer_low();      //for end bit
 		sd_clk_transfer_high();
 	
-		sd_delay_clocks_z(SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
+		sd_delay_clocks_z(sd_mmc_info, SD_MMC_TIME_NRC_NCC);     //Clock delay, Z type
 
 		data_offset += read_byte_count;
 		byte_count -= read_byte_count;
@@ -5340,28 +5468,28 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_read_data(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+int sdio_read_data(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
 {
 	int error = 0, ret;
-	//SD_WORK_MODE = CARD_SW_MODE;
 	unsigned long block_nums, byte_nums;
+	BUG_ON(sd_mmc_info->sdio_blk_len[function_no] == 0);
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
 	{
-		sd_sdio_enable();
-    	if(sd_save_hw_reg_flag)
-    	{
-    		WRITE_CBUS_REG(SDIO_CONFIG, sd_save_hw_io_config);
-      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_save_hw_io_mult_config);
+		//sd_sdio_enable(sd_mmc_info->io_pad_type);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
     	}		
 	}
 #endif       
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		sd_mmc_io_config();
+		sd_mmc_io_config(sd_mmc_info);
 #endif
 	
+	sd_mmc_info->blk_len = sd_mmc_info->sdio_blk_len[function_no];
 	byte_nums = byte_count % sd_mmc_info->blk_len;
 	block_nums = byte_count / sd_mmc_info->blk_len;
 
@@ -5371,25 +5499,25 @@
 		{
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
-				error = sdio_read_data_byte_hw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+				error = sdio_read_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
-				error = sdio_read_data_byte_sw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+				error = sdio_read_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 			if(error == SD_MMC_ERROR_TIMEOUT)
 			{
-				ret = sdio_data_transfer_abort(function_no);
+				ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 				if(ret)
 					return ret;
 
 #ifdef SD_MMC_HW_CONTROL
 				if(SD_WORK_MODE == CARD_HW_MODE)
-					error = sdio_read_data_byte_hw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+					error = sdio_read_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 #ifdef SD_MMC_SW_CONTROL
 				if(SD_WORK_MODE == CARD_SW_MODE)
-					error = sdio_read_data_byte_sw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+					error = sdio_read_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 				if(error == SD_MMC_ERROR_TIMEOUT)
 					return error;
@@ -5409,7 +5537,7 @@
 #ifdef  SD_MMC_DEBUG
 			Debug_Printf("#%s error occured in sdio_read_byte()\n", sd_error_to_string(error));
 #endif
-			ret = sdio_data_transfer_abort(function_no);
+			ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 			if(ret)
 				return ret;
 
@@ -5418,43 +5546,43 @@
 	}
 	else
 	{
-		if(sd_mmc_info->blk_len == SDIO_BLOCK_SIZE)
+		if(sd_mmc_info->blk_len == sd_mmc_info->sdio_blk_len[function_no])
 		{
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
 			{
-				error = sdio_read_data_block_hw(function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
+				error = sdio_read_data_block_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
 				if(error == SD_MMC_ERROR_TIMEOUT)
 				{
-					ret = sdio_data_transfer_abort(function_no);
+					ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 					if(ret)
 						return ret;
 
-					error = sdio_read_data_byte_hw(function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
+					error = sdio_read_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
 				}
 
 				if(byte_nums)
 				{
-					error = sdio_read_data_byte_hw(function_no, buf_or_fifo, sdio_addr + block_nums*sd_mmc_info->blk_len, byte_nums, data_buf + block_nums*sd_mmc_info->blk_len);
+					error = sdio_read_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr + block_nums*sd_mmc_info->blk_len, byte_nums, data_buf + block_nums*sd_mmc_info->blk_len);
 				}
 			}
 #endif
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
 			{
-				error = sdio_read_data_block_sw(function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
+				error = sdio_read_data_block_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
 				if(error == SD_MMC_ERROR_TIMEOUT)
 				{
-					ret = sdio_data_transfer_abort(function_no);
+					ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 					if(ret)
 						return ret;
 
-					error = sdio_read_data_byte_sw(function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
+					error = sdio_read_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
 				}
 
 				if(byte_nums)
 				{
-					error = sdio_read_data_byte_sw(function_no, buf_or_fifo, sdio_addr + block_nums*sd_mmc_info->blk_len, byte_nums, data_buf + block_nums*sd_mmc_info->blk_len);
+					error = sdio_read_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr + block_nums*sd_mmc_info->blk_len, byte_nums, data_buf + block_nums*sd_mmc_info->blk_len);
 				}
 			}
 #endif
@@ -5463,11 +5591,11 @@
 		{
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
-				error = sdio_read_data_byte_hw(function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
+				error = sdio_read_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
 #endif
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
-				error = sdio_read_data_byte_sw(function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
+				error = sdio_read_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
 #endif
 		}
 
@@ -5476,7 +5604,7 @@
 #ifdef  SD_MMC_DEBUG
 			Debug_Printf("#%s error occured in sdio_read_block()\n", sd_error_to_string(error));
 #endif
-			ret = sdio_data_transfer_abort(function_no);
+			ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 			if(ret)
 				return ret;
 
@@ -5484,13 +5612,10 @@
 		}
 	}
 
-	//sd_sdio_enable();
-	//SD_WORK_MODE = CARD_HW_MODE;
-
 	return SD_MMC_NO_ERROR;	
 }
 
-int sdio_write_data_block_hw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
+int sdio_write_data_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
@@ -5501,8 +5626,8 @@
 
 	while(block_count)
 	{
-		if(block_count > sd_mmc_buf_size/sd_mmc_info->blk_len)
-			write_block_count = sd_mmc_buf_size/sd_mmc_info->blk_len;
+		if(block_count > sd_mmc_info->max_blk_count)
+			write_block_count = sd_mmc_info->max_blk_count;
 		else
 			write_block_count = block_count;
 
@@ -5513,7 +5638,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = write_block_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_hw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, data_buf+data_offset, write_block_count*sd_mmc_info->blk_len, 0);
+		ret = sd_send_cmd_hw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, data_buf+data_offset, write_block_count*sd_mmc_info->blk_len, 0);
 		if(ret)
 			return ret;
 
@@ -5524,7 +5649,7 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_write_data_block_sw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
+int sdio_write_data_block_sw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long block_count, unsigned char *data_buf)
 {
 	unsigned long write_block_count, data_offset = 0;
 
@@ -5550,8 +5675,8 @@
 
 	while(block_count)
 	{
-		if(block_count > sd_mmc_buf_size/sd_mmc_info->blk_len)
-			write_block_count = sd_mmc_buf_size/sd_mmc_info->blk_len;
+		if(block_count > sd_mmc_info->max_blk_count)
+			write_block_count = sd_mmc_info->max_blk_count;
 		else
 			write_block_count = block_count;
 
@@ -5562,7 +5687,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = write_block_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_sw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response);
 		if(ret)
 			return ret;
 
@@ -5572,7 +5697,7 @@
 			org_buf = data_buf;
 
 			//Nwr cycles delay
-			sd_delay_clocks_h(SD_MMC_TIME_NWR);
+			sd_delay_clocks_h(sd_mmc_info, SD_MMC_TIME_NWR);
 
 			//Start bit
 			if(sd_mmc_info->bus_width == SD_BUS_WIDE)
@@ -5690,7 +5815,7 @@
 				sd_set_dat0_input();
 			}
 
-			sd_delay_clocks_h(SD_MMC_Z_CMD_TO_RES);
+			sd_delay_clocks_h(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 
 			crc_status = 0;
 	
@@ -5739,7 +5864,7 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_write_data_byte_hw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+int sdio_write_data_byte_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
 {
 	int ret;
 	unsigned char response[MAX_RESPONSE_BYTES];
@@ -5762,7 +5887,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = write_byte_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_hw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, data_buf+data_offset, write_byte_count, 0);
+		ret = sd_send_cmd_hw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response, data_buf+data_offset, write_byte_count, 0);
 		if(ret)
 			return ret;
 
@@ -5773,7 +5898,7 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_write_data_byte_sw(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+int sdio_write_data_byte_sw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
 {
 	int ret,i,j;
 	unsigned long crc_status, data;
@@ -5811,7 +5936,7 @@
 		sdio_io_extend_rw->Byte_Block_Count = write_byte_count;
 		sdio_io_extend_rw->Register_Address = ((sdio_addr+data_offset) & 0x1FFFF);
 
-		ret = sd_send_cmd_sw(IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response);
+		ret = sd_send_cmd_sw(sd_mmc_info, IO_RW_EXTENDED, sdio_extend_rw, RESPONSE_R5, response);
 		if(ret)
 			return ret;
 
@@ -5819,7 +5944,7 @@
 		org_buf = data_buf;
 
 		//Nwr cycles delay
-		sd_delay_clocks_h(SD_MMC_TIME_NWR);
+		sd_delay_clocks_h(sd_mmc_info, SD_MMC_TIME_NWR);
 
 		//Start bit
 		if(sd_mmc_info->bus_width == SD_BUS_WIDE)
@@ -5937,7 +6062,7 @@
 			sd_set_dat0_input();
 		}
 
-		sd_delay_clocks_h(SD_MMC_Z_CMD_TO_RES);
+		sd_delay_clocks_h(sd_mmc_info, SD_MMC_Z_CMD_TO_RES);
 
 		crc_status = 0;
 	
@@ -5985,31 +6110,32 @@
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_write_data(int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
+int sdio_write_data(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr, unsigned long byte_count, unsigned char *data_buf)
 {
 	int error = 0,ret;
 	unsigned long block_nums, byte_nums;
-	//SD_WORK_MODE = CARD_SW_MODE;
+	BUG_ON(sd_mmc_info->sdio_blk_len[function_no] == 0);
 
 #ifdef SD_MMC_HW_CONTROL
 	if(SD_WORK_MODE == CARD_HW_MODE)
 	{
-		sd_sdio_enable();
-    	if(sd_save_hw_reg_flag)
-    	{
-    		WRITE_CBUS_REG(SDIO_CONFIG, sd_save_hw_io_config);
-      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_save_hw_io_mult_config);
+		//sd_sdio_enable(sd_mmc_info->io_pad_type);
+		if (sd_mmc_info->sd_save_hw_io_flag) {
+    		WRITE_CBUS_REG(SDIO_CONFIG, sd_mmc_info->sd_save_hw_io_config);
+      		WRITE_CBUS_REG(SDIO_MULT_CONFIG, sd_mmc_info->sd_save_hw_io_mult_config);
     	}		
 	}
 #endif
 #ifdef SD_MMC_SW_CONTROL
 	if(SD_WORK_MODE == CARD_SW_MODE)
-		sd_mmc_io_config();
+		sd_mmc_io_config(sd_mmc_info);
 #endif
 
+	sd_mmc_info->blk_len = sd_mmc_info->sdio_blk_len[function_no];
 	block_nums = sd_mmc_info->blk_len;
 	block_nums = byte_count / block_nums;
 	byte_nums = byte_count % sd_mmc_info->blk_len;
+	//printk("sdio write data addr %x at fun %d cnt: %d blk len %d\n", sdio_addr, function_no, byte_count, sd_mmc_info->blk_len);
 
 	if(block_nums == 0)
 	{
@@ -6017,25 +6143,25 @@
 		{
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
-				error = sdio_write_data_byte_hw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+				error = sdio_write_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
-				error = sdio_write_data_byte_sw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+				error = sdio_write_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 			if(error)
 			{
-				ret = sdio_data_transfer_abort(function_no);
+				ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 				if(ret)
 					return ret;
 
 #ifdef SD_MMC_HW_CONTROL
 				if(SD_WORK_MODE == CARD_HW_MODE)
-					error = sdio_write_data_byte_hw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+					error = sdio_write_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 #ifdef SD_MMC_SW_CONTROL
 				if(SD_WORK_MODE == CARD_SW_MODE)
-					error = sdio_write_data_byte_sw(function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
+					error = sdio_write_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_nums, data_buf);
 #endif
 				if(error)
 					return error;
@@ -6045,7 +6171,7 @@
 		{
 			error = SD_MMC_ERROR_BLOCK_LEN;
 #ifdef  SD_MMC_DEBUG
-			Debug_Printf("#%s error occured in sdio_write_data()\n", sd_error_to_string(error));
+			Debug_Printf("#%s error occured in sdio_write_data() blklen %d fun no %d\n", sd_error_to_string(error), sd_mmc_info->blk_len, function_no);
 #endif
 			return error;
 		}
@@ -6055,7 +6181,7 @@
 #ifdef  SD_MMC_DEBUG
 			Debug_Printf("#%s error occured in sdio_write_byte()\n", sd_error_to_string(error));
 #endif
-			ret = sdio_data_transfer_abort(function_no);
+			ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 			if(ret)
 				return ret;
 
@@ -6064,59 +6190,59 @@
 	}
 	else
 	{
-		if(sd_mmc_info->blk_len == SDIO_BLOCK_SIZE)
+		if(sd_mmc_info->blk_len == sd_mmc_info->sdio_blk_len[function_no])
 		{
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
 			{
-				error = sdio_write_data_block_hw(function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
+				error = sdio_write_data_block_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
 				if(error)
 				{
-					ret = sdio_data_transfer_abort(function_no);
+					ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 					if(ret)
 						return ret;
 
-					error = sdio_write_data_block_hw(function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
+					error = sdio_write_data_block_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
 					if(error)
 					{
-						ret = sdio_data_transfer_abort(function_no);
+						ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 						if(ret)
 							return ret;
 
-						error = sdio_write_data_byte_hw(function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
+						error = sdio_write_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
 					}
 				}
 
 				if(byte_nums)
 				{
-					error = sdio_write_data_byte_hw(function_no, buf_or_fifo, sdio_addr+block_nums*sd_mmc_info->blk_len, byte_nums, data_buf+block_nums*sd_mmc_info->blk_len);
+					error = sdio_write_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr+block_nums*sd_mmc_info->blk_len, byte_nums, data_buf+block_nums*sd_mmc_info->blk_len);
 				}
 			}
 #endif
 #ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
 			{
-				error = sdio_write_data_block_sw(function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
+				error = sdio_write_data_block_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
 				if(error)
 				{
-					ret = sdio_data_transfer_abort(function_no);
+					ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 					if(ret)
 						return ret;
 
-					error = sdio_write_data_block_sw(function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
+					error = sdio_write_data_block_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums, data_buf);
 					if(error)
 					{
-						ret = sdio_data_transfer_abort(function_no);
+						ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 						if(ret)
 							return ret;
 
-						error = sdio_write_data_byte_sw(function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
+						error = sdio_write_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, block_nums*sd_mmc_info->blk_len, data_buf);
 					}
 				}
 
 				if(byte_nums)
 				{
-					error = sdio_write_data_byte_sw(function_no, buf_or_fifo, sdio_addr+block_nums*sd_mmc_info->blk_len, byte_nums, data_buf+block_nums*sd_mmc_info->blk_len);
+					error = sdio_write_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr+block_nums*sd_mmc_info->blk_len, byte_nums, data_buf+block_nums*sd_mmc_info->blk_len);
 				}
 			}
 #endif
@@ -6125,20 +6251,20 @@
 		{
 #ifdef SD_MMC_HW_CONTROL
 			if(SD_WORK_MODE == CARD_HW_MODE)
-				error = sdio_write_data_byte_hw(function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
+				error = sdio_write_data_byte_hw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
 #endif
-#ifdef SD_MMC_HW_CONTROL
+#ifdef SD_MMC_SW_CONTROL
 			if(SD_WORK_MODE == CARD_SW_MODE)
-				error = sdio_write_data_byte_sw(function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
+				error = sdio_write_data_byte_sw(sd_mmc_info, function_no, buf_or_fifo, sdio_addr, byte_count, data_buf);
 #endif
 		}
 
 		if(error)
 		{			
 #ifdef  SD_MMC_DEBUG
-			Debug_Printf("#%s error occured in sdio_write_block()\n", sd_error_to_string(error));
+			Debug_Printf("#%s error occured in sdio_write_block() blklen %d fun no %d\n", sd_error_to_string(error), sd_mmc_info->blk_len, function_no);
 #endif
-			ret = sdio_data_transfer_abort(function_no);
+			ret = sdio_data_transfer_abort(sd_mmc_info, function_no);
 			if(ret)
 				return ret;
 
@@ -6146,40 +6272,37 @@
 		}
 	}
 
-	//sd_sdio_enable();
-	//SD_WORK_MODE = CARD_HW_MODE;
-
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_open_target_interrupt(int function_no)
+int sdio_open_target_interrupt(SD_MMC_Card_Info_t *sd_mmc_info, int function_no)
 {
 	int error = 0;
 	unsigned char read_reg_data, write_reg_data;
 
-	error = sdio_read_reg(0, Card_Capability_REG, &read_reg_data);
+	error = sdio_read_reg(sd_mmc_info, 0, Card_Capability_REG, &read_reg_data);
 	if(error)
 		return error;
 
 	write_reg_data = ((1 << function_no) | SDIO_INT_EN_MASK);
-	error = sdio_write_reg(0, INT_ENABLE_REG, &write_reg_data, SDIO_Read_After_Write);
+	error = sdio_write_reg(sd_mmc_info, 0, INT_ENABLE_REG, &write_reg_data, SDIO_Read_After_Write);
 	if(error)
     	return error;
 
 	return SD_MMC_NO_ERROR;
 }
 
-int sdio_close_target_interrupt(int function_no)
+int sdio_close_target_interrupt(SD_MMC_Card_Info_t *sd_mmc_info, int function_no)
 {
 	int error = 0;
 	unsigned char read_reg_data, write_reg_data;
 
-	error = sdio_read_reg(0, Card_Capability_REG, &read_reg_data);
+	error = sdio_read_reg(sd_mmc_info, 0, Card_Capability_REG, &read_reg_data);
 	if(error)
 		return error;
 
 	write_reg_data = 0;
-	error = sdio_write_reg(0, INT_ENABLE_REG, &write_reg_data, SDIO_Read_After_Write);
+	error = sdio_write_reg(sd_mmc_info, 0, INT_ENABLE_REG, &write_reg_data, SDIO_Read_After_Write);
 	if(error)
     	return error;
 
diff -Nur drivers/amlogic/cardreader/sd/sd_protocol.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_protocol.h
--- drivers/amlogic/cardreader/sd/sd_protocol.h	2010-10-08 14:21:12.000000000 +0800
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/sd_protocol.h	2011-07-14 00:17:51.980739983 +0800
@@ -147,6 +147,7 @@
 } SD_REG_CSD_t;
 
 
+
 typedef struct _SDHC_REG_CSD {
 	
 	unsigned Reserved1:6;
@@ -199,32 +200,106 @@
 	unsigned CRC:7;	//CRC checksum
 } SDHC_REG_CSD_t;
 
-/*typedef struct _MMC_REG_EXT_CSD
+
+
+typedef struct _MMC_REG_EXT_CSD
 {
-    unsigned char Reserved1[7];
-    unsigned char S_CMD_SET;
-    unsigned char Reserved2[300];
-    unsigned char PWR_CL_26_360;
-    unsigned char PWR_CL_52_360;
-    unsigned char PWR_CL_26_195;
-    unsigned char PWR_CL_52_195;
-    unsigned char Reserved3[3];
-    unsigned char CARD_TYPE;
-    unsigned char Reserved4;
-    unsigned char CSD_STRUCTURE;
-    unsigned char Reserved5;
-    unsigned char EXT_CSD_REV;
-    unsigned char CMD_SET;
-    unsigned char Reserved6;
-    unsigned char CMD_SET_REV;
-    unsigned char Reserved7;
-    unsigned char POWER_CLASS;
-    unsigned char Reserved8;
-    unsigned char HS_TIMING;
-    unsigned char Reserved9;
-    unsigned char BUS_WIDTH;
-    unsigned char Reserved10[183];
-            } MMC_REG_EXT_CSD_t;*/// reserved for future use
+ 	unsigned char Reserved26[134];                 //133
+ 	unsigned char SEC_BAD_BLK_MGMNT;               //134
+ 	unsigned char Reserved25;                      //135
+ 	unsigned char ENH_START_ADDR[4];               //136
+ 	unsigned char ENH_SIZE_MULT[3];                //140
+ 	unsigned char GP_SIZE_MULT[12];                //143
+ 	unsigned char PARTITION_SETTING_COMPLETED;     //155
+ 	unsigned char PARTITIONS_ATTRIBUTE;            //156
+ 	unsigned char MAX_ENH_SIZE_MULT[3];            //157
+ 	unsigned char PARTITIONING_SUPPORT;            //160
+ 	unsigned char HPI_MGMT;                        //161
+ 	unsigned char RST_n_FUNCTION;                  //162
+ 	unsigned char BKOPS_EN;                        //163
+ 	unsigned char BKOPS_START;                     //164
+ 	unsigned char Reserved24;                      //165
+ 	unsigned char WR_REL_PARAM;                    //166
+ 	unsigned char WR_REL_SET;                      //167
+ 	unsigned char RPMB_SIZE_MULT;                  //168
+ 	unsigned char FW_CONFIG;                       //169
+ 	unsigned char Reserved23; 	                   //170
+ 	unsigned char USER_WP;                         //171
+ 	unsigned char Reserved22;                      //172
+ 	unsigned char BOOT_WP;                         //173
+ 	unsigned char Reserved21; 	                   //174
+ 	unsigned char ERASE_GROUP_DEF;                 //175
+ 	unsigned char Reserved20; 	                   //176
+ 	unsigned char BOOT_BUS_WIDTH;                  //177
+ 	unsigned char BOOT_CONFIG_PROT;                //178
+ 	unsigned char PARTITION_CONFIG;                //179
+ 	unsigned char Reserved19;                      //180
+ 	unsigned char ERASED_MEM_CONT;                 //181
+ 	unsigned char Reserved18;                      //182
+ 	unsigned char BUS_WIDTH;                       //183
+ 	unsigned char Reserved17;                      //184
+ 	unsigned char HS_TIMING;                       //185
+ 	unsigned char Reserved16;                      //186
+ 	unsigned char POWER_CLASS;                     //187
+ 	unsigned char Reserved15;                      //188
+ 	unsigned char CMD_SET_REV;                     //189
+ 	unsigned char Reserved14;                      //190 
+ 	unsigned char CMD_SET;                         //191
+ 	unsigned char EXT_CSD_REV;                     //192
+ 	unsigned char Reserved13;                      //193
+ 	unsigned char CSD_STRUCTURE;                   //194
+ 	unsigned char Reserved12;                      //195
+ 	unsigned char CARD_TYPE;                       //196
+ 	unsigned char Reserved11;                      //197
+ 	unsigned char OUT_OF_INTERRUPT_TIME;           //198
+ 	unsigned char PARTITION_SWITCH_TIME;           //199
+ 	unsigned char PWR_CL_52_195;                   //200
+ 	unsigned char PWR_CL_26_195;                   //201
+ 	unsigned char PWR_CL_52_360;                   //202
+ 	unsigned char PWR_CL_26_360;                   //203
+ 	unsigned char Reserved10;                      //204
+ 	unsigned char MIN_PERF_R_4_26;                 //205
+ 	unsigned char MIN_PERF_W_4_26;                 //206
+ 	unsigned char MIN_PERF_R_8_26_4_52;            //207
+ 	unsigned char MIN_PERF_W_8_26_4_52;            //208
+ 	unsigned char MIN_PERF_R_8_52;                 //209
+ 	unsigned char MIN_PERF_W_8_52;                 //210
+ 	unsigned char Reserved9;                       //211
+ 	unsigned char SEC_COUNT[4];                    //212
+ 	unsigned char Reserved8;                       //216
+ 	unsigned char S_A_TIMEOUT;                     //217
+ 	unsigned char Reserved7;                       //218
+ 	unsigned char S_C_VCCQ;                        //219
+ 	unsigned char S_C_VCC;                         //220
+ 	unsigned char HC_WP_GRP_SIZE;                  //221
+ 	unsigned char REL_WR_SEC_C;                    //222
+ 	unsigned char ERASE_TIMEOUT_MULT;              //223
+ 	unsigned char HC_ERASE_GRP_SIZE;               //224
+ 	unsigned char ACC_SIZE;                        //225
+ 	unsigned char BOOT_SIZE_MULTI;                 //226
+ 	unsigned char Reserved6;                       //227
+ 	unsigned char BOOT_INFO;                       //228
+ 	unsigned char SEC_TRIM_MULT;                   //229
+ 	unsigned char SEC_ERASE_MULT;                  //230
+ 	unsigned char SEC_FEATURE_SUPPORT;             //231
+ 	unsigned char TRIM_MULT;                       //232
+ 	unsigned char Reserved5;                       //233
+ 	unsigned char MIN_PERF_DDR_R_8_52;             //234
+ 	unsigned char MIN_PERF_DDR_W_8_52;             //235
+ 	unsigned char Reserved4[2];                    //236
+ 	unsigned char PWR_CL_DDR_52_195;               //238
+ 	unsigned char PWR_CL_DDR_52_360;               //239
+ 	unsigned char Reserved3;                       //240
+ 	unsigned char INI_TIMEOUT_AP;                  //241
+ 	unsigned char CORRECTLY_PRG_SECTORS_NUM[4];    //242
+ 	unsigned char BKOPS_STATUS;                    //246
+ 	unsigned char Reserved2[255];                  //247
+ 	unsigned char BKOPS_SUPPORT;                   //502
+ 	unsigned char HPI_FEATURES;                    //503
+ 	unsigned char S_CMD_SET;                       //504
+    unsigned char Reserved1[7];                    //505
+} MMC_REG_EXT_CSD_t;
+
     
 //MSB->LSB, structure for SD CARD Configuration Register
 typedef struct _SD_REG_SCR {
@@ -561,7 +636,8 @@
 	CARD_TYPE_NONE = 0, 
 	CARD_TYPE_SD, 
 	CARD_TYPE_SDHC, 
-	CARD_TYPE_MMC, 
+	CARD_TYPE_MMC,
+	CARD_TYPE_EMMC, 
 	CARD_TYPE_SDIO 
 } SD_Card_Type_t;
 
@@ -608,20 +684,23 @@
 typedef struct SD_MMC_Card_Info {
 	
 	SD_Card_Type_t card_type;	
-	SDIO_Card_Type_t sdio_card_type;	
+	SDIO_Card_Type_t sdio_card_type[8];	
 	SD_Operation_Mode_t operation_mode;	
 	SD_Bus_Width_t bus_width;	
 	SD_SPEC_VERSION_t spec_version;	
 	MMC_SPEC_VERSION_t mmc_spec_version;	
 	SD_SPEED_CLASS_t speed_class;	
 	SD_REG_CID_t raw_cid;	
+	SDIO_Pad_Type_t  io_pad_type;	/* hw io pin pad */
 
 	unsigned short card_rca;
-	unsigned sdio_function_no;
+	unsigned char sdio_function_nums;
 	unsigned sdio_clk_unit;
-	unsigned long blk_len;
-	unsigned long blk_nums;	
-	unsigned long clks_nac;
+	unsigned blk_len;
+	unsigned sdio_blk_len[8];
+	unsigned sdio_cis_addr[8];
+	unsigned blk_nums;	
+	unsigned clks_nac;
 	int write_protected_flag;
 	int inited_flag;
 	int removed_flag;
@@ -629,12 +708,29 @@
 	int single_blk_failed;
 	int sdio_init_flag;	
 
+	unsigned emmc_boot_support;
+	unsigned emmc_boot_partition_size[2];
+	unsigned sd_save_hw_io_flag;
+	unsigned sd_save_hw_io_config;
+	unsigned sd_save_hw_io_mult_config;
+	unsigned read_multi_block_failed;
+	unsigned write_multi_block_failed;
+	unsigned sdio_read_crc_close;
+	unsigned sd_mmc_power_delay ;
+	unsigned disable_high_speed;
+	unsigned disable_wide_bus;
+	unsigned max_blk_count;
+
+	unsigned char *sd_mmc_buf;
+	unsigned char *sd_mmc_phy_buf;
+
 	void (*sd_mmc_power) (int power_on);
 	int (*sd_mmc_get_ins) (void);	
 	int (*sd_get_wp) (void);	
 	void (*sd_mmc_io_release) (void);
 } SD_MMC_Card_Info_t;
 
+#define EMMC_BOOT_SIZE_UNIT (128*1024)  // for emmc boot size
     //SDIO_REG_DEFINE
 #define CCCR_SDIO_SPEC_REG               0x00
 #define SD_SPEC_REG                      0x01
@@ -662,12 +758,16 @@
 #define SDIO_Read_Data				  0
 #define SDIO_Write_Data				  1
 #define SDIO_DONT_Read_After_Write	  0
+#ifdef CONFIG_SDIO_MARVELL_NH387_WIFI
+#define SDIO_Read_After_Write		  0	//MARVELL_NH387 can't support verify check
+#else
 #define SDIO_Read_After_Write		  1
+#endif
 #define SDIO_Block_MODE			  	  1
 #define SDIO_Byte_MODE		  	  	  0
     
 #define SDIO_Wide_bus_Bit			  0x02
-#define SDIO_Single_bus_Bit			  0x01
+#define SDIO_Single_bus_Bit			  0x00
 #define SDIO_Support_High_Speed		  0x01
 #define SDIO_Enable_High_Speed		  0x02
 #define SDIO_Support_Multi_Block	  0x02
@@ -675,7 +775,7 @@
 #define SDIO_E4MI_EN_MASK			  0x20
 #define SDIO_RES_bit				  0x08
     
-#define SDIO_BLOCK_SIZE				  128
+#define SDIO_BLOCK_SIZE				  512
     
 //SD/MMC Card bus commands          CMD     type    argument                response
     
@@ -696,7 +796,7 @@
 #define SD_SWITCH_FUNCTION				46	//bcr   [31:23]mode,[22:8]default bit,[7:0]function
 #define SD_MMC_SELECT_DESELECT_CARD     7	//ac    [31:16] RCA             R1
 #define SD_SEND_IF_COND                 8	//      [11:8]supply voltage    R7
-#define MMC_SEND_EXT_CSD                8	//ac    [31:0]stuff             R1
+#define MMC_SEND_EXT_CSD                48	//ac    [31:0]stuff             R1
 #define SD_MMC_SEND_CSD                 9	//ac    [31:16] RCA             R2
 #define SD_MMC_SEND_CID                 10	//ac    [31:16] RCA             R2
 #define SD_READ_DAT_UNTIL_STOP          11	//adtc  [31:0] data address     R1
@@ -823,69 +923,69 @@
 //Following functions are the API used for outside routine
     
 //SD Initialization...
-int sd_mmc_init(void);
+int sd_mmc_init(SD_MMC_Card_Info_t *sd_mmc_info);
 
-void sd_mmc_exit(void);
+void sd_mmc_exit(SD_MMC_Card_Info_t *sd_mmc_info);
 
-void sd_mmc_prepare_init(void);
+void sd_mmc_prepare_init(SD_MMC_Card_Info_t *sd_mmc_info);
 
 //get sd_mmc card information
 //void sd_mmc_get_info(blkdev_stat_t *info);
 //Check if any card is connected to adapter
-    SD_Card_Type_t sd_mmc_check_present(void);
+SD_Card_Type_t sd_mmc_check_present(SD_MMC_Card_Info_t *sd_mmc_info);
 
 //Check if any card is inserted according to pull up resistor
-int sd_mmc_check_insert(void);
+int sd_mmc_check_insert(SD_MMC_Card_Info_t *sd_mmc_info);
 
 //Read data from SD/MMC card
-int sd_mmc_read_data(unsigned long lba, unsigned long byte_cnt,
+int sd_mmc_read_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long byte_cnt,
 		     unsigned char *data_buf);
 
 //Write data to SD/MMC card
-int sd_mmc_write_data(unsigned long lba, unsigned long byte_cnt,
+int sd_mmc_write_data(SD_MMC_Card_Info_t *sd_mmc_info, unsigned long lba, unsigned long byte_cnt,
 		      unsigned char *data_buf);
 
 
-int sdio_read_data_block_hw(int function_no, int buf_or_fifo,
+int sdio_read_data_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo,
 			      unsigned long sdio_addr,
 			      unsigned long block_count,
 			      unsigned char *data_buf);
 
-int sdio_read_data_byte_hw(int function_no, int buf_or_fifo,
+int sdio_read_data_byte_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo,
 			    unsigned long sdio_addr, unsigned long byte_count,
 			    unsigned char *data_buf);
 
-int sdio_write_data_block_hw(int function_no, int buf_or_fifo,
+int sdio_write_data_block_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo,
 			      unsigned long sdio_addr,
 			      unsigned long block_count,
 			      unsigned char *data_buf);
 
-int sdio_write_data_byte_hw(int function_no, int buf_or_fifo,
+int sdio_write_data_byte_hw(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo,
 			     unsigned long sdio_addr, unsigned long byte_count,
 			     unsigned char *data_buf);
 
-int sdio_read_reg(int function_no, unsigned long sdio_register,
+int sdio_read_reg(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, unsigned long sdio_register,
 		   unsigned char *reg_data);
 
-int sdio_write_reg(int function_no, unsigned long sdio_register,
+int sdio_write_reg(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, unsigned int sdio_register,
 		    unsigned char *reg_data, unsigned read_after_write_flag);
 
-int sdio_read_data(int function_no, int buf_or_fifo, unsigned long sdio_addr,
+int sdio_read_data(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr,
 		    unsigned long byte_count, unsigned char *data_buf);
 
-int sdio_write_data(int function_no, int buf_or_fifo, unsigned long sdio_addr,
+int sdio_write_data(SD_MMC_Card_Info_t *sd_mmc_info, int function_no, int buf_or_fifo, unsigned long sdio_addr,
 		     unsigned long byte_count, unsigned char *data_buf);
 
-int sdio_close_target_interrupt(int function_no);
+int sdio_close_target_interrupt(SD_MMC_Card_Info_t *sd_mmc_info, int function_no);
 
-int sdio_open_target_interrupt(int function_no);
+int sdio_open_target_interrupt(SD_MMC_Card_Info_t *sd_mmc_info, int function_no);
 
 //SD Power on/off
-void sd_mmc_power_on(void);
+void sd_mmc_power_on(SD_MMC_Card_Info_t *sd_mmc_info);
 
-void sd_mmc_power_off(void);
+void sd_mmc_power_off(SD_MMC_Card_Info_t *sd_mmc_info);
 
-void sd_mmc_prepare_init(void);
+void sd_mmc_prepare_init(SD_MMC_Card_Info_t *sd_mmc_info);
 
 #endif				//_H_SD_PROTOCOL
     
Binary files drivers/amlogic/cardreader/sd/.sd_protocol.h.swp and /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sd/.sd_protocol.h.swp differ
diff -Nur drivers/amlogic/cardreader/sdio_cis.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_cis.c
--- drivers/amlogic/cardreader/sdio_cis.c	1970-01-01 08:30:00.000000000 +0830
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_cis.c	2011-07-14 00:17:51.980739983 +0800
@@ -0,0 +1,410 @@
+/*
+ * linux/drivers/mmc/core/sdio_cis.c
+ *
+ * Author:	Nicolas Pitre
+ * Created:	June 11, 2007
+ * Copyright:	MontaVista Software Inc.
+ *
+ * Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include <linux/cardreader/sdio.h>
+#include <linux/cardreader/cardreader.h>
+#include <linux/cardreader/card_block.h>
+
+#include "sdio_ops.h"
+
+static int cistpl_vers_1(struct memory_card *card, struct sdio_func *func,
+			 const unsigned char *buf, unsigned size)
+{
+	unsigned i, nr_strings;
+	char **buffer, *string;
+
+	/* Find all null-terminated (including zero length) strings in
+	   the TPLLV1_INFO field. Trailing garbage is ignored. */
+	buf += 2;
+	size -= 2;
+
+	nr_strings = 0;
+	for (i = 0; i < size; i++) {
+		if (buf[i] == 0xff)
+			break;
+		if (buf[i] == 0)
+			nr_strings++;
+	}
+	if (nr_strings == 0)
+		return 0;
+
+	size = i;
+
+	buffer = kzalloc(sizeof(char*) * nr_strings + size, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	string = (char*)(buffer + nr_strings);
+
+	for (i = 0; i < nr_strings; i++) {
+		buffer[i] = string;
+		strcpy(string, buf);
+		string += strlen(string) + 1;
+		buf += strlen(buf) + 1;
+	}
+
+	if (func) {
+		func->num_info = nr_strings;
+		func->info = (const char**)buffer;
+	} else {
+		card->num_info = nr_strings;
+		card->info = (const char**)buffer;
+	}
+
+	return 0;
+}
+
+static int cistpl_manfid(struct memory_card *card, struct sdio_func *func,
+			 const unsigned char *buf, unsigned size)
+{
+	unsigned int vendor, device;
+
+	/* TPLMID_MANF */
+	vendor = buf[0] | (buf[1] << 8);
+
+	/* TPLMID_CARD */
+	device = buf[2] | (buf[3] << 8);
+
+	if (func) {
+		func->vendor = vendor;
+		func->device = device;
+	} else {
+		card->cis.vendor = vendor;
+		card->cis.device = device;
+	}
+
+	return 0;
+}
+
+static const unsigned char speed_val[16] =
+	{ 0, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80 };
+static const unsigned int speed_unit[8] =
+	{ 10000, 100000, 1000000, 10000000, 0, 0, 0, 0 };
+
+
+typedef int (tpl_parse_t)(struct memory_card *, struct sdio_func *,
+			   const unsigned char *, unsigned);
+
+struct cis_tpl {
+	unsigned char code;
+	unsigned char min_size;
+	tpl_parse_t *parse;
+};
+
+static int cis_tpl_parse(struct memory_card *card, struct sdio_func *func,
+			 const char *tpl_descr,
+			 const struct cis_tpl *tpl, int tpl_count,
+			 unsigned char code,
+			 const unsigned char *buf, unsigned size)
+{
+	int i, ret;
+
+	/* look for a matching code in the table */
+	for (i = 0; i < tpl_count; i++, tpl++) {
+		if (tpl->code == code)
+			break;
+	}
+	if (i < tpl_count) {
+		if (size >= tpl->min_size) {
+			if (tpl->parse)
+				ret = tpl->parse(card, func, buf, size);
+			else
+				ret = -EILSEQ;	/* known tuple, not parsed */
+		} else {
+			/* invalid tuple */
+			ret = -EINVAL;
+		}
+		if (ret && ret != -EILSEQ && ret != -ENOENT) {
+			printk(KERN_ERR "%s: bad %s tuple 0x%02x (%u bytes)\n",
+			       card_hostname(card->host), tpl_descr, code, size);
+		}
+	} else {
+		/* unknown tuple */
+		ret = -ENOENT;
+	}
+
+	return ret;
+}
+
+static int cistpl_funce_common(struct memory_card *card, struct sdio_func *func,
+			       const unsigned char *buf, unsigned size)
+{
+	/* Only valid for the common CIS (function 0) */
+	if (func)
+		return -EINVAL;
+
+	/* TPLFE_FN0_BLK_SIZE */
+	card->cis.blksize = buf[1] | (buf[2] << 8);
+
+	/* TPLFE_MAX_TRAN_SPEED */
+	card->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *
+			    speed_unit[buf[3] & 7];
+
+	return 0;
+}
+
+static int cistpl_funce_func(struct memory_card *card, struct sdio_func *func,
+			     const unsigned char *buf, unsigned size)
+{
+	unsigned vsn;
+	unsigned min_size;
+
+	/* Only valid for the individual function's CIS (1-7) */
+	if (!func)
+		return -EINVAL;
+
+	/*
+	 * This tuple has a different length depending on the SDIO spec
+	 * version.
+	 */
+	vsn = func->card->cccr.sdio_vsn;
+	min_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;
+
+	if (size < min_size)
+		return -EINVAL;
+
+	/* TPLFE_MAX_BLK_SIZE */
+	func->max_blksize = buf[12] | (buf[13] << 8);
+
+	/* TPLFE_ENABLE_TIMEOUT_VAL, present in ver 1.1 and above */
+	if (vsn > SDIO_SDIO_REV_1_00)
+		func->enable_timeout = (buf[28] | (buf[29] << 8)) * 10;
+	else
+		func->enable_timeout = jiffies_to_msecs(HZ);
+
+	return 0;
+}
+
+/*
+ * Known TPLFE_TYPEs table for CISTPL_FUNCE tuples.
+ *
+ * Note that, unlike PCMCIA, CISTPL_FUNCE tuples are not parsed depending
+ * on the TPLFID_FUNCTION value of the previous CISTPL_FUNCID as on SDIO
+ * TPLFID_FUNCTION is always hardcoded to 0x0C.
+ */
+static const struct cis_tpl cis_tpl_funce_list[] = {
+	{	0x00,	4,	cistpl_funce_common		},
+	{	0x01,	0,	cistpl_funce_func		},
+	{	0x04,	1+1+6,	/* CISTPL_FUNCE_LAN_NODE_ID */	},
+};
+
+static int cistpl_funce(struct memory_card *card, struct sdio_func *func,
+			const unsigned char *buf, unsigned size)
+{
+	if (size < 1)
+		return -EINVAL;
+
+	return cis_tpl_parse(card, func, "CISTPL_FUNCE",
+			     cis_tpl_funce_list,
+			     ARRAY_SIZE(cis_tpl_funce_list),
+			     buf[0], buf, size);
+}
+
+/* Known TPL_CODEs table for CIS tuples */
+static const struct cis_tpl cis_tpl_list[] = {
+	{	0x15,	3,	cistpl_vers_1		},
+	{	0x20,	4,	cistpl_manfid		},
+	{	0x21,	2,	/* cistpl_funcid */	},
+	{	0x22,	0,	cistpl_funce		},
+};
+
+static int sdio_read_cis(struct memory_card *card, struct sdio_func *func)
+{
+	int ret;
+	struct sdio_func_tuple *this, **prev;
+	unsigned i, ptr = 0;
+
+	/*
+	 * Note that this works for the common CIS (function number 0) as
+	 * well as a function's CIS * since SDIO_CCCR_CIS and SDIO_FBR_CIS
+	 * have the same offset.
+	 */
+	for (i = 0; i < 3; i++) {
+		unsigned char x, fn;
+
+		if (func)
+			fn = func->num;
+		else
+			fn = 0;
+
+		ret = sdio_io_rw_direct(card, 0, 0,
+			SDIO_FBR_BASE(fn) + SDIO_FBR_CIS + i, 0, &x);
+		if (ret)
+			return ret;
+		ptr |= x << (i * 8);
+	}
+
+	if (func)
+		prev = &func->tuples;
+	else
+		prev = &card->tuples;
+
+	BUG_ON(*prev);
+
+	do {
+		unsigned char tpl_code, tpl_link;
+
+		ret = sdio_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_code);
+		if (ret)
+			break;
+
+		/* 0xff means we're done */
+		if (tpl_code == 0xff)
+			break;
+
+		/* null entries have no link field or data */
+		if (tpl_code == 0x00)
+			continue;
+
+		ret = sdio_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_link);
+		if (ret)
+			break;
+
+		/* a size of 0xff also means we're done */
+		if (tpl_link == 0xff)
+			break;
+
+		this = kmalloc(sizeof(*this) + tpl_link, GFP_KERNEL);
+		if (!this)
+			return -ENOMEM;
+
+		for (i = 0; i < tpl_link; i++) {
+			ret = sdio_io_rw_direct(card, 0, 0,
+					       ptr + i, 0, &this->data[i]);
+			if (ret)
+				break;
+		}
+		if (ret) {
+			kfree(this);
+			break;
+		}
+
+		/* Try to parse the CIS tuple */
+		ret = cis_tpl_parse(card, func, "CIS",
+				    cis_tpl_list, ARRAY_SIZE(cis_tpl_list),
+				    tpl_code, this->data, tpl_link);
+		if (ret == -EILSEQ || ret == -ENOENT) {
+			/*
+			 * The tuple is unknown or known but not parsed.
+			 * Queue the tuple for the function driver.
+			 */
+			this->next = NULL;
+			this->code = tpl_code;
+			this->size = tpl_link;
+			*prev = this;
+			prev = &this->next;
+
+			if (ret == -ENOENT) {
+				/* warn about unknown tuples */
+				printk(KERN_WARNING "%s: queuing unknown"
+				       " CIS tuple 0x%02x (%u bytes)\n",
+				       card_hostname(card->host),
+				       tpl_code, tpl_link);
+			}
+
+			/* keep on analyzing tuples */
+			ret = 0;
+		} else {
+			/*
+			 * We don't need the tuple anymore if it was
+			 * successfully parsed by the SDIO core or if it is
+			 * not going to be queued for a driver.
+			 */
+			kfree(this);
+		}
+
+		ptr += tpl_link;
+	} while (!ret);
+
+	/*
+	 * Link in all unknown tuples found in the common CIS so that
+	 * drivers don't have to go digging in two places.
+	 */
+	if (func)
+		*prev = card->tuples;
+
+	return ret;
+}
+
+int sdio_read_common_cis(struct memory_card *card)
+{
+	return sdio_read_cis(card, NULL);
+}
+
+void sdio_free_common_cis(struct memory_card *card)
+{
+	struct sdio_func_tuple *tuple, *victim;
+
+	tuple = card->tuples;
+
+	while (tuple) {
+		victim = tuple;
+		tuple = tuple->next;
+		kfree(victim);
+	}
+
+	card->tuples = NULL;
+}
+
+int sdio_read_func_cis(struct sdio_func *func)
+{
+	int ret;
+
+	ret = sdio_read_cis(func->card, func);
+	if (ret)
+		return ret;
+
+	/*
+	 * Since we've linked to tuples in the card structure,
+	 * we must make sure we have a reference to it.
+	 */
+	get_device(&func->card->dev);
+
+	/*
+	 * Vendor/device id is optional for function CIS, so
+	 * copy it from the card structure as needed.
+	 */
+	if (func->vendor == 0) {
+		func->vendor = func->card->cis.vendor;
+		func->device = func->card->cis.device;
+	}
+
+	return 0;
+}
+
+void sdio_free_func_cis(struct sdio_func *func)
+{
+	struct sdio_func_tuple *tuple, *victim;
+
+	tuple = func->tuples;
+
+	while (tuple && tuple != func->card->tuples) {
+		victim = tuple;
+		tuple = tuple->next;
+		kfree(victim);
+	}
+
+	func->tuples = NULL;
+
+	/*
+	 * We have now removed the link to the tuples in the
+	 * card structure, so remove the reference.
+	 */
+	put_device(&func->card->dev);
+}
+
diff -Nur drivers/amlogic/cardreader/sdio_io.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_io.c
--- drivers/amlogic/cardreader/sdio_io.c	1970-01-01 08:30:00.000000000 +0830
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_io.c	2011-07-14 00:17:51.980739983 +0800
@@ -0,0 +1,952 @@
+/*
+ *  linux/drivers/amlogic/cardreader/sdio_io.c
+ *
+ *  Copyright 20108 Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <linux/cardreader/sdio.h>
+#include <linux/cardreader/card_block.h>
+#include "sdio_ops.h"
+
+static int process_sdio_pending_irqs(struct memory_card *card)
+{
+	int i, ret, count;
+	unsigned char pending;
+
+	ret = sdio_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, &pending);
+	if (ret) {
+		printk(KERN_DEBUG "%s: error %d reading SDIO_CCCR_INTx\n",
+		       card_card_id(card), ret);
+		return ret;
+	}
+
+
+	count = 0;
+	for (i = 1; i <= 7; i++) {
+		if (pending & (1 << i)) {
+			struct sdio_func *func = card->sdio_func[i - 1];
+			if (!func) {
+				printk(KERN_WARNING "%s: pending IRQ for "
+					"non-existant function,pending = %x\n",
+					card_card_id(card), pending);
+				ret = -EINVAL;
+			} else if (func->irq_handler) {
+				//printk("sdio irq received and handled at func %d\n", i);
+				func->irq_handler(func);
+				count++;
+			} else {
+				printk(KERN_WARNING "%s: pending IRQ with no handler fun_num: %d\n", sdio_func_id(func), i);
+				ret = -EINVAL;
+			}
+		}
+	}
+
+	sdio_irq_handled = 1;
+	if (count)
+		return count;
+
+	return ret;
+}
+
+static int sdio_irq_thread(void *_host)
+{
+	struct card_host *host = _host;
+	struct sched_param param = { .sched_priority = 1 };
+	unsigned long period, idle_period;
+	int ret;
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+
+	/*
+	 * We want to allow for SDIO cards to work even on non SDIO
+	 * aware hosts.  One thing that non SDIO host cannot do is
+	 * asynchronous notification of pending SDIO card interrupts
+	 * hence we poll for them in that case.
+	 */
+	idle_period = msecs_to_jiffies(10);
+	period = (host->caps & CARD_CAP_SDIO_IRQ) ?
+		MAX_SCHEDULE_TIMEOUT : idle_period;
+
+	pr_debug("%s: IRQ thread started (poll period = %lu jiffies)\n",
+		 card_hostname(host), period);
+
+	do {
+		/*
+		 * We claim the host here on drivers behalf for a couple
+		 * reasons:
+		 *
+		 * 1) it is already needed to retrieve the CCCR_INTx;
+		 * 2) we want the driver(s) to clear the IRQ condition ASAP;
+		 * 3) we need to control the abort condition locally.
+		 *
+		 * Just like traditional hard IRQ handlers, we expect SDIO
+		 * IRQ handlers to be quick and to the point, so that the
+		 * holding of the host lock does not cover too much work
+		 * that doesn't require that lock to be held.
+		 */
+		//ret = __card_claim_host(host, &host->sdio_irq_thread_abort);
+		card_claim_host(host);
+		//if (ret)
+			//break;
+		ret = process_sdio_pending_irqs(host->card);
+		card_release_host(host);
+
+		/*
+		 * Give other threads a chance to run in the presence of
+		 * errors.
+		 */
+		if (ret < 0) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (!kthread_should_stop())
+				schedule_timeout(HZ);
+			set_current_state(TASK_RUNNING);
+		}
+
+		/*
+		 * Adaptive polling frequency based on the assumption
+		 * that an interrupt will be closely followed by more.
+		 * This has a substantial benefit for network devices.
+		 */
+		if (!(host->caps & CARD_CAP_SDIO_IRQ)) {
+			if (ret > 0)
+				period /= 2;
+			else {
+				period++;
+				if (period > idle_period)
+					period = idle_period;
+			}
+		}
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (host->caps & CARD_CAP_SDIO_IRQ) {
+			host->ops->enable_sdio_irq(host, 1);
+			schedule();
+		}
+		else if (!kthread_should_stop())
+		    msleep(10);
+			//schedule_timeout(period);
+                set_current_state(TASK_INTERRUPTIBLE);
+		if(host->sdio_task_state)
+		{
+			schedule();
+		}
+		set_current_state(TASK_RUNNING);
+	} while (!kthread_should_stop());
+
+	if (host->caps & CARD_CAP_SDIO_IRQ)
+		host->ops->enable_sdio_irq(host, 0);
+
+	pr_debug("%s: IRQ thread exiting with code %d\n",
+		 card_hostname(host), ret);
+
+	return ret;
+}
+
+static int sdio_card_irq_get(struct memory_card *card)
+{
+	struct card_host *host = card->host;
+
+	WARN_ON(!host->claimed);
+
+	if (!host->sdio_irqs++) {
+		atomic_set(&host->sdio_irq_thread_abort, 0);
+		host->sdio_irq_thread =
+			kthread_run(sdio_irq_thread, host, "ksdioirqd/%s",
+				card_hostname(host));
+		if (IS_ERR(host->sdio_irq_thread)) {
+			int err = PTR_ERR(host->sdio_irq_thread);
+			host->sdio_irqs--;
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int sdio_card_irq_put(struct memory_card *card)
+{
+	struct card_host *host = card->host;
+
+	WARN_ON(!host->claimed);
+	BUG_ON(host->sdio_irqs < 1);
+
+	if (!--host->sdio_irqs) {
+		atomic_set(&host->sdio_irq_thread_abort, 1);
+		kthread_stop(host->sdio_irq_thread);
+	}
+
+	return 0;
+}
+
+/**
+ *	sdio_claim_irq - claim the IRQ for a SDIO function
+ *	@func: SDIO function
+ *	@handler: IRQ handler callback
+ *
+ *	Claim and activate the IRQ for the given SDIO function. The provided
+ *	handler will be called when that IRQ is asserted.  The host is always
+ *	claimed already when the handler is called so the handler must not
+ *	call sdio_claim_host() nor sdio_release_host().
+ */
+int sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Enabling IRQ for %s...\n", sdio_func_id(func));
+
+	if (func->irq_handler) {
+		pr_debug("SDIO: IRQ for %s already in use.\n", sdio_func_id(func));
+		return -EBUSY;
+	}
+
+	ret = sdio_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
+	if (ret)
+		return ret;
+
+	reg |= 1 << func->num;
+
+	reg |= 1; /* Master interrupt enable */
+
+	ret = sdio_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
+	if (ret)
+		return ret;
+
+	func->irq_handler = handler;
+	ret = sdio_card_irq_get(func->card);
+	if (ret)
+		func->irq_handler = NULL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdio_claim_irq);
+
+/**
+ *	sdio_release_irq - release the IRQ for a SDIO function
+ *	@func: SDIO function
+ *
+ *	Disable and release the IRQ for the given SDIO function.
+ */
+int sdio_release_irq(struct sdio_func *func)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Disabling IRQ for %s...\n", sdio_func_id(func));
+
+	if (func->irq_handler) {
+		func->irq_handler = NULL;
+		sdio_card_irq_put(func->card);
+	}
+
+	ret = sdio_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);
+	if (ret)
+		return ret;
+
+	reg &= ~(1 << func->num);
+
+	/* Disable master interrupt with the last function interrupt */
+	if (!(reg & 0xFE))
+		reg = 0;
+
+	ret = sdio_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdio_release_irq);
+
+/**
+ *	sdio_claim_host - exclusively claim a bus for a certain SDIO function
+ *	@func: SDIO function that will be accessed
+ *
+ *	Claim a bus for a set of operations. The SDIO function given
+ *	is used to figure out which bus is relevant.
+ */
+void sdio_claim_host(struct sdio_func *func)
+{
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	__card_claim_host(func->card->host, func->card);
+}
+EXPORT_SYMBOL_GPL(sdio_claim_host);
+
+/**
+ *	sdio_release_host - release a bus for a certain SDIO function
+ *	@func: SDIO function that was accessed
+ *
+ *	Release a bus, allowing others to claim the bus for their
+ *	operations.
+ */
+void sdio_release_host(struct sdio_func *func)
+{
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	card_release_host(func->card->host);
+}
+EXPORT_SYMBOL_GPL(sdio_release_host);
+
+/**
+ *	sdio_enable_func - enables a SDIO function for usage
+ *	@func: SDIO function to enable
+ *
+ *	Powers up and activates a SDIO function so that register
+ *	access is possible.
+ */
+int sdio_enable_func(struct sdio_func *func)
+{
+	int ret;
+	unsigned char reg;
+	unsigned long timeout;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Enabling device %s...\n", sdio_func_id(func));
+
+	ret = sdio_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IOEx, 0, &reg);
+	if (ret)
+		goto err;
+
+	reg |= 1 << func->num;
+
+	ret = sdio_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IOEx, reg, NULL);
+	if (ret)
+		goto err;
+
+	timeout = jiffies + msecs_to_jiffies(func->enable_timeout);
+
+	while (1) {
+		ret = sdio_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IORx, 0, &reg);
+		if (ret)
+			goto err;
+		if (reg & (1 << func->num))
+			break;
+		ret = -ETIME;
+		if (time_after(jiffies, timeout))
+			goto err;
+	}
+
+	pr_debug("SDIO: Enabled device %s\n", sdio_func_id(func));
+
+	return 0;
+
+err:
+	pr_debug("SDIO: Failed to enable device %s\n", sdio_func_id(func));
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sdio_enable_func);
+
+/**
+ *	sdio_disable_func - disable a SDIO function
+ *	@func: SDIO function to disable
+ *
+ *	Powers down and deactivates a SDIO function. Register access
+ *	to this function will fail until the function is reenabled.
+ */
+int sdio_disable_func(struct sdio_func *func)
+{
+	int ret;
+	unsigned char reg;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	pr_debug("SDIO: Disabling device %s...\n", sdio_func_id(func));
+
+	ret = sdio_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IOEx, 0, &reg);
+	if (ret)
+		goto err;
+
+	reg &= ~(1 << func->num);
+
+	ret = sdio_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IOEx, reg, NULL);
+	if (ret)
+		goto err;
+
+	pr_debug("SDIO: Disabled device %s\n", sdio_func_id(func));
+
+	return 0;
+
+err:
+	pr_debug("SDIO: Failed to disable device %s\n", sdio_func_id(func));
+	return -EIO;
+}
+EXPORT_SYMBOL_GPL(sdio_disable_func);
+
+/**
+ *	sdio_set_block_size - set the block size of an SDIO function
+ *	@func: SDIO function to change
+ *	@blksz: new block size or 0 to use the default.
+ *
+ *	The default block size is the largest supported by both the function
+ *	and the host, with a maximum of 512 to ensure that arbitrarily sized
+ *	data transfer use the optimal (least) number of commands.
+ *
+ *	A driver may call this to override the default block size set by the
+ *	core. This can be used to set a block size greater than the maximum
+ *	that reported by the card; it is the driver's responsibility to ensure
+ *	it uses a value that the card supports.
+ *
+ *	Returns 0 on success, -EINVAL if the host does not support the
+ *	requested block size, or -EIO (etc.) if one of the resultant FBR block
+ *	size register writes failed.
+ *
+ */
+int sdio_set_block_size(struct sdio_func *func, unsigned blksz)
+{
+	int ret;
+
+	if (blksz > func->card->host->max_blk_size)
+		return -EINVAL;
+
+	if (blksz == 0) {
+		blksz = min(func->max_blksize, func->card->host->max_blk_size);
+		blksz = min(blksz, 512u);
+	}
+
+	ret = sdio_io_rw_direct(func->card, 1, 0,
+		SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,
+		blksz & 0xff, NULL);
+	if (ret)
+		return ret;
+	ret = sdio_io_rw_direct(func->card, 1, 0,
+		SDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1,
+		(blksz >> 8) & 0xff, NULL);
+	if (ret)
+		return ret;
+	func->cur_blksize = blksz;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdio_set_block_size);
+
+/*
+ * Calculate the maximum byte mode transfer size
+ */
+static inline unsigned int sdio_max_byte_size(struct sdio_func *func)
+{
+	unsigned mval =	min(func->card->host->max_seg_size,
+			    func->card->host->max_blk_size);
+
+	/*if (mmc_blksz_for_byte_mode(func->card))
+		mval = min(mval, func->cur_blksize);
+	else
+		mval = min(mval, func->max_blksize);*/
+
+	return min(mval, 512u); /* maximum size for byte mode */
+}
+
+/**
+ *	sdio_align_size - pads a transfer size to a more optimal value
+ *	@func: SDIO function
+ *	@sz: original transfer size
+ *
+ *	Pads the original data size with a number of extra bytes in
+ *	order to avoid controller bugs and/or performance hits
+ *	(e.g. some controllers revert to PIO for certain sizes).
+ *
+ *	If possible, it will also adjust the size so that it can be
+ *	handled in just a single request.
+ *
+ *	Returns the improved size, which might be unmodified.
+ */
+unsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)
+{
+	unsigned int orig_sz;
+	unsigned int blk_sz, byte_sz;
+	unsigned chunk_sz;
+
+	orig_sz = sz;
+
+	/*
+	 * Do a first check with the controller, in case it
+	 * wants to increase the size up to a point where it
+	 * might need more than one block.
+	 */
+	sz = card_align_data_size(func->card, sz);
+
+	/*
+	 * If we can still do this with just a byte transfer, then
+	 * we're done.
+	 */
+	if (sz <= sdio_max_byte_size(func))
+		return sz;
+
+	if (1) {
+		/*
+		 * Check if the transfer is already block aligned
+		 */
+		if ((sz % func->cur_blksize) == 0)
+			return sz;
+
+		/*
+		 * Realign it so that it can be done with one request,
+		 * and recheck if the controller still likes it.
+		 */
+		blk_sz = ((sz + func->cur_blksize - 1) /
+			func->cur_blksize) * func->cur_blksize;
+		blk_sz = card_align_data_size(func->card, blk_sz);
+
+		/*
+		 * This value is only good if it is still just
+		 * one request.
+		 */
+		if ((blk_sz % func->cur_blksize) == 0)
+			return blk_sz;
+
+		/*
+		 * We failed to do one request, but at least try to
+		 * pad the remainder properly.
+		 */
+		byte_sz = card_align_data_size(func->card,
+				sz % func->cur_blksize);
+		if (byte_sz <= sdio_max_byte_size(func)) {
+			blk_sz = sz / func->cur_blksize;
+			return blk_sz * func->cur_blksize + byte_sz;
+		}
+	} else {
+		/*
+		 * We need multiple requests, so first check that the
+		 * controller can handle the chunk size;
+		 */
+		chunk_sz = card_align_data_size(func->card,
+				sdio_max_byte_size(func));
+		if (chunk_sz == sdio_max_byte_size(func)) {
+			/*
+			 * Fix up the size of the remainder (if any)
+			 */
+			byte_sz = orig_sz % chunk_sz;
+			if (byte_sz) {
+				byte_sz = card_align_data_size(func->card,
+						byte_sz);
+			}
+
+			return (orig_sz / chunk_sz) * chunk_sz + byte_sz;
+		}
+	}
+
+	/*
+	 * The controller is simply incapable of transferring the size
+	 * we want in decent manner, so just return the original size.
+	 */
+	return orig_sz;
+}
+EXPORT_SYMBOL_GPL(sdio_align_size);
+
+/* Split an arbitrarily sized data transfer into several
+ * IO_RW_EXTENDED commands. */
+static int sdio_io_rw_ext_helper(struct sdio_func *func, int write,
+	unsigned addr, int incr_addr, u8 *buf, unsigned size)
+{
+	unsigned remainder = size;
+	unsigned max_blocks;
+	int ret;
+	//printk("sdio rw ext addr %x at fun %d cnt: %d read_or_write %d\n", 
+			//addr, func->num, size, write);
+
+	/* Do the bulk of the transfer using block mode (if supported). */
+	if ((size > sdio_max_byte_size(func))) {
+		/* Blocks per command is limited by host count, host transfer
+		 * size (we only use a single sg entry) and the maximum for
+		 * IO_RW_EXTENDED of 511 blocks. */
+		max_blocks = min(func->card->host->max_blk_count,
+			func->card->host->max_seg_size / func->cur_blksize);
+		max_blocks = min(max_blocks, 511u);
+
+		while (remainder > func->cur_blksize) {
+			unsigned blocks;
+
+			blocks = remainder / func->cur_blksize;
+			if (blocks > max_blocks)
+				blocks = max_blocks;
+			size = blocks * func->cur_blksize;
+
+			ret = sdio_io_rw_extended(func->card, write,
+				func->num, addr, incr_addr, buf,
+				blocks, func->cur_blksize);
+			if (ret)
+				return ret;
+
+			remainder -= size;
+			buf += size;
+			if (incr_addr)
+				addr += size;
+		}
+	}
+
+	/* Write the remainder using byte mode. */
+	while (remainder > 0) {
+		size = min(remainder, sdio_max_byte_size(func));
+
+		ret = sdio_io_rw_extended(func->card, write, func->num, addr,
+			 incr_addr, buf, 1, size);
+		if (ret)
+			return ret;
+
+		remainder -= size;
+		buf += size;
+		if (incr_addr)
+			addr += size;
+	}
+	return 0;
+}
+
+/**
+ *	sdio_readb - read a single byte from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *
+ *	Reads a single byte from the address space of a given SDIO
+ *	function. If there is a problem reading the address, 0xff
+ *	is returned and @err_ret will contain the error code.
+ */
+u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)
+{
+	int ret;
+	u8 val;
+
+	BUG_ON(!func);
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = sdio_io_rw_direct(func->card, 0, func->num, addr, 0, &val);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFF;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(sdio_readb);
+
+/**
+ *	sdio_writeb - write a single byte to a SDIO function
+ *	@func: SDIO function to access
+ *	@b: byte to write
+ *	@addr: address to write to
+ *	@err_ret: optional status value from transfer
+ *
+ *	Writes a single byte to the address space of a given SDIO
+ *	function. @err_ret will contain the status of the actual
+ *	transfer.
+ */
+void sdio_writeb(struct sdio_func *func, u8 b, unsigned int addr, int *err_ret)
+{
+	int ret;
+
+	BUG_ON(!func);
+
+	ret = sdio_io_rw_direct(func->card, 1, func->num, addr, b, NULL);
+	if (err_ret)
+		*err_ret = ret;
+}
+EXPORT_SYMBOL_GPL(sdio_writeb);
+
+/**
+ *	sdio_memcpy_fromio - read a chunk of memory from a SDIO function
+ *	@func: SDIO function to access
+ *	@dst: buffer to store the data
+ *	@addr: address to begin reading from
+ *	@count: number of bytes to read
+ *
+ *	Reads from the address space of a given SDIO function. Return
+ *	value indicates if the transfer succeeded or not.
+ */
+int sdio_memcpy_fromio(struct sdio_func *func, void *dst,
+	unsigned int addr, int count)
+{
+	return sdio_io_rw_ext_helper(func, 0, addr, 1, dst, count);
+}
+EXPORT_SYMBOL_GPL(sdio_memcpy_fromio);
+
+/**
+ *	sdio_memcpy_toio - write a chunk of memory to a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to start writing to
+ *	@src: buffer that contains the data to write
+ *	@count: number of bytes to write
+ *
+ *	Writes to the address space of a given SDIO function. Return
+ *	value indicates if the transfer succeeded or not.
+ */
+int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,
+	void *src, int count)
+{
+	return sdio_io_rw_ext_helper(func, 1, addr, 1, src, count);
+}
+EXPORT_SYMBOL_GPL(sdio_memcpy_toio);
+
+/**
+ *	sdio_readsb - read from a FIFO on a SDIO function
+ *	@func: SDIO function to access
+ *	@dst: buffer to store the data
+ *	@addr: address of (single byte) FIFO
+ *	@count: number of bytes to read
+ *
+ *	Reads from the specified FIFO of a given SDIO function. Return
+ *	value indicates if the transfer succeeded or not.
+ */
+int sdio_readsb(struct sdio_func *func, void *dst, unsigned int addr,
+	int count)
+{
+	return sdio_io_rw_ext_helper(func, 0, addr, 0, dst, count);
+}
+EXPORT_SYMBOL_GPL(sdio_readsb);
+
+/**
+ *	sdio_writesb - write to a FIFO of a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address of (single byte) FIFO
+ *	@src: buffer that contains the data to write
+ *	@count: number of bytes to write
+ *
+ *	Writes to the specified FIFO of a given SDIO function. Return
+ *	value indicates if the transfer succeeded or not.
+ */
+int sdio_writesb(struct sdio_func *func, unsigned int addr, void *src,
+	int count)
+{
+	return sdio_io_rw_ext_helper(func, 1, addr, 0, src, count);
+}
+EXPORT_SYMBOL_GPL(sdio_writesb);
+
+/**
+ *	sdio_readw - read a 16 bit integer from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *
+ *	Reads a 16 bit integer from the address space of a given SDIO
+ *	function. If there is a problem reading the address, 0xffff
+ *	is returned and @err_ret will contain the error code.
+ */
+u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret)
+{
+	int ret;
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = sdio_memcpy_fromio(func, func->tmpbuf, addr, 2);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFFFF;
+	}
+
+	return le16_to_cpup((__le16 *)func->tmpbuf);
+}
+EXPORT_SYMBOL_GPL(sdio_readw);
+
+/**
+ *	sdio_writew - write a 16 bit integer to a SDIO function
+ *	@func: SDIO function to access
+ *	@b: integer to write
+ *	@addr: address to write to
+ *	@err_ret: optional status value from transfer
+ *
+ *	Writes a 16 bit integer to the address space of a given SDIO
+ *	function. @err_ret will contain the status of the actual
+ *	transfer.
+ */
+void sdio_writew(struct sdio_func *func, u16 b, unsigned int addr, int *err_ret)
+{
+	int ret;
+
+	*(__le16 *)func->tmpbuf = cpu_to_le16(b);
+
+	ret = sdio_memcpy_toio(func, addr, func->tmpbuf, 2);
+	if (err_ret)
+		*err_ret = ret;
+}
+EXPORT_SYMBOL_GPL(sdio_writew);
+
+/**
+ *	sdio_readl - read a 32 bit integer from a SDIO function
+ *	@func: SDIO function to access
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *
+ *	Reads a 32 bit integer from the address space of a given SDIO
+ *	function. If there is a problem reading the address,
+ *	0xffffffff is returned and @err_ret will contain the error
+ *	code.
+ */
+u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret)
+{
+	int ret;
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = sdio_memcpy_fromio(func, func->tmpbuf, addr, 4);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFFFFFFFF;
+	}
+
+	return le32_to_cpup((__le32 *)func->tmpbuf);
+}
+EXPORT_SYMBOL_GPL(sdio_readl);
+
+/**
+ *	sdio_writel - write a 32 bit integer to a SDIO function
+ *	@func: SDIO function to access
+ *	@b: integer to write
+ *	@addr: address to write to
+ *	@err_ret: optional status value from transfer
+ *
+ *	Writes a 32 bit integer to the address space of a given SDIO
+ *	function. @err_ret will contain the status of the actual
+ *	transfer.
+ */
+void sdio_writel(struct sdio_func *func, u32 b, unsigned int addr, int *err_ret)
+{
+	int ret;
+
+	*(__le32 *)func->tmpbuf = cpu_to_le32(b);
+
+	ret = sdio_memcpy_toio(func, addr, func->tmpbuf, 4);
+	if (err_ret)
+		*err_ret = ret;
+}
+EXPORT_SYMBOL_GPL(sdio_writel);
+
+/**
+ *	sdio_f0_readb - read a single byte from SDIO function 0
+ *	@func: an SDIO function of the card
+ *	@addr: address to read
+ *	@err_ret: optional status value from transfer
+ *
+ *	Reads a single byte from the address space of SDIO function 0.
+ *	If there is a problem reading the address, 0xff is returned
+ *	and @err_ret will contain the error code.
+ */
+unsigned char sdio_f0_readb(struct sdio_func *func, unsigned int addr,
+	int *err_ret)
+{
+	int ret;
+	unsigned char val;
+
+	BUG_ON(!func);
+
+	if (err_ret)
+		*err_ret = 0;
+
+	ret = sdio_io_rw_direct(func->card, 0, 0, addr, 0, &val);
+	if (ret) {
+		if (err_ret)
+			*err_ret = ret;
+		return 0xFF;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(sdio_f0_readb);
+
+/**
+ *	sdio_f0_writeb - write a single byte to SDIO function 0
+ *	@func: an SDIO function of the card
+ *	@b: byte to write
+ *	@addr: address to write to
+ *	@err_ret: optional status value from transfer
+ *
+ *	Writes a single byte to the address space of SDIO function 0.
+ *	@err_ret will contain the status of the actual transfer.
+ *
+ *	Only writes to the vendor specific CCCR registers (0xF0 -
+ *	0xFF) are permiited; @err_ret will be set to -EINVAL for *
+ *	writes outside this range.
+ */
+void sdio_f0_writeb(struct sdio_func *func, unsigned char b, unsigned int addr,
+	int *err_ret)
+{
+	int ret;
+
+	BUG_ON(!func);
+
+	if ((addr < 0xF0 || addr > 0xFF)) {
+		if (err_ret)
+			*err_ret = -EINVAL;
+		return;
+	}
+
+	ret = sdio_io_rw_direct(func->card, 1, 0, addr, b, NULL);
+	if (err_ret)
+		*err_ret = ret;
+}
+EXPORT_SYMBOL_GPL(sdio_f0_writeb);
+
+/**
+ *	sdio_get_host_pm_caps - get host power management capabilities
+ *	@func: SDIO function attached to host
+ *
+ *	Returns a capability bitmask corresponding to power management
+ *	features supported by the host controller that the card function
+ *	might rely upon during a system suspend.  The host doesn't need
+ *	to be claimed, nor the function active, for this information to be
+ *	obtained.
+ */
+card_pm_flag_t sdio_get_host_pm_caps(struct sdio_func *func)
+{
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	return func->card->host->pm_caps;
+}
+EXPORT_SYMBOL_GPL(sdio_get_host_pm_caps);
+
+/**
+ *	sdio_set_host_pm_flags - set wanted host power management capabilities
+ *	@func: SDIO function attached to host
+ *
+ *	Set a capability bitmask corresponding to wanted host controller
+ *	power management features for the upcoming suspend state.
+ *	This must be called, if needed, each time the suspend method of
+ *	the function driver is called, and must contain only bits that
+ *	were returned by sdio_get_host_pm_caps().
+ *	The host doesn't need to be claimed, nor the function active,
+ *	for this information to be set.
+ */
+int sdio_set_host_pm_flags(struct sdio_func *func, card_pm_flag_t flags)
+{
+	struct card_host *host;
+
+	BUG_ON(!func);
+	BUG_ON(!func->card);
+
+	host = func->card->host;
+
+	if (flags & ~host->pm_caps)
+		return -EINVAL;
+
+	/* function suspend methods are serialized, hence no lock needed */
+	host->pm_flags |= flags;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sdio_set_host_pm_flags);
diff -Nur drivers/amlogic/cardreader/sdio_ops.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_ops.c
--- drivers/amlogic/cardreader/sdio_ops.c	1970-01-01 08:30:00.000000000 +0830
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_ops.c	2011-07-14 00:17:51.980739983 +0800
@@ -0,0 +1,116 @@
+/*
+ *  linux/drivers/mmc/sdio_ops.c
+ *
+ *  Copyright 2006-2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/cardreader/sdio.h>
+#include <linux/cardreader/card_block.h>
+
+#include "sdio_ops.h"
+
+static int sdio_io_rw_direct_host(struct card_host *host, int write, unsigned fn,
+	unsigned addr, u8 in, u8 *out)
+{
+	struct card_blk_request brq;
+
+	BUG_ON(!host);
+	BUG_ON(fn > 7);
+
+	/* sanity check */
+	if (addr & ~0x1FFFF)
+		return -EINVAL;
+
+	if (write)
+		brq.crq.cmd = WRITE;
+	else
+		brq.crq.cmd = READ;
+	if (out)
+		brq.crq.cmd |= READ_AFTER_WRITE;
+	brq.crq.cmd |= SDIO_OPS_REG;
+
+	brq.crq.buf = &in;
+	brq.crq.back_buf = out;
+	brq.card_data.lba = addr;
+	brq.card_data.flags = fn;
+	brq.card_data.blk_size = 1;
+	brq.card_data.blk_nums = 1;						// for read reg just one byte
+
+	card_wait_for_req(host, &brq);
+
+	return brq.card_data.error;
+}
+
+int sdio_io_rw_direct(struct memory_card *card, int write, unsigned fn,
+	unsigned addr, u8 in, u8 *out)
+{
+	BUG_ON(!card);
+	card->host->card_busy = card;
+	return sdio_io_rw_direct_host(card->host, write, fn, addr, in, out);
+}
+
+EXPORT_SYMBOL(sdio_io_rw_direct);
+
+int sdio_io_rw_extended(struct memory_card *card, int write, unsigned fn,
+	unsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)
+{
+	struct card_blk_request brq;
+
+	BUG_ON(!card);
+	BUG_ON(fn > 7);
+	BUG_ON(blocks == 1 && blksz > 512);
+	WARN_ON(blocks == 0);
+	WARN_ON(blksz == 0);
+
+	/* sanity check */
+	if (addr & ~0x1FFFF)
+		return -EINVAL;
+
+	card->host->card_busy = card;
+	if (write)
+		brq.crq.cmd = WRITE;
+	else
+		brq.crq.cmd = READ;
+	if (incr_addr)
+		brq.crq.cmd |= SDIO_FIFO_ADDR;
+
+	brq.crq.buf = buf;
+	brq.card_data.lba = addr;
+	brq.card_data.blk_size = blksz;
+	brq.card_data.blk_nums = blocks;
+	brq.card_data.flags = fn;
+
+	card_wait_for_req(card->host, &brq);
+
+	return brq.card_data.error;
+}
+
+EXPORT_SYMBOL(sdio_io_rw_extended);
+
+int sdio_reset(struct card_host *host)
+{
+	int ret;
+	u8 abort;
+
+	/* SDIO Simplified Specification V2.0, 4.4 Reset for SDIO */
+	host->card_busy = host->card;
+	ret = sdio_io_rw_direct_host(host, 0, 0, SDIO_CCCR_ABORT, 0, &abort);
+	if (ret)
+		abort = 0x08;
+	else
+		abort |= 0x08;
+
+	ret = sdio_io_rw_direct_host(host, 1, 0, SDIO_CCCR_ABORT, abort, NULL);
+	return ret;
+}
+
diff -Nur drivers/amlogic/cardreader/sdio_ops.h /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_ops.h
--- drivers/amlogic/cardreader/sdio_ops.h	1970-01-01 08:30:00.000000000 +0830
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_ops.h	2011-07-14 00:17:51.980739983 +0800
@@ -0,0 +1,23 @@
+/*
+ *  linux/drivers/mmc/sdio_ops.c
+ *
+ *  Copyright 2006-2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef _MMC_SDIO_OPS_H
+#define _MMC_SDIO_OPS_H
+
+int sdio_send_io_op_cond(struct card_host *host, u32 ocr, u32 *rocr);
+int sdio_io_rw_direct(struct memory_card *card, int write, unsigned fn,
+	unsigned addr, u8 in, u8* out);
+int sdio_io_rw_extended(struct memory_card *card, int write, unsigned fn,
+	unsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz);
+int sdio_reset(struct card_host *host);
+
+#endif
+
diff -Nur drivers/amlogic/cardreader/sdio_sys.c /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_sys.c
--- drivers/amlogic/cardreader/sdio_sys.c	1970-01-01 08:30:00.000000000 +0830
+++ /home/linux-builder/autobuild/arm_build/android/kernel/drivers/amlogic/cardreader/sdio_sys.c	2011-07-14 00:17:51.980739983 +0800
@@ -0,0 +1,272 @@
+/*
+ *  linux/drivers/amlogic/cardreader/sdio_sys.c
+ *
+ *  Copyright 2010 Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * SDIO function driver model
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+
+#include <linux/cardreader/sdio.h>
+#include <linux/cardreader/card_block.h>
+
+/* show configuration fields */
+#define sdio_config_attr(field, format_string)				\
+static ssize_t								\
+field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
+{									\
+	struct sdio_func *func;						\
+									\
+	func = dev_to_sdio_func (dev);					\
+	return sprintf (buf, format_string, func->field);		\
+}
+
+sdio_config_attr(class, "0x%02x\n");
+sdio_config_attr(vendor, "0x%04x\n");
+sdio_config_attr(device, "0x%04x\n");
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sdio_func *func = dev_to_sdio_func (dev);
+
+	return sprintf(buf, "sdio:c%02Xv%04Xd%04X\n",
+			func->class, func->vendor, func->device);
+}
+
+static struct device_attribute sdio_dev_attrs[] = {
+	__ATTR_RO(class),
+	__ATTR_RO(vendor),
+	__ATTR_RO(device),
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+static const struct sdio_device_id *sdio_match_one(struct sdio_func *func,
+	const struct sdio_device_id *id)
+{
+	if (func->vendor && func->device) {
+
+		if (id->class != (__u8)SDIO_ANY_ID && id->class != func->class)
+			return NULL;
+		if (id->vendor != (__u16)SDIO_ANY_ID && id->vendor != func->vendor)
+			return NULL;
+		if (id->device != (__u16)SDIO_ANY_ID && id->device != func->device)
+			return NULL;
+	}
+	else {
+
+	if (id->class != (__u8)SDIO_ANY_ID && id->class != func->class)
+		func->class = id->class;
+	if (id->vendor != (__u16)SDIO_ANY_ID && id->vendor != func->vendor)
+		func->vendor = id->vendor;
+	if (id->device != (__u16)SDIO_ANY_ID && id->device != func->device)
+		func->device = id->device;
+	}
+	return id;
+}
+
+static const struct sdio_device_id *sdio_match_device(struct sdio_func *func,
+	struct sdio_driver *sdrv)
+{
+	const struct sdio_device_id *ids;
+
+	ids = sdrv->id_table;
+
+	if (ids) {
+		while (ids->class || ids->vendor || ids->device) {
+			if (sdio_match_one(func, ids))
+				return ids;
+			ids++;
+		}
+	}
+
+	return NULL;
+}
+
+static int sdio_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sdio_driver *sdrv = to_sdio_driver(drv);
+
+	if (sdio_match_device(func, sdrv))
+		return 1;
+
+	return 0;
+}
+
+static int
+sdio_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	if (add_uevent_var(env,
+			"SDIO_CLASS=%02X", func->class))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, 
+			"SDIO_ID=%04X:%04X", func->vendor, func->device))
+		return -ENOMEM;
+
+	if (add_uevent_var(env,
+			"MODALIAS=sdio:c%02Xv%04Xd%04X",
+			func->class, func->vendor, func->device))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int sdio_bus_probe(struct device *dev)
+{
+	struct sdio_driver *drv = to_sdio_driver(dev->driver);
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	const struct sdio_device_id *id;
+	//int ret = 0;
+
+	id = sdio_match_device(func, drv);
+	if (!id)
+		return -ENODEV;
+
+	/* Set the default block size so the driver is sure it's something
+	 * sensible. */
+	/*sdio_claim_host(func);
+	ret = sdio_set_block_size(func, 0);
+	sdio_release_host(func);
+	if (ret)
+		return ret;*/
+
+	return drv->probe(func, id);
+}
+
+static int sdio_bus_remove(struct device *dev)
+{
+	struct sdio_driver *drv = to_sdio_driver(dev->driver);
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	drv->remove(func);
+
+	if (func->irq_handler) {
+		printk(KERN_WARNING "WARNING: driver %s did not remove "
+			"its interrupt handler!\n", drv->name);
+		sdio_claim_host(func);
+		sdio_release_irq(func);
+		sdio_release_host(func);
+	}
+
+	return 0;
+}
+
+static struct bus_type sdio_bus_type = {
+	.name		= "sdio",
+	.dev_attrs	= sdio_dev_attrs,
+	.match		= sdio_bus_match,
+	.uevent		= sdio_bus_uevent,
+	.probe		= sdio_bus_probe,
+	.remove		= sdio_bus_remove,
+};
+
+int sdio_register_bus(void)
+{
+	return bus_register(&sdio_bus_type);
+}
+
+void sdio_unregister_bus(void)
+{
+	bus_unregister(&sdio_bus_type);
+}
+
+/**
+ *	sdio_register_driver - register a function driver
+ *	@drv: SDIO function driver
+ */
+int sdio_register_driver(struct sdio_driver *drv)
+{
+	drv->drv.name = drv->name;
+	drv->drv.bus = &sdio_bus_type;
+	return driver_register(&drv->drv);
+}
+EXPORT_SYMBOL_GPL(sdio_register_driver);
+
+/**
+ *	sdio_unregister_driver - unregister a function driver
+ *	@drv: SDIO function driver
+ */
+void sdio_unregister_driver(struct sdio_driver *drv)
+{
+	drv->drv.bus = &sdio_bus_type;
+	driver_unregister(&drv->drv);
+}
+EXPORT_SYMBOL_GPL(sdio_unregister_driver);
+
+static void sdio_release_func(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+
+	//sdio_free_func_cis(func);
+
+	if (func->info)
+		kfree(func->info);
+
+	kfree(func);
+}
+
+/*
+ * Allocate and initialise a new SDIO function structure.
+ */
+struct sdio_func *sdio_alloc_func(struct memory_card *card)
+{
+	struct sdio_func *func;
+
+	func = kzalloc(sizeof(struct sdio_func), GFP_KERNEL);
+	if (!func)
+		return ERR_PTR(-ENOMEM);
+
+	func->card = card;
+
+	device_initialize(&func->dev);
+
+	func->dev.parent = &card->dev;
+	func->dev.bus = &sdio_bus_type;
+	func->dev.release = sdio_release_func;
+
+	return func;
+}
+
+/*
+ * Register a new SDIO function with the driver model.
+ */
+int sdio_add_func(struct sdio_func *func)
+{
+	int ret;
+
+	dev_set_name(&func->dev, "%s:%d", card_card_id(func->card), func->num);
+
+	ret = device_add(&func->dev);
+	if (ret == 0)
+		sdio_func_set_present(func);
+
+	return ret;
+}
+
+/*
+ * Unregister a SDIO function with the driver model, and
+ * (eventually) free it.
+ * This function can be called through error paths where sdio_add_func() was
+ * never executed (because a failure occurred at an earlier point).
+ */
+void sdio_remove_func(struct sdio_func *func)
+{
+	if (!sdio_func_present(func))
+		return;
+
+	device_del(&func->dev);
+	put_device(&func->dev);
+}
+
